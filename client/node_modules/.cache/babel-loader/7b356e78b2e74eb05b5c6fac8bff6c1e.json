{"ast":null,"code":"/*!\n * Module requirements.\n */\n'use strict';\n\nconst castArraysOfNumbers = require('./helpers').castArraysOfNumbers;\n\nconst castToNumber = require('./helpers').castToNumber;\n/*!\n * ignore\n */\n\n\nexports.cast$geoIntersects = cast$geoIntersects;\nexports.cast$near = cast$near;\nexports.cast$within = cast$within;\n\nfunction cast$near(val) {\n  const SchemaArray = require('../array');\n\n  if (Array.isArray(val)) {\n    castArraysOfNumbers(val, this);\n    return val;\n  }\n\n  _castMinMaxDistance(this, val);\n\n  if (val && val.$geometry) {\n    return cast$geometry(val, this);\n  }\n\n  return SchemaArray.prototype.castForQuery.call(this, val);\n}\n\nfunction cast$geometry(val, self) {\n  switch (val.$geometry.type) {\n    case 'Polygon':\n    case 'LineString':\n    case 'Point':\n      castArraysOfNumbers(val.$geometry.coordinates, self);\n      break;\n\n    default:\n      // ignore unknowns\n      break;\n  }\n\n  _castMinMaxDistance(self, val);\n\n  return val;\n}\n\nfunction cast$within(val) {\n  _castMinMaxDistance(this, val);\n\n  if (val.$box || val.$polygon) {\n    const type = val.$box ? '$box' : '$polygon';\n    val[type].forEach(arr => {\n      if (!Array.isArray(arr)) {\n        const msg = 'Invalid $within $box argument. ' + 'Expected an array, received ' + arr;\n        throw new TypeError(msg);\n      }\n\n      arr.forEach((v, i) => {\n        arr[i] = castToNumber.call(this, v);\n      });\n    });\n  } else if (val.$center || val.$centerSphere) {\n    const type = val.$center ? '$center' : '$centerSphere';\n    val[type].forEach((item, i) => {\n      if (Array.isArray(item)) {\n        item.forEach((v, j) => {\n          item[j] = castToNumber.call(this, v);\n        });\n      } else {\n        val[type][i] = castToNumber.call(this, item);\n      }\n    });\n  } else if (val.$geometry) {\n    cast$geometry(val, this);\n  }\n\n  return val;\n}\n\nfunction cast$geoIntersects(val) {\n  const geo = val.$geometry;\n\n  if (!geo) {\n    return;\n  }\n\n  cast$geometry(val, this);\n  return val;\n}\n\nfunction _castMinMaxDistance(self, val) {\n  if (val.$maxDistance) {\n    val.$maxDistance = castToNumber.call(self, val.$maxDistance);\n  }\n\n  if (val.$minDistance) {\n    val.$minDistance = castToNumber.call(self, val.$minDistance);\n  }\n}","map":{"version":3,"sources":["D:/Other/Git/Developer-Connector/node_modules/mongoose/lib/schema/operators/geospatial.js"],"names":["castArraysOfNumbers","require","castToNumber","exports","cast$geoIntersects","cast$near","cast$within","val","SchemaArray","Array","isArray","_castMinMaxDistance","$geometry","cast$geometry","prototype","castForQuery","call","self","type","coordinates","$box","$polygon","forEach","arr","msg","TypeError","v","i","$center","$centerSphere","item","j","geo","$maxDistance","$minDistance"],"mappings":"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","sourcesContent":["/*!\n * Module requirements.\n */\n\n'use strict';\n\nconst castArraysOfNumbers = require('./helpers').castArraysOfNumbers;\nconst castToNumber = require('./helpers').castToNumber;\n\n/*!\n * ignore\n */\n\nexports.cast$geoIntersects = cast$geoIntersects;\nexports.cast$near = cast$near;\nexports.cast$within = cast$within;\n\nfunction cast$near(val) {\n  const SchemaArray = require('../array');\n\n  if (Array.isArray(val)) {\n    castArraysOfNumbers(val, this);\n    return val;\n  }\n\n  _castMinMaxDistance(this, val);\n\n  if (val && val.$geometry) {\n    return cast$geometry(val, this);\n  }\n\n  return SchemaArray.prototype.castForQuery.call(this, val);\n}\n\nfunction cast$geometry(val, self) {\n  switch (val.$geometry.type) {\n    case 'Polygon':\n    case 'LineString':\n    case 'Point':\n      castArraysOfNumbers(val.$geometry.coordinates, self);\n      break;\n    default:\n      // ignore unknowns\n      break;\n  }\n\n  _castMinMaxDistance(self, val);\n\n  return val;\n}\n\nfunction cast$within(val) {\n  _castMinMaxDistance(this, val);\n\n  if (val.$box || val.$polygon) {\n    const type = val.$box ? '$box' : '$polygon';\n    val[type].forEach(arr => {\n      if (!Array.isArray(arr)) {\n        const msg = 'Invalid $within $box argument. '\n            + 'Expected an array, received ' + arr;\n        throw new TypeError(msg);\n      }\n      arr.forEach((v, i) => {\n        arr[i] = castToNumber.call(this, v);\n      });\n    });\n  } else if (val.$center || val.$centerSphere) {\n    const type = val.$center ? '$center' : '$centerSphere';\n    val[type].forEach((item, i) => {\n      if (Array.isArray(item)) {\n        item.forEach((v, j) => {\n          item[j] = castToNumber.call(this, v);\n        });\n      } else {\n        val[type][i] = castToNumber.call(this, item);\n      }\n    });\n  } else if (val.$geometry) {\n    cast$geometry(val, this);\n  }\n\n  return val;\n}\n\nfunction cast$geoIntersects(val) {\n  const geo = val.$geometry;\n  if (!geo) {\n    return;\n  }\n\n  cast$geometry(val, this);\n  return val;\n}\n\nfunction _castMinMaxDistance(self, val) {\n  if (val.$maxDistance) {\n    val.$maxDistance = castToNumber.call(self, val.$maxDistance);\n  }\n  if (val.$minDistance) {\n    val.$minDistance = castToNumber.call(self, val.$minDistance);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}