{"ast":null,"code":"'use strict';\n/*!\n * Module dependencies.\n */\n\nconst ArrayType = require('./array');\n\nconst CastError = require('../error/cast');\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst SchemaDocumentArrayOptions = require('../options/SchemaDocumentArrayOptions');\n\nconst SchemaType = require('../schematype');\n\nconst discriminator = require('../helpers/model/discriminator');\n\nconst get = require('../helpers/get');\n\nconst util = require('util');\n\nconst utils = require('../utils');\n\nconst getConstructor = require('../helpers/discriminator/getConstructor');\n\nconst arrayParentSymbol = require('../helpers/symbols').arrayParentSymbol;\n\nconst arrayPathSymbol = require('../helpers/symbols').arrayPathSymbol;\n\nlet MongooseDocumentArray;\nlet Subdocument;\n/**\n * SubdocsArray SchemaType constructor\n *\n * @param {String} key\n * @param {Schema} schema\n * @param {Object} options\n * @inherits SchemaArray\n * @api public\n */\n\nfunction DocumentArrayPath(key, schema, options, schemaOptions) {\n  const EmbeddedDocument = _createConstructor(schema, options);\n\n  EmbeddedDocument.prototype.$basePath = key;\n  ArrayType.call(this, key, EmbeddedDocument, options);\n  this.schema = schema;\n  this.schemaOptions = schemaOptions || {};\n  this.$isMongooseDocumentArray = true;\n  this.Constructor = EmbeddedDocument;\n  EmbeddedDocument.base = schema.base;\n  const fn = this.defaultValue;\n\n  if (!('defaultValue' in this) || fn !== void 0) {\n    this.default(function () {\n      let arr = fn.call(this);\n\n      if (!Array.isArray(arr)) {\n        arr = [arr];\n      } // Leave it up to `cast()` to convert this to a documentarray\n\n\n      return arr;\n    });\n  }\n\n  const parentSchemaType = this;\n  this.$embeddedSchemaType = new SchemaType(key + '.$', {\n    required: get(this, 'schemaOptions.required', false)\n  });\n\n  this.$embeddedSchemaType.cast = function (value, doc, init) {\n    return parentSchemaType.cast(value, doc, init)[0];\n  };\n\n  this.$embeddedSchemaType.$isMongooseDocumentArrayElement = true;\n  this.$embeddedSchemaType.caster = this.Constructor;\n  this.$embeddedSchemaType.schema = this.schema;\n}\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\n\n\nDocumentArrayPath.schemaName = 'DocumentArray';\n/**\n * Options for all document arrays.\n *\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n *\n * @api public\n */\n\nDocumentArrayPath.options = {\n  castNonArrays: true\n};\n/*!\n * Inherits from ArrayType.\n */\n\nDocumentArrayPath.prototype = Object.create(ArrayType.prototype);\nDocumentArrayPath.prototype.constructor = DocumentArrayPath;\nDocumentArrayPath.prototype.OptionsConstructor = SchemaDocumentArrayOptions;\n/*!\n * Ignore\n */\n\nfunction _createConstructor(schema, options, baseClass) {\n  Subdocument || (Subdocument = require('../types/embedded')); // compile an embedded document for this schema\n\n  function EmbeddedDocument() {\n    Subdocument.apply(this, arguments);\n    this.$session(this.ownerDocument().$session());\n  }\n\n  const proto = baseClass != null ? baseClass.prototype : Subdocument.prototype;\n  EmbeddedDocument.prototype = Object.create(proto);\n  EmbeddedDocument.prototype.$__setSchema(schema);\n  EmbeddedDocument.schema = schema;\n  EmbeddedDocument.prototype.constructor = EmbeddedDocument;\n  EmbeddedDocument.$isArraySubdocument = true;\n  EmbeddedDocument.events = new EventEmitter(); // apply methods\n\n  for (const i in schema.methods) {\n    EmbeddedDocument.prototype[i] = schema.methods[i];\n  } // apply statics\n\n\n  for (const i in schema.statics) {\n    EmbeddedDocument[i] = schema.statics[i];\n  }\n\n  for (const i in EventEmitter.prototype) {\n    EmbeddedDocument[i] = EventEmitter.prototype[i];\n  }\n\n  EmbeddedDocument.options = options;\n  return EmbeddedDocument;\n}\n/**\n * Adds a discriminator to this document array.\n *\n * ####Example:\n *     const shapeSchema = Schema({ name: String }, { discriminatorKey: 'kind' });\n *     const schema = Schema({ shapes: [shapeSchema] });\n *\n *     const docArrayPath = parentSchema.path('shapes');\n *     docArrayPath.discriminator('Circle', Schema({ radius: Number }));\n *\n * @param {String} name\n * @param {Schema} schema fields to add to the schema for instances of this sub-class\n * @param {String} [value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n * @see discriminators /docs/discriminators.html\n * @return {Function} the constructor Mongoose will use for creating instances of this discriminator model\n * @api public\n */\n\n\nDocumentArrayPath.prototype.discriminator = function (name, schema, tiedValue) {\n  if (typeof name === 'function') {\n    name = utils.getFunctionName(name);\n  }\n\n  schema = discriminator(this.casterConstructor, name, schema, tiedValue);\n\n  const EmbeddedDocument = _createConstructor(schema, null, this.casterConstructor);\n\n  EmbeddedDocument.baseCasterConstructor = this.casterConstructor;\n\n  try {\n    Object.defineProperty(EmbeddedDocument, 'name', {\n      value: name\n    });\n  } catch (error) {// Ignore error, only happens on old versions of node\n  }\n\n  this.casterConstructor.discriminators[name] = EmbeddedDocument;\n  return this.casterConstructor.discriminators[name];\n};\n/**\n * Performs local validations first, then validations on each embedded doc\n *\n * @api private\n */\n\n\nDocumentArrayPath.prototype.doValidate = function (array, fn, scope, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentarray'));\n\n  const _this = this;\n\n  try {\n    SchemaType.prototype.doValidate.call(this, array, cb, scope);\n  } catch (err) {\n    err.$isArrayValidatorError = true;\n    return fn(err);\n  }\n\n  function cb(err) {\n    if (err) {\n      err.$isArrayValidatorError = true;\n      return fn(err);\n    }\n\n    let count = array && array.length;\n    let error;\n\n    if (!count) {\n      return fn();\n    }\n\n    if (options && options.updateValidator) {\n      return fn();\n    }\n\n    if (!array.isMongooseDocumentArray) {\n      array = new MongooseDocumentArray(array, _this.path, scope);\n    } // handle sparse arrays, do not use array.forEach which does not\n    // iterate over sparse elements yet reports array.length including\n    // them :(\n\n\n    function callback(err) {\n      if (err != null) {\n        error = err;\n\n        if (error.name !== 'ValidationError') {\n          error.$isArrayValidatorError = true;\n        }\n      }\n\n      --count || fn(error);\n    }\n\n    for (let i = 0, len = count; i < len; ++i) {\n      // sidestep sparse entries\n      let doc = array[i];\n\n      if (doc == null) {\n        --count || fn(error);\n        continue;\n      } // If you set the array index directly, the doc might not yet be\n      // a full fledged mongoose subdoc, so make it into one.\n\n\n      if (!(doc instanceof Subdocument)) {\n        const Constructor = getConstructor(_this.casterConstructor, array[i]);\n        doc = array[i] = new Constructor(doc, array, undefined, undefined, i);\n      }\n\n      doc.$__validate(callback);\n    }\n  }\n};\n/**\n * Performs local validations first, then validations on each embedded doc.\n *\n * ####Note:\n *\n * This method ignores the asynchronous validators.\n *\n * @return {MongooseError|undefined}\n * @api private\n */\n\n\nDocumentArrayPath.prototype.doValidateSync = function (array, scope) {\n  const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, array, scope);\n\n  if (schemaTypeError != null) {\n    schemaTypeError.$isArrayValidatorError = true;\n    return schemaTypeError;\n  }\n\n  const count = array && array.length;\n  let resultError = null;\n\n  if (!count) {\n    return;\n  } // handle sparse arrays, do not use array.forEach which does not\n  // iterate over sparse elements yet reports array.length including\n  // them :(\n\n\n  for (let i = 0, len = count; i < len; ++i) {\n    // sidestep sparse entries\n    let doc = array[i];\n\n    if (!doc) {\n      continue;\n    } // If you set the array index directly, the doc might not yet be\n    // a full fledged mongoose subdoc, so make it into one.\n\n\n    if (!(doc instanceof Subdocument)) {\n      const Constructor = getConstructor(this.casterConstructor, array[i]);\n      doc = array[i] = new Constructor(doc, array, undefined, undefined, i);\n    }\n\n    const subdocValidateError = doc.validateSync();\n\n    if (subdocValidateError && resultError == null) {\n      resultError = subdocValidateError;\n    }\n  }\n\n  return resultError;\n};\n/*!\n * ignore\n */\n\n\nDocumentArrayPath.prototype.getDefault = function (scope) {\n  let ret = typeof this.defaultValue === 'function' ? this.defaultValue.call(scope) : this.defaultValue;\n\n  if (ret == null) {\n    return ret;\n  } // lazy load\n\n\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentarray'));\n\n  if (!Array.isArray(ret)) {\n    ret = [ret];\n  }\n\n  ret = new MongooseDocumentArray(ret, this.path, scope);\n  const _parent = ret[arrayParentSymbol];\n  ret[arrayParentSymbol] = null;\n\n  for (let i = 0; i < ret.length; ++i) {\n    const Constructor = getConstructor(this.casterConstructor, ret[i]);\n    ret[i] = new Constructor(ret[i], ret, undefined, undefined, i);\n  }\n\n  ret[arrayParentSymbol] = _parent;\n  return ret;\n};\n/**\n * Casts contents\n *\n * @param {Object} value\n * @param {Document} document that triggers the casting\n * @api private\n */\n\n\nDocumentArrayPath.prototype.cast = function (value, doc, init, prev, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentarray'));\n  let selected;\n  let subdoc;\n  let i;\n  const _opts = {\n    transform: false,\n    virtuals: false\n  };\n\n  if (!Array.isArray(value)) {\n    if (!init && !DocumentArrayPath.options.castNonArrays) {\n      throw new CastError('DocumentArray', util.inspect(value), this.path);\n    } // gh-2442 mark whole array as modified if we're initializing a doc from\n    // the db and the path isn't an array in the document\n\n\n    if (!!doc && init) {\n      doc.markModified(this.path);\n    }\n\n    return this.cast([value], doc, init, prev);\n  }\n\n  if (!(value && value.isMongooseDocumentArray) && (!options || !options.skipDocumentArrayCast)) {\n    value = new MongooseDocumentArray(value, this.path, doc);\n  } else if (value && value.isMongooseDocumentArray) {\n    // We need to create a new array, otherwise change tracking will\n    // update the old doc (gh-4449)\n    value = new MongooseDocumentArray(value, this.path, doc);\n  }\n\n  i = value.length;\n\n  while (i--) {\n    if (!value[i]) {\n      continue;\n    }\n\n    const Constructor = getConstructor(this.casterConstructor, value[i]); // Check if the document has a different schema (re gh-3701)\n\n    if (value[i].$__ && !(value[i] instanceof Constructor)) {\n      value[i] = value[i].toObject({\n        transform: false,\n        // Special case: if different model, but same schema, apply virtuals\n        // re: gh-7898\n        virtuals: value[i].schema === Constructor.schema\n      });\n    }\n\n    if (value[i] instanceof Subdocument) {\n      // Might not have the correct index yet, so ensure it does.\n      if (value[i].__index == null) {\n        value[i].$setIndex(i);\n      }\n    } else if (value[i] != null) {\n      if (init) {\n        if (doc) {\n          selected || (selected = scopePaths(this, doc.$__.selected, init));\n        } else {\n          selected = true;\n        }\n\n        subdoc = new Constructor(null, value, true, selected, i);\n        value[i] = subdoc.init(value[i]);\n      } else {\n        if (prev && typeof prev.id === 'function') {\n          subdoc = prev.id(value[i]._id);\n        }\n\n        if (prev && subdoc && utils.deepEqual(subdoc.toObject(_opts), value[i])) {\n          // handle resetting doc with existing id and same data\n          subdoc.set(value[i]); // if set() is hooked it will have no return value\n          // see gh-746\n\n          value[i] = subdoc;\n        } else {\n          try {\n            subdoc = new Constructor(value[i], value, undefined, undefined, i); // if set() is hooked it will have no return value\n            // see gh-746\n\n            value[i] = subdoc;\n          } catch (error) {\n            const valueInErrorMessage = util.inspect(value[i]);\n            throw new CastError('embedded', valueInErrorMessage, value[arrayPathSymbol], error);\n          }\n        }\n      }\n    }\n  }\n\n  return value;\n};\n/*!\n * ignore\n */\n\n\nDocumentArrayPath.prototype.clone = function () {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, this.schema, options, this.schemaOptions);\n  schematype.validators = this.validators.slice();\n  schematype.Constructor.discriminators = Object.assign({}, this.Constructor.discriminators);\n  return schematype;\n};\n/*!\n * Scopes paths selected in a query to this array.\n * Necessary for proper default application of subdocument values.\n *\n * @param {DocumentArrayPath} array - the array to scope `fields` paths\n * @param {Object|undefined} fields - the root fields selected in the query\n * @param {Boolean|undefined} init - if we are being created part of a query result\n */\n\n\nfunction scopePaths(array, fields, init) {\n  if (!(init && fields)) {\n    return undefined;\n  }\n\n  const path = array.path + '.';\n  const keys = Object.keys(fields);\n  let i = keys.length;\n  const selected = {};\n  let hasKeys;\n  let key;\n  let sub;\n\n  while (i--) {\n    key = keys[i];\n\n    if (key.startsWith(path)) {\n      sub = key.substring(path.length);\n\n      if (sub === '$') {\n        continue;\n      }\n\n      if (sub.startsWith('$.')) {\n        sub = sub.substr(2);\n      }\n\n      hasKeys || (hasKeys = true);\n      selected[sub] = fields[key];\n    }\n  }\n\n  return hasKeys && selected || undefined;\n}\n/*!\n * Module exports.\n */\n\n\nmodule.exports = DocumentArrayPath;","map":{"version":3,"sources":["D:/Other/Git/Developer-Connector/node_modules/mongoose/lib/schema/documentarray.js"],"names":["ArrayType","require","CastError","EventEmitter","SchemaDocumentArrayOptions","SchemaType","discriminator","get","util","utils","getConstructor","arrayParentSymbol","arrayPathSymbol","MongooseDocumentArray","Subdocument","DocumentArrayPath","key","schema","options","schemaOptions","EmbeddedDocument","_createConstructor","prototype","$basePath","call","$isMongooseDocumentArray","Constructor","base","fn","defaultValue","default","arr","Array","isArray","parentSchemaType","$embeddedSchemaType","required","cast","value","doc","init","$isMongooseDocumentArrayElement","caster","schemaName","castNonArrays","Object","create","constructor","OptionsConstructor","baseClass","apply","arguments","$session","ownerDocument","proto","$__setSchema","$isArraySubdocument","events","i","methods","statics","name","tiedValue","getFunctionName","casterConstructor","baseCasterConstructor","defineProperty","error","discriminators","doValidate","array","scope","_this","cb","err","$isArrayValidatorError","count","length","updateValidator","isMongooseDocumentArray","path","callback","len","undefined","$__validate","doValidateSync","schemaTypeError","resultError","subdocValidateError","validateSync","getDefault","ret","_parent","prev","selected","subdoc","_opts","transform","virtuals","inspect","markModified","skipDocumentArrayCast","$__","toObject","__index","$setIndex","scopePaths","id","_id","deepEqual","set","valueInErrorMessage","clone","assign","schematype","validators","slice","fields","keys","hasKeys","sub","startsWith","substring","substr","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst ArrayType = require('./array');\nconst CastError = require('../error/cast');\nconst EventEmitter = require('events').EventEmitter;\nconst SchemaDocumentArrayOptions =\n  require('../options/SchemaDocumentArrayOptions');\nconst SchemaType = require('../schematype');\nconst discriminator = require('../helpers/model/discriminator');\nconst get = require('../helpers/get');\nconst util = require('util');\nconst utils = require('../utils');\nconst getConstructor = require('../helpers/discriminator/getConstructor');\n\nconst arrayParentSymbol = require('../helpers/symbols').arrayParentSymbol;\nconst arrayPathSymbol = require('../helpers/symbols').arrayPathSymbol;\n\nlet MongooseDocumentArray;\nlet Subdocument;\n\n/**\n * SubdocsArray SchemaType constructor\n *\n * @param {String} key\n * @param {Schema} schema\n * @param {Object} options\n * @inherits SchemaArray\n * @api public\n */\n\nfunction DocumentArrayPath(key, schema, options, schemaOptions) {\n  const EmbeddedDocument = _createConstructor(schema, options);\n  EmbeddedDocument.prototype.$basePath = key;\n\n  ArrayType.call(this, key, EmbeddedDocument, options);\n\n  this.schema = schema;\n  this.schemaOptions = schemaOptions || {};\n  this.$isMongooseDocumentArray = true;\n  this.Constructor = EmbeddedDocument;\n\n  EmbeddedDocument.base = schema.base;\n\n  const fn = this.defaultValue;\n\n  if (!('defaultValue' in this) || fn !== void 0) {\n    this.default(function() {\n      let arr = fn.call(this);\n      if (!Array.isArray(arr)) {\n        arr = [arr];\n      }\n      // Leave it up to `cast()` to convert this to a documentarray\n      return arr;\n    });\n  }\n\n  const parentSchemaType = this;\n  this.$embeddedSchemaType = new SchemaType(key + '.$', {\n    required: get(this, 'schemaOptions.required', false)\n  });\n  this.$embeddedSchemaType.cast = function(value, doc, init) {\n    return parentSchemaType.cast(value, doc, init)[0];\n  };\n  this.$embeddedSchemaType.$isMongooseDocumentArrayElement = true;\n  this.$embeddedSchemaType.caster = this.Constructor;\n  this.$embeddedSchemaType.schema = this.schema;\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nDocumentArrayPath.schemaName = 'DocumentArray';\n\n/**\n * Options for all document arrays.\n *\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n *\n * @api public\n */\n\nDocumentArrayPath.options = { castNonArrays: true };\n\n/*!\n * Inherits from ArrayType.\n */\nDocumentArrayPath.prototype = Object.create(ArrayType.prototype);\nDocumentArrayPath.prototype.constructor = DocumentArrayPath;\nDocumentArrayPath.prototype.OptionsConstructor = SchemaDocumentArrayOptions;\n\n/*!\n * Ignore\n */\n\nfunction _createConstructor(schema, options, baseClass) {\n  Subdocument || (Subdocument = require('../types/embedded'));\n\n  // compile an embedded document for this schema\n  function EmbeddedDocument() {\n    Subdocument.apply(this, arguments);\n\n    this.$session(this.ownerDocument().$session());\n  }\n\n  const proto = baseClass != null ? baseClass.prototype : Subdocument.prototype;\n  EmbeddedDocument.prototype = Object.create(proto);\n  EmbeddedDocument.prototype.$__setSchema(schema);\n  EmbeddedDocument.schema = schema;\n  EmbeddedDocument.prototype.constructor = EmbeddedDocument;\n  EmbeddedDocument.$isArraySubdocument = true;\n  EmbeddedDocument.events = new EventEmitter();\n\n  // apply methods\n  for (const i in schema.methods) {\n    EmbeddedDocument.prototype[i] = schema.methods[i];\n  }\n\n  // apply statics\n  for (const i in schema.statics) {\n    EmbeddedDocument[i] = schema.statics[i];\n  }\n\n  for (const i in EventEmitter.prototype) {\n    EmbeddedDocument[i] = EventEmitter.prototype[i];\n  }\n\n  EmbeddedDocument.options = options;\n\n  return EmbeddedDocument;\n}\n\n/**\n * Adds a discriminator to this document array.\n *\n * ####Example:\n *     const shapeSchema = Schema({ name: String }, { discriminatorKey: 'kind' });\n *     const schema = Schema({ shapes: [shapeSchema] });\n *\n *     const docArrayPath = parentSchema.path('shapes');\n *     docArrayPath.discriminator('Circle', Schema({ radius: Number }));\n *\n * @param {String} name\n * @param {Schema} schema fields to add to the schema for instances of this sub-class\n * @param {String} [value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n * @see discriminators /docs/discriminators.html\n * @return {Function} the constructor Mongoose will use for creating instances of this discriminator model\n * @api public\n */\n\nDocumentArrayPath.prototype.discriminator = function(name, schema, tiedValue) {\n  if (typeof name === 'function') {\n    name = utils.getFunctionName(name);\n  }\n\n  schema = discriminator(this.casterConstructor, name, schema, tiedValue);\n\n  const EmbeddedDocument = _createConstructor(schema, null, this.casterConstructor);\n  EmbeddedDocument.baseCasterConstructor = this.casterConstructor;\n\n  try {\n    Object.defineProperty(EmbeddedDocument, 'name', {\n      value: name\n    });\n  } catch (error) {\n    // Ignore error, only happens on old versions of node\n  }\n\n  this.casterConstructor.discriminators[name] = EmbeddedDocument;\n\n  return this.casterConstructor.discriminators[name];\n};\n\n/**\n * Performs local validations first, then validations on each embedded doc\n *\n * @api private\n */\n\nDocumentArrayPath.prototype.doValidate = function(array, fn, scope, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentarray'));\n\n  const _this = this;\n  try {\n    SchemaType.prototype.doValidate.call(this, array, cb, scope);\n  } catch (err) {\n    err.$isArrayValidatorError = true;\n    return fn(err);\n  }\n\n  function cb(err) {\n    if (err) {\n      err.$isArrayValidatorError = true;\n      return fn(err);\n    }\n\n    let count = array && array.length;\n    let error;\n\n    if (!count) {\n      return fn();\n    }\n    if (options && options.updateValidator) {\n      return fn();\n    }\n    if (!array.isMongooseDocumentArray) {\n      array = new MongooseDocumentArray(array, _this.path, scope);\n    }\n\n    // handle sparse arrays, do not use array.forEach which does not\n    // iterate over sparse elements yet reports array.length including\n    // them :(\n\n    function callback(err) {\n      if (err != null) {\n        error = err;\n        if (error.name !== 'ValidationError') {\n          error.$isArrayValidatorError = true;\n        }\n      }\n      --count || fn(error);\n    }\n\n    for (let i = 0, len = count; i < len; ++i) {\n      // sidestep sparse entries\n      let doc = array[i];\n      if (doc == null) {\n        --count || fn(error);\n        continue;\n      }\n\n      // If you set the array index directly, the doc might not yet be\n      // a full fledged mongoose subdoc, so make it into one.\n      if (!(doc instanceof Subdocument)) {\n        const Constructor = getConstructor(_this.casterConstructor, array[i]);\n        doc = array[i] = new Constructor(doc, array, undefined, undefined, i);\n      }\n\n      doc.$__validate(callback);\n    }\n  }\n};\n\n/**\n * Performs local validations first, then validations on each embedded doc.\n *\n * ####Note:\n *\n * This method ignores the asynchronous validators.\n *\n * @return {MongooseError|undefined}\n * @api private\n */\n\nDocumentArrayPath.prototype.doValidateSync = function(array, scope) {\n  const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, array, scope);\n  if (schemaTypeError != null) {\n    schemaTypeError.$isArrayValidatorError = true;\n    return schemaTypeError;\n  }\n\n  const count = array && array.length;\n  let resultError = null;\n\n  if (!count) {\n    return;\n  }\n\n  // handle sparse arrays, do not use array.forEach which does not\n  // iterate over sparse elements yet reports array.length including\n  // them :(\n\n  for (let i = 0, len = count; i < len; ++i) {\n    // sidestep sparse entries\n    let doc = array[i];\n    if (!doc) {\n      continue;\n    }\n\n    // If you set the array index directly, the doc might not yet be\n    // a full fledged mongoose subdoc, so make it into one.\n    if (!(doc instanceof Subdocument)) {\n      const Constructor = getConstructor(this.casterConstructor, array[i]);\n      doc = array[i] = new Constructor(doc, array, undefined, undefined, i);\n    }\n\n    const subdocValidateError = doc.validateSync();\n\n    if (subdocValidateError && resultError == null) {\n      resultError = subdocValidateError;\n    }\n  }\n\n  return resultError;\n};\n\n/*!\n * ignore\n */\n\nDocumentArrayPath.prototype.getDefault = function(scope) {\n  let ret = typeof this.defaultValue === 'function'\n    ? this.defaultValue.call(scope)\n    : this.defaultValue;\n\n  if (ret == null) {\n    return ret;\n  }\n\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentarray'));\n\n  if (!Array.isArray(ret)) {\n    ret = [ret];\n  }\n\n  ret = new MongooseDocumentArray(ret, this.path, scope);\n  const _parent = ret[arrayParentSymbol];\n  ret[arrayParentSymbol] = null;\n\n  for (let i = 0; i < ret.length; ++i) {\n    const Constructor = getConstructor(this.casterConstructor, ret[i]);\n    ret[i] = new Constructor(ret[i], ret, undefined,\n      undefined, i);\n  }\n\n  ret[arrayParentSymbol] = _parent;\n\n  return ret;\n};\n\n/**\n * Casts contents\n *\n * @param {Object} value\n * @param {Document} document that triggers the casting\n * @api private\n */\n\nDocumentArrayPath.prototype.cast = function(value, doc, init, prev, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentarray'));\n\n  let selected;\n  let subdoc;\n  let i;\n  const _opts = { transform: false, virtuals: false };\n\n  if (!Array.isArray(value)) {\n    if (!init && !DocumentArrayPath.options.castNonArrays) {\n      throw new CastError('DocumentArray', util.inspect(value), this.path);\n    }\n    // gh-2442 mark whole array as modified if we're initializing a doc from\n    // the db and the path isn't an array in the document\n    if (!!doc && init) {\n      doc.markModified(this.path);\n    }\n    return this.cast([value], doc, init, prev);\n  }\n\n  if (!(value && value.isMongooseDocumentArray) &&\n      (!options || !options.skipDocumentArrayCast)) {\n    value = new MongooseDocumentArray(value, this.path, doc);\n  } else if (value && value.isMongooseDocumentArray) {\n    // We need to create a new array, otherwise change tracking will\n    // update the old doc (gh-4449)\n    value = new MongooseDocumentArray(value, this.path, doc);\n  }\n\n  i = value.length;\n\n  while (i--) {\n    if (!value[i]) {\n      continue;\n    }\n\n    const Constructor = getConstructor(this.casterConstructor, value[i]);\n\n    // Check if the document has a different schema (re gh-3701)\n    if ((value[i].$__) &&\n        !(value[i] instanceof Constructor)) {\n      value[i] = value[i].toObject({\n        transform: false,\n        // Special case: if different model, but same schema, apply virtuals\n        // re: gh-7898\n        virtuals: value[i].schema === Constructor.schema\n      });\n    }\n\n    if (value[i] instanceof Subdocument) {\n      // Might not have the correct index yet, so ensure it does.\n      if (value[i].__index == null) {\n        value[i].$setIndex(i);\n      }\n    } else if (value[i] != null) {\n      if (init) {\n        if (doc) {\n          selected || (selected = scopePaths(this, doc.$__.selected, init));\n        } else {\n          selected = true;\n        }\n\n        subdoc = new Constructor(null, value, true, selected, i);\n        value[i] = subdoc.init(value[i]);\n      } else {\n        if (prev && typeof prev.id === 'function') {\n          subdoc = prev.id(value[i]._id);\n        }\n\n        if (prev && subdoc && utils.deepEqual(subdoc.toObject(_opts), value[i])) {\n          // handle resetting doc with existing id and same data\n          subdoc.set(value[i]);\n          // if set() is hooked it will have no return value\n          // see gh-746\n          value[i] = subdoc;\n        } else {\n          try {\n            subdoc = new Constructor(value[i], value, undefined,\n              undefined, i);\n            // if set() is hooked it will have no return value\n            // see gh-746\n            value[i] = subdoc;\n          } catch (error) {\n            const valueInErrorMessage = util.inspect(value[i]);\n            throw new CastError('embedded', valueInErrorMessage,\n              value[arrayPathSymbol], error);\n          }\n        }\n      }\n    }\n  }\n\n  return value;\n};\n\n/*!\n * ignore\n */\n\nDocumentArrayPath.prototype.clone = function() {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, this.schema, options, this.schemaOptions);\n  schematype.validators = this.validators.slice();\n  schematype.Constructor.discriminators = Object.assign({},\n    this.Constructor.discriminators);\n  return schematype;\n};\n\n/*!\n * Scopes paths selected in a query to this array.\n * Necessary for proper default application of subdocument values.\n *\n * @param {DocumentArrayPath} array - the array to scope `fields` paths\n * @param {Object|undefined} fields - the root fields selected in the query\n * @param {Boolean|undefined} init - if we are being created part of a query result\n */\n\nfunction scopePaths(array, fields, init) {\n  if (!(init && fields)) {\n    return undefined;\n  }\n\n  const path = array.path + '.';\n  const keys = Object.keys(fields);\n  let i = keys.length;\n  const selected = {};\n  let hasKeys;\n  let key;\n  let sub;\n\n  while (i--) {\n    key = keys[i];\n    if (key.startsWith(path)) {\n      sub = key.substring(path.length);\n      if (sub === '$') {\n        continue;\n      }\n      if (sub.startsWith('$.')) {\n        sub = sub.substr(2);\n      }\n      hasKeys || (hasKeys = true);\n      selected[sub] = fields[key];\n    }\n  }\n\n  return hasKeys && selected || undefined;\n}\n\n/*!\n * Module exports.\n */\n\nmodule.exports = DocumentArrayPath;\n"]},"metadata":{},"sourceType":"script"}