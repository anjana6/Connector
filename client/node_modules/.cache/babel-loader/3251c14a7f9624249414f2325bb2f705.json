{"ast":null,"code":"'use strict';\n/*!\n * Module dependencies.\n */\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst InternalCache = require('./internal');\n\nconst MongooseError = require('./error/index');\n\nconst MixedSchema = require('./schema/mixed');\n\nconst ObjectExpectedError = require('./error/objectExpected');\n\nconst ObjectParameterError = require('./error/objectParameter');\n\nconst Schema = require('./schema');\n\nconst StrictModeError = require('./error/strict');\n\nconst ValidatorError = require('./schematype').ValidatorError;\n\nconst VirtualType = require('./virtualtype');\n\nconst cleanModifiedSubpaths = require('./helpers/document/cleanModifiedSubpaths');\n\nconst compile = require('./helpers/document/compile').compile;\n\nconst defineKey = require('./helpers/document/compile').defineKey;\n\nconst flatten = require('./helpers/common').flatten;\n\nconst get = require('./helpers/get');\n\nconst getEmbeddedDiscriminatorPath = require('./helpers/document/getEmbeddedDiscriminatorPath');\n\nconst idGetter = require('./plugins/idGetter');\n\nconst isDefiningProjection = require('./helpers/projection/isDefiningProjection');\n\nconst isExclusive = require('./helpers/projection/isExclusive');\n\nconst inspect = require('util').inspect;\n\nconst internalToObjectOptions = require('./options').internalToObjectOptions;\n\nconst mpath = require('mpath');\n\nconst utils = require('./utils');\n\nconst ValidationError = MongooseError.ValidationError;\nconst clone = utils.clone;\nconst deepEqual = utils.deepEqual;\nconst isMongooseObject = utils.isMongooseObject;\n\nconst arrayAtomicsSymbol = require('./helpers/symbols').arrayAtomicsSymbol;\n\nconst documentArrayParent = require('./helpers/symbols').documentArrayParent;\n\nconst documentSchemaSymbol = require('./helpers/symbols').documentSchemaSymbol;\n\nconst getSymbol = require('./helpers/symbols').getSymbol;\n\nconst populateModelSymbol = require('./helpers/symbols').populateModelSymbol;\n\nlet DocumentArray;\nlet MongooseArray;\nlet Embedded;\nconst specialProperties = utils.specialProperties;\n/**\n * The core Mongoose document constructor. You should not call this directly,\n * the Mongoose [Model constructor](./api.html#Model) calls this for you.\n *\n * @param {Object} obj the values to set\n * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data\n * @param {Boolean} [skipId] bool, should we auto create an ObjectId _id\n * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter\n * @event `init`: Emitted on a document after it has was retreived from the db and fully hydrated by Mongoose.\n * @event `save`: Emitted when the document is successfully saved\n * @api private\n */\n\nfunction Document(obj, fields, skipId, options) {\n  if (typeof skipId === 'object' && skipId != null) {\n    options = skipId;\n    skipId = options.skipId;\n  }\n\n  options = options || {}; // Support `browserDocument.js` syntax\n\n  if (this.schema == null) {\n    const _schema = utils.isObject(fields) && !fields.instanceOfSchema ? new Schema(fields) : fields;\n\n    this.$__setSchema(_schema);\n    fields = skipId;\n    skipId = options;\n    options = arguments[4] || {};\n  }\n\n  this.$__ = new InternalCache();\n  this.$__.emitter = new EventEmitter();\n  this.isNew = 'isNew' in options ? options.isNew : true;\n  this.errors = undefined;\n  this.$__.$options = options || {};\n\n  if (obj != null && typeof obj !== 'object') {\n    throw new ObjectParameterError(obj, 'obj', 'Document');\n  }\n\n  const schema = this.schema;\n\n  if (typeof fields === 'boolean') {\n    this.$__.strictMode = fields;\n    fields = undefined;\n  } else {\n    this.$__.strictMode = schema.options.strict;\n    this.$__.selected = fields;\n  }\n\n  const required = schema.requiredPaths(true);\n\n  for (let i = 0; i < required.length; ++i) {\n    this.$__.activePaths.require(required[i]);\n  }\n\n  this.$__.emitter.setMaxListeners(0);\n  let exclude = null; // determine if this doc is a result of a query with\n  // excluded fields\n\n  if (utils.isPOJO(fields)) {\n    exclude = isExclusive(fields);\n  }\n\n  const hasIncludedChildren = exclude === false && fields ? $__hasIncludedChildren(fields) : {};\n\n  if (this._doc == null) {\n    this.$__buildDoc(obj, fields, skipId, exclude, hasIncludedChildren, false); // By default, defaults get applied **before** setting initial values\n    // Re: gh-6155\n\n    $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, true, {\n      isNew: this.isNew\n    });\n  }\n\n  if (obj) {\n    if (obj instanceof Document) {\n      this.isNew = obj.isNew;\n    } // Skip set hooks\n\n\n    if (this.$__original_set) {\n      this.$__original_set(obj, undefined, true);\n    } else {\n      this.$set(obj, undefined, true);\n    }\n  } // Function defaults get applied **after** setting initial values so they\n  // see the full doc rather than an empty one, unless they opt out.\n  // Re: gh-3781, gh-6155\n\n\n  if (options.willInit) {\n    EventEmitter.prototype.once.call(this, 'init', () => {\n      $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, false, options.skipDefaults, {\n        isNew: this.isNew\n      });\n    });\n  } else {\n    $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, false, options.skipDefaults, {\n      isNew: this.isNew\n    });\n  }\n\n  this.$__._id = this._id;\n  this.$locals = {};\n\n  if (!schema.options.strict && obj) {\n    const _this = this;\n\n    const keys = Object.keys(this._doc);\n    keys.forEach(function (key) {\n      if (!(key in schema.tree)) {\n        defineKey(key, null, _this);\n      }\n    });\n  }\n\n  applyQueue(this);\n}\n/*!\n * Document exposes the NodeJS event emitter API, so you can use\n * `on`, `once`, etc.\n */\n\n\nutils.each(['on', 'once', 'emit', 'listeners', 'removeListener', 'setMaxListeners', 'removeAllListeners', 'addListener'], function (emitterFn) {\n  Document.prototype[emitterFn] = function () {\n    return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n  };\n});\nDocument.prototype.constructor = Document;\n\nfor (const i in EventEmitter.prototype) {\n  Document[i] = EventEmitter.prototype[i];\n}\n/**\n * The documents schema.\n *\n * @api public\n * @property schema\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.schema;\n/**\n * Empty object that you can use for storing properties on the document. This\n * is handy for passing data to middleware without conflicting with Mongoose\n * internals.\n *\n * ####Example:\n *\n *     schema.pre('save', function() {\n *       // Mongoose will set `isNew` to `false` if `save()` succeeds\n *       this.$locals.wasNew = this.isNew;\n *     });\n *\n *     schema.post('save', function() {\n *       // Prints true if `isNew` was set before `save()`\n *       console.log(this.$locals.wasNew);\n *     });\n *\n * @api public\n * @property $locals\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, '$locals', {\n  configurable: false,\n  enumerable: false,\n  writable: true\n});\n/**\n * Boolean flag specifying if the document is new.\n *\n * @api public\n * @property isNew\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.isNew;\n/**\n * The string version of this documents _id.\n *\n * ####Note:\n *\n * This getter exists on all documents by default. The getter can be disabled by setting the `id` [option](/docs/guide.html#id) of its `Schema` to false at construction time.\n *\n *     new Schema({ name: String }, { id: false });\n *\n * @api public\n * @see Schema options /docs/guide.html#options\n * @property id\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.id;\n/**\n * Hash containing current validation errors.\n *\n * @api public\n * @property errors\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.errors;\n/*!\n * ignore\n */\n\nfunction $__hasIncludedChildren(fields) {\n  const hasIncludedChildren = {};\n  const keys = Object.keys(fields);\n\n  for (let j = 0; j < keys.length; ++j) {\n    const parts = keys[j].split('.');\n    const c = [];\n\n    for (let k = 0; k < parts.length; ++k) {\n      c.push(parts[k]);\n      hasIncludedChildren[c.join('.')] = 1;\n    }\n  }\n\n  return hasIncludedChildren;\n}\n/*!\n * ignore\n */\n\n\nfunction $__applyDefaults(doc, fields, skipId, exclude, hasIncludedChildren, isBeforeSetters, pathsToSkip) {\n  const paths = Object.keys(doc.schema.paths);\n  const plen = paths.length;\n\n  for (let i = 0; i < plen; ++i) {\n    let def;\n    let curPath = '';\n    const p = paths[i];\n\n    if (p === '_id' && skipId) {\n      continue;\n    }\n\n    const type = doc.schema.paths[p];\n    const path = p.split('.');\n    const len = path.length;\n    let included = false;\n    let doc_ = doc._doc;\n\n    for (let j = 0; j < len; ++j) {\n      if (doc_ == null) {\n        break;\n      }\n\n      const piece = path[j];\n      curPath += (!curPath.length ? '' : '.') + piece;\n\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (j === len - 1) {\n        if (doc_[piece] !== void 0) {\n          break;\n        }\n\n        if (typeof type.defaultValue === 'function') {\n          if (!type.defaultValue.$runBeforeSetters && isBeforeSetters) {\n            break;\n          }\n\n          if (type.defaultValue.$runBeforeSetters && !isBeforeSetters) {\n            break;\n          }\n        } else if (!isBeforeSetters) {\n          // Non-function defaults should always run **before** setters\n          continue;\n        }\n\n        if (pathsToSkip && pathsToSkip[curPath]) {\n          break;\n        }\n\n        if (fields && exclude !== null) {\n          if (exclude === true) {\n            // apply defaults to all non-excluded fields\n            if (p in fields) {\n              continue;\n            }\n\n            def = type.getDefault(doc, false);\n\n            if (typeof def !== 'undefined') {\n              doc_[piece] = def;\n              doc.$__.activePaths.default(p);\n            }\n          } else if (included) {\n            // selected field\n            def = type.getDefault(doc, false);\n\n            if (typeof def !== 'undefined') {\n              doc_[piece] = def;\n              doc.$__.activePaths.default(p);\n            }\n          }\n        } else {\n          def = type.getDefault(doc, false);\n\n          if (typeof def !== 'undefined') {\n            doc_[piece] = def;\n            doc.$__.activePaths.default(p);\n          }\n        }\n      } else {\n        doc_ = doc_[piece];\n      }\n    }\n  }\n}\n/**\n * Builds the default doc structure\n *\n * @param {Object} obj\n * @param {Object} [fields]\n * @param {Boolean} [skipId]\n * @api private\n * @method $__buildDoc\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.$__buildDoc = function (obj, fields, skipId, exclude, hasIncludedChildren) {\n  const doc = {};\n  const paths = Object.keys(this.schema.paths). // Don't build up any paths that are underneath a map, we don't know\n  // what the keys will be\n  filter(p => !p.includes('$*'));\n  const plen = paths.length;\n  let ii = 0;\n\n  for (; ii < plen; ++ii) {\n    const p = paths[ii];\n\n    if (p === '_id') {\n      if (skipId) {\n        continue;\n      }\n\n      if (obj && '_id' in obj) {\n        continue;\n      }\n    }\n\n    const path = p.split('.');\n    const len = path.length;\n    const last = len - 1;\n    let curPath = '';\n    let doc_ = doc;\n    let included = false;\n\n    for (let i = 0; i < len; ++i) {\n      const piece = path[i];\n      curPath += (!curPath.length ? '' : '.') + piece; // support excluding intermediary levels\n\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (i < last) {\n        doc_ = doc_[piece] || (doc_[piece] = {});\n      }\n    }\n  }\n\n  this._doc = doc;\n};\n/*!\n * Converts to POJO when you use the document for querying\n */\n\n\nDocument.prototype.toBSON = function () {\n  return this.toObject(internalToObjectOptions);\n};\n/**\n * Initializes the document without setters or marking anything modified.\n *\n * Called internally after a document is returned from mongodb. Normally,\n * you do **not** need to call this function on your own.\n *\n * This function triggers `init` [middleware](/docs/middleware.html).\n * Note that `init` hooks are [synchronous](/docs/middleware.html#synchronous).\n *\n * @param {Object} doc document returned by mongo\n * @api public\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.init = function (doc, opts, fn) {\n  if (typeof opts === 'function') {\n    fn = opts;\n    opts = null;\n  }\n\n  this.$__init(doc, opts);\n\n  if (fn) {\n    fn(null, this);\n  }\n\n  return this;\n};\n/*!\n * ignore\n */\n\n\nDocument.prototype.$__init = function (doc, opts) {\n  this.isNew = false;\n  this.$init = true;\n  opts = opts || {}; // handle docs with populated paths\n  // If doc._id is not null or undefined\n\n  if (doc._id != null && opts.populated && opts.populated.length) {\n    const id = String(doc._id);\n\n    for (let i = 0; i < opts.populated.length; ++i) {\n      const item = opts.populated[i];\n\n      if (item.isVirtual) {\n        this.populated(item.path, utils.getValue(item.path, doc), item);\n      } else {\n        this.populated(item.path, item._docs[id], item);\n      }\n    }\n  }\n\n  init(this, doc, this._doc, opts);\n  markArraySubdocsPopulated(this, opts.populated);\n  this.emit('init', this);\n  this.constructor.emit('init', this);\n  this.$__._id = this._id;\n  return this;\n};\n/*!\n * If populating a path within a document array, make sure each\n * subdoc within the array knows its subpaths are populated.\n *\n * ####Example:\n *     const doc = await Article.findOne().populate('comments.author');\n *     doc.comments[0].populated('author'); // Should be set\n */\n\n\nfunction markArraySubdocsPopulated(doc, populated) {\n  if (doc._id == null || populated == null || populated.length === 0) {\n    return;\n  }\n\n  const id = String(doc._id);\n\n  for (const item of populated) {\n    if (item.isVirtual) {\n      continue;\n    }\n\n    const path = item.path;\n    const pieces = path.split('.');\n\n    for (let i = 0; i < pieces.length - 1; ++i) {\n      const subpath = pieces.slice(0, i + 1).join('.');\n      const rest = pieces.slice(i + 1).join('.');\n      const val = doc.get(subpath);\n\n      if (val == null) {\n        continue;\n      }\n\n      if (val.isMongooseDocumentArray) {\n        for (let j = 0; j < val.length; ++j) {\n          val[j].populated(rest, item._docs[id][j], item);\n        }\n\n        break;\n      }\n    }\n  }\n}\n/*!\n * Init helper.\n *\n * @param {Object} self document instance\n * @param {Object} obj raw mongodb doc\n * @param {Object} doc object we are initializing\n * @api private\n */\n\n\nfunction init(self, obj, doc, opts, prefix) {\n  prefix = prefix || '';\n  const keys = Object.keys(obj);\n  const len = keys.length;\n  let schema;\n  let path;\n  let i;\n  let index = 0;\n\n  while (index < len) {\n    _init(index++);\n  }\n\n  function _init(index) {\n    i = keys[index];\n    path = prefix + i;\n    schema = self.schema.path(path); // Should still work if not a model-level discriminator, but should not be\n    // necessary. This is *only* to catch the case where we queried using the\n    // base model and the discriminated model has a projection\n\n    if (self.schema.$isRootDiscriminator && !self.isSelected(path)) {\n      return;\n    }\n\n    if (!schema && utils.isPOJO(obj[i])) {\n      // assume nested object\n      if (!doc[i]) {\n        doc[i] = {};\n      }\n\n      init(self, obj[i], doc[i], opts, path + '.');\n    } else if (!schema) {\n      doc[i] = obj[i];\n    } else {\n      if (obj[i] === null) {\n        doc[i] = null;\n      } else if (obj[i] !== undefined) {\n        const intCache = obj[i].$__ || {};\n        const wasPopulated = intCache.wasPopulated || null;\n\n        if (schema && !wasPopulated) {\n          try {\n            doc[i] = schema.cast(obj[i], self, true);\n          } catch (e) {\n            self.invalidate(e.path, new ValidatorError({\n              path: e.path,\n              message: e.message,\n              type: 'cast',\n              value: e.value\n            }));\n          }\n        } else {\n          doc[i] = obj[i];\n        }\n      } // mark as hydrated\n\n\n      if (!self.isModified(path)) {\n        self.$__.activePaths.init(path);\n      }\n    }\n  }\n}\n/**\n * Sends an update command with this document `_id` as the query selector.\n *\n * ####Example:\n *\n *     weirdCar.update({$inc: {wheels:1}}, { w: 1 }, callback);\n *\n * ####Valid options:\n *\n *  - same as in [Model.update](#model_Model.update)\n *\n * @see Model.update #model_Model.update\n * @param {Object} doc\n * @param {Object} options\n * @param {Function} callback\n * @return {Query}\n * @api public\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.update = function update() {\n  const args = utils.args(arguments);\n  args.unshift({\n    _id: this._id\n  });\n  const query = this.constructor.update.apply(this.constructor, args);\n\n  if (this.$session() != null) {\n    if (!('session' in query.options)) {\n      query.options.session = this.$session();\n    }\n  }\n\n  return query;\n};\n/**\n * Sends an updateOne command with this document `_id` as the query selector.\n *\n * ####Example:\n *\n *     weirdCar.updateOne({$inc: {wheels:1}}, { w: 1 }, callback);\n *\n * ####Valid options:\n *\n *  - same as in [Model.updateOne](#model_Model.updateOne)\n *\n * @see Model.updateOne #model_Model.updateOne\n * @param {Object} doc\n * @param {Object} options\n * @param {Function} callback\n * @return {Query}\n * @api public\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.updateOne = function updateOne(doc, options, callback) {\n  const query = this.constructor.updateOne({\n    _id: this._id\n  }, doc, options);\n\n  query._pre(cb => {\n    this.constructor._middleware.execPre('updateOne', this, [], cb);\n  });\n\n  query._post(cb => {\n    this.constructor._middleware.execPost('updateOne', this, [], {}, cb);\n  });\n\n  if (this.$session() != null) {\n    if (!('session' in query.options)) {\n      query.options.session = this.$session();\n    }\n  }\n\n  if (callback != null) {\n    return query.exec(callback);\n  }\n\n  return query;\n};\n/**\n * Sends a replaceOne command with this document `_id` as the query selector.\n *\n * ####Valid options:\n *\n *  - same as in [Model.replaceOne](#model_Model.replaceOne)\n *\n * @see Model.replaceOne #model_Model.replaceOne\n * @param {Object} doc\n * @param {Object} options\n * @param {Function} callback\n * @return {Query}\n * @api public\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.replaceOne = function replaceOne() {\n  const args = utils.args(arguments);\n  args.unshift({\n    _id: this._id\n  });\n  return this.constructor.replaceOne.apply(this.constructor, args);\n};\n/**\n * Getter/setter around the session associated with this document. Used to\n * automatically set `session` if you `save()` a doc that you got from a\n * query with an associated session.\n *\n * ####Example:\n *\n *     const session = MyModel.startSession();\n *     const doc = await MyModel.findOne().session(session);\n *     doc.$session() === session; // true\n *     doc.$session(null);\n *     doc.$session() === null; // true\n *\n * If this is a top-level document, setting the session propagates to all child\n * docs.\n *\n * @param {ClientSession} [session] overwrite the current session\n * @return {ClientSession}\n * @method $session\n * @api public\n * @memberOf Document\n */\n\n\nDocument.prototype.$session = function $session(session) {\n  if (arguments.length === 0) {\n    return this.$__.session;\n  }\n\n  this.$__.session = session;\n\n  if (!this.ownerDocument) {\n    const subdocs = this.$__getAllSubdocs();\n\n    for (const child of subdocs) {\n      child.$session(session);\n    }\n  }\n\n  return session;\n};\n/**\n * Overwrite all values in this document with the values of `obj`, except\n * for immutable properties. Behaves similarly to `set()`, except for it\n * unsets all properties that aren't in `obj`.\n *\n * @param {Object} obj the object to overwrite this document with\n * @method overwrite\n * @name overwrite\n * @memberOf Document\n * @instance\n * @api public\n */\n\n\nDocument.prototype.overwrite = function overwrite(obj) {\n  const keys = Array.from(new Set(Object.keys(this._doc).concat(Object.keys(obj))));\n\n  for (const key of keys) {\n    if (key === '_id') {\n      continue;\n    } // Explicitly skip version key\n\n\n    if (this.schema.options.versionKey && key === this.schema.options.versionKey) {\n      continue;\n    }\n\n    this.$set(key, obj[key]);\n  }\n\n  return this;\n};\n/**\n * Alias for `set()`, used internally to avoid conflicts\n *\n * @param {String|Object} path path or object of key/vals to set\n * @param {Any} val the value to set\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for \"on-the-fly\" attributes\n * @param {Object} [options] optionally specify options that modify the behavior of the set\n * @method $set\n * @name $set\n * @memberOf Document\n * @instance\n * @api public\n */\n\n\nDocument.prototype.$set = function $set(path, val, type, options) {\n  if (utils.isPOJO(type)) {\n    options = type;\n    type = undefined;\n  }\n\n  options = options || {};\n  const merge = options.merge;\n  const adhoc = type && type !== true;\n  const constructing = type === true;\n  let adhocs;\n  let keys;\n  let i = 0;\n  let pathtype;\n  let key;\n  let prefix;\n  const strict = 'strict' in options ? options.strict : this.$__.strictMode;\n\n  if (adhoc) {\n    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n    adhocs[path] = this.schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  if (typeof path !== 'string') {\n    // new Document({ key: val })\n    if (path === null || path === void 0) {\n      const _ = path;\n      path = val;\n      val = _;\n    } else {\n      prefix = val ? val + '.' : '';\n\n      if (path instanceof Document) {\n        if (path.$__isNested) {\n          path = path.toObject();\n        } else {\n          path = path._doc;\n        }\n      }\n\n      keys = Object.keys(path);\n      const len = keys.length;\n\n      if (len === 0 && !this.schema.options.minimize) {\n        if (val) {\n          this.$set(val, {});\n        }\n\n        return this;\n      }\n\n      while (i < len) {\n        _handleIndex.call(this, i++);\n      }\n\n      return this;\n    }\n  } else {\n    this.$__.$setCalled.add(path);\n  }\n\n  function _handleIndex(i) {\n    key = keys[i];\n    const pathName = prefix + key;\n    pathtype = this.schema.pathType(pathName); // On initial set, delete any nested keys if we're going to overwrite\n    // them to ensure we keep the user's key order.\n\n    if (type === true && !prefix && path[key] != null && pathtype === 'nested' && this._doc[key] != null && Object.keys(this._doc[key]).length === 0) {\n      delete this._doc[key];\n    }\n\n    if (typeof path[key] === 'object' && !utils.isNativeObject(path[key]) && !utils.isMongooseType(path[key]) && path[key] != null && pathtype !== 'virtual' && pathtype !== 'real' && !(this.$__path(pathName) instanceof MixedSchema) && !(this.schema.paths[pathName] && this.schema.paths[pathName].options && this.schema.paths[pathName].options.ref)) {\n      this.$__.$setCalled.add(prefix + key);\n      this.$set(path[key], prefix + key, constructing, options);\n    } else if (strict) {\n      // Don't overwrite defaults with undefined keys (gh-3981)\n      if (constructing && path[key] === void 0 && this.get(key) !== void 0) {\n        return;\n      }\n\n      if (pathtype === 'adhocOrUndefined') {\n        pathtype = getEmbeddedDiscriminatorPath(this, pathName, {\n          typeOnly: true\n        });\n      }\n\n      if (pathtype === 'real' || pathtype === 'virtual') {\n        // Check for setting single embedded schema to document (gh-3535)\n        let p = path[key];\n\n        if (this.schema.paths[pathName] && this.schema.paths[pathName].$isSingleNested && path[key] instanceof Document) {\n          p = p.toObject({\n            virtuals: false,\n            transform: false\n          });\n        }\n\n        this.$set(prefix + key, p, constructing, options);\n      } else if (pathtype === 'nested' && path[key] instanceof Document) {\n        this.$set(prefix + key, path[key].toObject({\n          transform: false\n        }), constructing, options);\n      } else if (strict === 'throw') {\n        if (pathtype === 'nested') {\n          throw new ObjectExpectedError(key, path[key]);\n        } else {\n          throw new StrictModeError(key);\n        }\n      }\n    } else if (path[key] !== void 0) {\n      this.$set(prefix + key, path[key], constructing, options);\n    }\n  }\n\n  let pathType = this.schema.pathType(path);\n\n  if (pathType === 'adhocOrUndefined') {\n    pathType = getEmbeddedDiscriminatorPath(this, path, {\n      typeOnly: true\n    });\n  } // Assume this is a Mongoose document that was copied into a POJO using\n  // `Object.assign()` or `{...doc}`\n\n\n  if (utils.isPOJO(val) && val.$__ != null && val._doc != null) {\n    val = val._doc;\n  }\n\n  if (pathType === 'nested' && val) {\n    if (typeof val === 'object' && val != null) {\n      if (!merge) {\n        this.$__setValue(path, null);\n        cleanModifiedSubpaths(this, path);\n      } else {\n        return this.$set(val, path, constructing);\n      }\n\n      const keys = Object.keys(val);\n      this.$__setValue(path, {});\n\n      for (const key of keys) {\n        this.$set(path + '.' + key, val[key], constructing);\n      }\n\n      this.markModified(path);\n      cleanModifiedSubpaths(this, path, {\n        skipDocArrays: true\n      });\n      return this;\n    }\n\n    this.invalidate(path, new MongooseError.CastError('Object', val, path));\n    return this;\n  }\n\n  let schema;\n  const parts = path.split('.'); // Might need to change path for top-level alias\n\n  if (typeof this.schema.aliases[parts[0]] == 'string') {\n    parts[0] = this.schema.aliases[parts[0]];\n  }\n\n  if (pathType === 'adhocOrUndefined' && strict) {\n    // check for roots that are Mixed types\n    let mixed;\n\n    for (i = 0; i < parts.length; ++i) {\n      const subpath = parts.slice(0, i + 1).join('.'); // If path is underneath a virtual, bypass everything and just set it.\n\n      if (i + 1 < parts.length && this.schema.pathType(subpath) === 'virtual') {\n        mpath.set(path, val, this);\n        return this;\n      }\n\n      schema = this.schema.path(subpath);\n\n      if (schema == null) {\n        continue;\n      }\n\n      if (schema instanceof MixedSchema) {\n        // allow changes to sub paths of mixed types\n        mixed = true;\n        break;\n      }\n    }\n\n    if (schema == null) {\n      // Check for embedded discriminators\n      schema = getEmbeddedDiscriminatorPath(this, path);\n    }\n\n    if (!mixed && !schema) {\n      if (strict === 'throw') {\n        throw new StrictModeError(path);\n      }\n\n      return this;\n    }\n  } else if (pathType === 'virtual') {\n    schema = this.schema.virtualpath(path);\n    schema.applySetters(val, this);\n    return this;\n  } else {\n    schema = this.$__path(path);\n  } // gh-4578, if setting a deeply nested path that doesn't exist yet, create it\n\n\n  let cur = this._doc;\n  let curPath = '';\n\n  for (i = 0; i < parts.length - 1; ++i) {\n    cur = cur[parts[i]];\n    curPath += (curPath.length > 0 ? '.' : '') + parts[i];\n\n    if (!cur) {\n      this.$set(curPath, {}); // Hack re: gh-5800. If nested field is not selected, it probably exists\n      // so `MongoError: cannot use the part (nested of nested.num) to\n      // traverse the element ({nested: null})` is not likely. If user gets\n      // that error, its their fault for now. We should reconsider disallowing\n      // modifying not selected paths for 6.x\n\n      if (!this.isSelected(curPath)) {\n        this.unmarkModified(curPath);\n      }\n\n      cur = this.$__getValue(curPath);\n    }\n  }\n\n  let pathToMark; // When using the $set operator the path to the field must already exist.\n  // Else mongodb throws: \"LEFT_SUBFIELD only supports Object\"\n\n  if (parts.length <= 1) {\n    pathToMark = path;\n  } else {\n    for (i = 0; i < parts.length; ++i) {\n      const subpath = parts.slice(0, i + 1).join('.');\n\n      if (this.get(subpath, null, {\n        getters: false\n      }) === null) {\n        pathToMark = subpath;\n        break;\n      }\n    }\n\n    if (!pathToMark) {\n      pathToMark = path;\n    }\n  } // if this doc is being constructed we should not trigger getters\n\n\n  const priorVal = (() => {\n    if (this.$__.$options.priorDoc != null) {\n      return this.$__.$options.priorDoc.$__getValue(path);\n    }\n\n    if (constructing) {\n      return void 0;\n    }\n\n    return this.$__getValue(path);\n  })();\n\n  if (!schema) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n    return this;\n  }\n\n  if (schema.$isSingleNested && val != null && merge) {\n    if (val instanceof Document) {\n      val = val.toObject({\n        virtuals: false,\n        transform: false\n      });\n    }\n\n    const keys = Object.keys(val);\n\n    for (const key of keys) {\n      this.$set(path + '.' + key, val[key], constructing, options);\n    }\n\n    return this;\n  }\n\n  let shouldSet = true;\n\n  try {\n    // If the user is trying to set a ref path to a document with\n    // the correct model name, treat it as populated\n    const refMatches = (() => {\n      if (schema.options == null) {\n        return false;\n      }\n\n      if (!(val instanceof Document)) {\n        return false;\n      }\n\n      const model = val.constructor; // Check ref\n\n      const ref = schema.options.ref;\n\n      if (ref != null && (ref === model.modelName || ref === model.baseModelName)) {\n        return true;\n      } // Check refPath\n\n\n      const refPath = schema.options.refPath;\n\n      if (refPath == null) {\n        return false;\n      }\n\n      const modelName = val.get(refPath);\n\n      if (modelName === model.modelName || modelName === model.baseModelName) {\n        return true;\n      }\n\n      return false;\n    })();\n\n    let didPopulate = false;\n\n    if (refMatches && val instanceof Document) {\n      this.populated(path, val._id, {\n        [populateModelSymbol]: val.constructor\n      });\n      didPopulate = true;\n    }\n\n    let popOpts;\n\n    if (schema.options && Array.isArray(schema.options[this.schema.options.typeKey]) && schema.options[this.schema.options.typeKey].length && schema.options[this.schema.options.typeKey][0].ref && Array.isArray(val) && val.length > 0 && val[0] instanceof Document && val[0].constructor.modelName && (schema.options[this.schema.options.typeKey][0].ref === val[0].constructor.baseModelName || schema.options[this.schema.options.typeKey][0].ref === val[0].constructor.modelName)) {\n      if (this.ownerDocument) {\n        popOpts = {\n          [populateModelSymbol]: val[0].constructor\n        };\n        this.ownerDocument().populated(this.$__fullPath(path), val.map(function (v) {\n          return v._id;\n        }), popOpts);\n      } else {\n        popOpts = {\n          [populateModelSymbol]: val[0].constructor\n        };\n        this.populated(path, val.map(function (v) {\n          return v._id;\n        }), popOpts);\n      }\n\n      didPopulate = true;\n    }\n\n    if (this.schema.singleNestedPaths[path] == null) {\n      // If this path is underneath a single nested schema, we'll call the setter\n      // later in `$__set()` because we don't take `_doc` when we iterate through\n      // a single nested doc. That's to make sure we get the correct context.\n      // Otherwise we would double-call the setter, see gh-7196.\n      val = schema.applySetters(val, this, false, priorVal);\n    }\n\n    if (schema.$isMongooseDocumentArray && Array.isArray(val) && val.length > 0 && val[0] != null && val[0].$__ != null && val[0].$__.populated != null) {\n      const populatedPaths = Object.keys(val[0].$__.populated);\n\n      for (const populatedPath of populatedPaths) {\n        this.populated(path + '.' + populatedPath, val.map(v => v.populated(populatedPath)), val[0].$__.populated[populatedPath].options);\n      }\n\n      didPopulate = true;\n    }\n\n    if (!didPopulate && this.$__.populated) {\n      delete this.$__.populated[path];\n    }\n\n    this.$markValid(path);\n  } catch (e) {\n    if (e instanceof MongooseError.StrictModeError && e.isImmutableError) {\n      this.invalidate(path, e);\n    } else {\n      this.invalidate(path, new MongooseError.CastError(schema.instance, val, path, e));\n    }\n\n    shouldSet = false;\n  }\n\n  if (shouldSet) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n  }\n\n  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {\n    cleanModifiedSubpaths(this, path);\n  }\n\n  return this;\n};\n/**\n * Sets the value of a path, or many paths.\n *\n * ####Example:\n *\n *     // path, value\n *     doc.set(path, value)\n *\n *     // object\n *     doc.set({\n *         path  : value\n *       , path2 : {\n *            path  : value\n *         }\n *     })\n *\n *     // on-the-fly cast to number\n *     doc.set(path, value, Number)\n *\n *     // on-the-fly cast to string\n *     doc.set(path, value, String)\n *\n *     // changing strict mode behavior\n *     doc.set(path, value, { strict: false });\n *\n * @param {String|Object} path path or object of key/vals to set\n * @param {Any} val the value to set\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for \"on-the-fly\" attributes\n * @param {Object} [options] optionally specify options that modify the behavior of the set\n * @api public\n * @method set\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.set = Document.prototype.$set;\n/**\n * Determine if we should mark this change as modified.\n *\n * @return {Boolean}\n * @api private\n * @method $__shouldModify\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__shouldModify = function (pathToMark, path, constructing, parts, schema, val, priorVal) {\n  if (this.isNew) {\n    return true;\n  } // Re: the note about gh-7196, `val` is the raw value without casting or\n  // setters if the full path is under a single nested subdoc because we don't\n  // want to double run setters. So don't set it as modified. See gh-7264.\n\n\n  if (this.schema.singleNestedPaths[path] != null) {\n    return false;\n  }\n\n  if (val === void 0 && !this.isSelected(path)) {\n    // when a path is not selected in a query, its initial\n    // value will be undefined.\n    return true;\n  }\n\n  if (val === void 0 && path in this.$__.activePaths.states.default) {\n    // we're just unsetting the default value which was never saved\n    return false;\n  } // gh-3992: if setting a populated field to a doc, don't mark modified\n  // if they have the same _id\n\n\n  if (this.populated(path) && val instanceof Document && deepEqual(val._id, priorVal)) {\n    return false;\n  }\n\n  if (!deepEqual(val, priorVal || this.get(path))) {\n    return true;\n  }\n\n  if (!constructing && val !== null && val !== undefined && path in this.$__.activePaths.states.default && deepEqual(val, schema.getDefault(this, constructing))) {\n    // a path with a default was $unset on the server\n    // and the user is setting it to the same value again\n    return true;\n  }\n\n  return false;\n};\n/**\n * Handles the actual setting of the value and marking the path modified if appropriate.\n *\n * @api private\n * @method $__set\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.$__set = function (pathToMark, path, constructing, parts, schema, val, priorVal) {\n  Embedded = Embedded || require('./types/embedded');\n  const shouldModify = this.$__shouldModify(pathToMark, path, constructing, parts, schema, val, priorVal);\n\n  const _this = this;\n\n  if (shouldModify) {\n    this.markModified(pathToMark); // handle directly setting arrays (gh-1126)\n\n    MongooseArray || (MongooseArray = require('./types/array'));\n\n    if (val && val.isMongooseArray) {\n      val._registerAtomic('$set', val); // Update embedded document parent references (gh-5189)\n\n\n      if (val.isMongooseDocumentArray) {\n        val.forEach(function (item) {\n          item && item.__parentArray && (item.__parentArray = val);\n        });\n      } // Small hack for gh-1638: if we're overwriting the entire array, ignore\n      // paths that were modified before the array overwrite\n\n\n      this.$__.activePaths.forEach(function (modifiedPath) {\n        if (modifiedPath.startsWith(path + '.')) {\n          _this.$__.activePaths.ignore(modifiedPath);\n        }\n      });\n    }\n  }\n\n  let obj = this._doc;\n  let i = 0;\n  const l = parts.length;\n  let cur = '';\n\n  for (; i < l; i++) {\n    const next = i + 1;\n    const last = next === l;\n    cur += cur ? '.' + parts[i] : parts[i];\n\n    if (specialProperties.has(parts[i])) {\n      return;\n    }\n\n    if (last) {\n      if (obj instanceof Map) {\n        obj.set(parts[i], val);\n      } else {\n        obj[parts[i]] = val;\n      }\n    } else {\n      if (utils.isPOJO(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]].$isSingleNested) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else {\n        obj[parts[i]] = obj[parts[i]] || {};\n        obj = obj[parts[i]];\n      }\n    }\n  }\n};\n/**\n * Gets a raw value from a path (no getters)\n *\n * @param {String} path\n * @api private\n */\n\n\nDocument.prototype.$__getValue = function (path) {\n  return utils.getValue(path, this._doc);\n};\n/**\n * Sets a raw value for a path (no casting, setters, transformations)\n *\n * @param {String} path\n * @param {Object} value\n * @api private\n */\n\n\nDocument.prototype.$__setValue = function (path, val) {\n  utils.setValue(path, val, this._doc);\n  return this;\n};\n/**\n * Returns the value of a path.\n *\n * ####Example\n *\n *     // path\n *     doc.get('age') // 47\n *\n *     // dynamic casting to a string\n *     doc.get('age', String) // \"47\"\n *\n * @param {String} path\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for on-the-fly attributes\n * @param {Object} [options]\n * @param {Boolean} [options.virtuals=false] Apply virtuals before getting this path\n * @param {Boolean} [options.getters=true] If false, skip applying getters and just get the raw value\n * @api public\n */\n\n\nDocument.prototype.get = function (path, type, options) {\n  let adhoc;\n  options = options || {};\n\n  if (type) {\n    adhoc = this.schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  let schema = this.$__path(path);\n\n  if (schema == null) {\n    schema = this.schema.virtualpath(path);\n  }\n\n  if (schema instanceof MixedSchema) {\n    const virtual = this.schema.virtualpath(path);\n\n    if (virtual != null) {\n      schema = virtual;\n    }\n  }\n\n  const pieces = path.split('.');\n  let obj = this._doc;\n\n  if (schema instanceof VirtualType) {\n    if (schema.getters.length === 0) {\n      return void 0;\n    }\n\n    return schema.applyGetters(null, this);\n  } // Might need to change path for top-level alias\n\n\n  if (typeof this.schema.aliases[pieces[0]] == 'string') {\n    pieces[0] = this.schema.aliases[pieces[0]];\n  }\n\n  for (let i = 0, l = pieces.length; i < l; i++) {\n    if (obj && obj._doc) {\n      obj = obj._doc;\n    }\n\n    if (obj == null) {\n      obj = void 0;\n    } else if (obj instanceof Map) {\n      obj = obj.get(pieces[i]);\n    } else if (i === l - 1) {\n      obj = utils.getValue(pieces[i], obj);\n    } else {\n      obj = obj[pieces[i]];\n    }\n  }\n\n  if (adhoc) {\n    obj = adhoc.cast(obj);\n  }\n\n  if (schema != null && options.getters !== false) {\n    obj = schema.applyGetters(obj, this);\n  } else if (this.schema.nested[path] && options.virtuals) {\n    // Might need to apply virtuals if this is a nested path\n    return applyVirtuals(this, utils.clone(obj) || {}, {\n      path: path\n    });\n  }\n\n  return obj;\n};\n/*!\n * ignore\n */\n\n\nDocument.prototype[getSymbol] = Document.prototype.get;\n/**\n * Returns the schematype for the given `path`.\n *\n * @param {String} path\n * @api private\n * @method $__path\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__path = function (path) {\n  const adhocs = this.$__.adhocPaths;\n  const adhocType = adhocs && adhocs.hasOwnProperty(path) ? adhocs[path] : null;\n\n  if (adhocType) {\n    return adhocType;\n  }\n\n  return this.schema.path(path);\n};\n/**\n * Marks the path as having pending changes to write to the db.\n *\n * _Very helpful when using [Mixed](./schematypes.html#mixed) types._\n *\n * ####Example:\n *\n *     doc.mixed.type = 'changed';\n *     doc.markModified('mixed.type');\n *     doc.save() // changes to mixed.type are now persisted\n *\n * @param {String} path the path to mark modified\n * @param {Document} [scope] the scope to run validators with\n * @api public\n */\n\n\nDocument.prototype.markModified = function (path, scope) {\n  this.$__.activePaths.modify(path);\n\n  if (scope != null && !this.ownerDocument) {\n    this.$__.pathsToScopes[path] = scope;\n  }\n};\n/**\n * Clears the modified state on the specified path.\n *\n * ####Example:\n *\n *     doc.foo = 'bar';\n *     doc.unmarkModified('foo');\n *     doc.save(); // changes to foo will not be persisted\n *\n * @param {String} path the path to unmark modified\n * @api public\n */\n\n\nDocument.prototype.unmarkModified = function (path) {\n  this.$__.activePaths.init(path);\n  delete this.$__.pathsToScopes[path];\n};\n/**\n * Don't run validation on this path or persist changes to this path.\n *\n * ####Example:\n *\n *     doc.foo = null;\n *     doc.$ignore('foo');\n *     doc.save(); // changes to foo will not be persisted and validators won't be run\n *\n * @memberOf Document\n * @instance\n * @method $ignore\n * @param {String} path the path to ignore\n * @api public\n */\n\n\nDocument.prototype.$ignore = function (path) {\n  this.$__.activePaths.ignore(path);\n};\n/**\n * Returns the list of paths that have been directly modified. A direct\n * modified path is a path that you explicitly set, whether via `doc.foo = 'bar'`,\n * `Object.assign(doc, { foo: 'bar' })`, or `doc.set('foo', 'bar')`.\n *\n * A path `a` may be in `modifiedPaths()` but not in `directModifiedPaths()`\n * because a child of `a` was directly modified.\n *\n * ####Example\n *     const schema = new Schema({ foo: String, nested: { bar: String } });\n *     const Model = mongoose.model('Test', schema);\n *     await Model.create({ foo: 'original', nested: { bar: 'original' } });\n *\n *     const doc = await Model.findOne();\n *     doc.nested.bar = 'modified';\n *     doc.directModifiedPaths(); // ['nested.bar']\n *     doc.modifiedPaths(); // ['nested', 'nested.bar']\n *\n * @return {Array}\n * @api public\n */\n\n\nDocument.prototype.directModifiedPaths = function () {\n  return Object.keys(this.$__.activePaths.states.modify);\n};\n/**\n * Returns true if the given path is nullish or only contains empty objects.\n * Useful for determining whether this subdoc will get stripped out by the\n * [minimize option](/docs/guide.html#minimize).\n *\n * ####Example:\n *     const schema = new Schema({ nested: { foo: String } });\n *     const Model = mongoose.model('Test', schema);\n *     const doc = new Model({});\n *     doc.$isEmpty('nested'); // true\n *     doc.nested.$isEmpty(); // true\n *\n *     doc.nested.foo = 'bar';\n *     doc.$isEmpty('nested'); // false\n *     doc.nested.$isEmpty(); // false\n *\n * @memberOf Document\n * @instance\n * @api public\n * @method $isEmpty\n * @return {Boolean}\n */\n\n\nDocument.prototype.$isEmpty = function (path) {\n  const isEmptyOptions = {\n    minimize: true,\n    virtuals: false,\n    getters: false,\n    transform: false\n  };\n\n  if (arguments.length > 0) {\n    const v = this.get(path);\n\n    if (v == null) {\n      return true;\n    }\n\n    if (typeof v !== 'object') {\n      return false;\n    }\n\n    if (utils.isPOJO(v)) {\n      return _isEmpty(v);\n    }\n\n    return Object.keys(v.toObject(isEmptyOptions)).length === 0;\n  }\n\n  return Object.keys(this.toObject(isEmptyOptions)).length === 0;\n};\n\nfunction _isEmpty(v) {\n  if (v == null) {\n    return true;\n  }\n\n  if (typeof v !== 'object' || Array.isArray(v)) {\n    return false;\n  }\n\n  for (const key of Object.keys(v)) {\n    if (!_isEmpty(v[key])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Returns the list of paths that have been modified.\n *\n * @param {Object} [options]\n * @param {Boolean} [options.includeChildren=false] if true, returns children of modified paths as well. For example, if false, the list of modified paths for `doc.colors = { primary: 'blue' };` will **not** contain `colors.primary`. If true, `modifiedPaths()` will return an array that contains `colors.primary`.\n * @return {Array}\n * @api public\n */\n\n\nDocument.prototype.modifiedPaths = function (options) {\n  options = options || {};\n  const directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n\n  const _this = this;\n\n  return directModifiedPaths.reduce(function (list, path) {\n    const parts = path.split('.');\n    list = list.concat(parts.reduce(function (chains, part, i) {\n      return chains.concat(parts.slice(0, i).concat(part).join('.'));\n    }, []).filter(function (chain) {\n      return list.indexOf(chain) === -1;\n    }));\n\n    if (!options.includeChildren) {\n      return list;\n    }\n\n    let cur = _this.get(path);\n\n    if (cur != null && typeof cur === 'object') {\n      if (cur._doc) {\n        cur = cur._doc;\n      }\n\n      if (Array.isArray(cur)) {\n        const len = cur.length;\n\n        for (let i = 0; i < len; ++i) {\n          if (list.indexOf(path + '.' + i) === -1) {\n            list.push(path + '.' + i);\n\n            if (cur[i] != null && cur[i].$__) {\n              const modified = cur[i].modifiedPaths();\n\n              for (const childPath of modified) {\n                list.push(path + '.' + i + '.' + childPath);\n              }\n            }\n          }\n        }\n      } else {\n        Object.keys(cur).filter(function (key) {\n          return list.indexOf(path + '.' + key) === -1;\n        }).forEach(function (key) {\n          list.push(path + '.' + key);\n        });\n      }\n    }\n\n    return list;\n  }, []);\n};\n/**\n * Returns true if this document was modified, else false.\n *\n * If `path` is given, checks if a path or any full path containing `path` as part of its path chain has been modified.\n *\n * ####Example\n *\n *     doc.set('documents.0.title', 'changed');\n *     doc.isModified()                      // true\n *     doc.isModified('documents')           // true\n *     doc.isModified('documents.0.title')   // true\n *     doc.isModified('documents otherProp') // true\n *     doc.isDirectModified('documents')     // false\n *\n * @param {String} [path] optional\n * @return {Boolean}\n * @api public\n */\n\n\nDocument.prototype.isModified = function (paths, modifiedPaths) {\n  if (paths) {\n    if (!Array.isArray(paths)) {\n      paths = paths.split(' ');\n    }\n\n    const modified = modifiedPaths || this.modifiedPaths();\n    const directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n    const isModifiedChild = paths.some(function (path) {\n      return !!~modified.indexOf(path);\n    });\n    return isModifiedChild || paths.some(function (path) {\n      return directModifiedPaths.some(function (mod) {\n        return mod === path || path.startsWith(mod + '.');\n      });\n    });\n  }\n\n  return this.$__.activePaths.some('modify');\n};\n/**\n * Checks if a path is set to its default.\n *\n * ####Example\n *\n *     MyModel = mongoose.model('test', { name: { type: String, default: 'Val '} });\n *     var m = new MyModel();\n *     m.$isDefault('name'); // true\n *\n * @memberOf Document\n * @instance\n * @method $isDefault\n * @param {String} [path]\n * @return {Boolean}\n * @api public\n */\n\n\nDocument.prototype.$isDefault = function (path) {\n  return path in this.$__.activePaths.states.default;\n};\n/**\n * Getter/setter, determines whether the document was removed or not.\n *\n * ####Example:\n *     product.remove(function (err, product) {\n *       product.$isDeleted(); // true\n *       product.remove(); // no-op, doesn't send anything to the db\n *\n *       product.$isDeleted(false);\n *       product.$isDeleted(); // false\n *       product.remove(); // will execute a remove against the db\n *     })\n *\n * @param {Boolean} [val] optional, overrides whether mongoose thinks the doc is deleted\n * @return {Boolean} whether mongoose thinks this doc is deleted.\n * @method $isDeleted\n * @memberOf Document\n * @instance\n * @api public\n */\n\n\nDocument.prototype.$isDeleted = function (val) {\n  if (arguments.length === 0) {\n    return !!this.$__.isDeleted;\n  }\n\n  this.$__.isDeleted = !!val;\n  return this;\n};\n/**\n * Returns true if `path` was directly set and modified, else false.\n *\n * ####Example\n *\n *     doc.set('documents.0.title', 'changed');\n *     doc.isDirectModified('documents.0.title') // true\n *     doc.isDirectModified('documents') // false\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\n\nDocument.prototype.isDirectModified = function (path) {\n  return path in this.$__.activePaths.states.modify;\n};\n/**\n * Checks if `path` was initialized.\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\n\nDocument.prototype.isInit = function (path) {\n  return path in this.$__.activePaths.states.init;\n};\n/**\n * Checks if `path` was selected in the source query which initialized this document.\n *\n * ####Example\n *\n *     Thing.findOne().select('name').exec(function (err, doc) {\n *        doc.isSelected('name') // true\n *        doc.isSelected('age')  // false\n *     })\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\n\nDocument.prototype.isSelected = function isSelected(path) {\n  if (this.$__.selected) {\n    if (path === '_id') {\n      return this.$__.selected._id !== 0;\n    }\n\n    const paths = Object.keys(this.$__.selected);\n    let i = paths.length;\n    let inclusive = null;\n    let cur;\n\n    if (i === 1 && paths[0] === '_id') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n\n      if (cur === '_id') {\n        continue;\n      }\n\n      if (!isDefiningProjection(this.$__.selected[cur])) {\n        continue;\n      }\n\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    i = paths.length;\n    const pathDot = path + '.';\n\n    while (i--) {\n      cur = paths[i];\n\n      if (cur === '_id') {\n        continue;\n      }\n\n      if (cur.startsWith(pathDot)) {\n        return inclusive || cur !== pathDot;\n      }\n\n      if (pathDot.startsWith(cur + '.')) {\n        return inclusive;\n      }\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n};\n/**\n * Checks if `path` was explicitly selected. If no projection, always returns\n * true.\n *\n * ####Example\n *\n *     Thing.findOne().select('nested.name').exec(function (err, doc) {\n *        doc.isDirectSelected('nested.name') // true\n *        doc.isDirectSelected('nested.otherName') // false\n *        doc.isDirectSelected('nested')  // false\n *     })\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\n\nDocument.prototype.isDirectSelected = function isDirectSelected(path) {\n  if (this.$__.selected) {\n    if (path === '_id') {\n      return this.$__.selected._id !== 0;\n    }\n\n    const paths = Object.keys(this.$__.selected);\n    let i = paths.length;\n    let inclusive = null;\n    let cur;\n\n    if (i === 1 && paths[0] === '_id') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n\n      if (cur === '_id') {\n        continue;\n      }\n\n      if (!isDefiningProjection(this.$__.selected[cur])) {\n        continue;\n      }\n\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n};\n/**\n * Executes registered validation rules for this document.\n *\n * ####Note:\n *\n * This method is called `pre` save and if a validation rule is violated, [save](#model_Model-save) is aborted and the error is returned to your `callback`.\n *\n * ####Example:\n *\n *     doc.validate(function (err) {\n *       if (err) handleError(err);\n *       else // validation passed\n *     });\n *\n * @param {Object} optional options internal options\n * @param {Function} callback optional callback called after validation completes, passing an error if one occurred\n * @return {Promise} Promise\n * @api public\n */\n\n\nDocument.prototype.validate = function (options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n\n  return utils.promiseOrCallback(callback, cb => {\n    this.$__validate(options, function (error) {\n      cb(error);\n    });\n  }, this.constructor.events);\n};\n/*!\n * ignore\n */\n\n\nfunction _evaluateRequiredFunctions(doc) {\n  Object.keys(doc.$__.activePaths.states.require).forEach(path => {\n    const p = doc.schema.path(path);\n\n    if (p != null && typeof p.originalRequiredValue === 'function') {\n      doc.$__.cachedRequired[path] = p.originalRequiredValue.call(doc);\n    }\n  });\n}\n/*!\n * ignore\n */\n\n\nfunction _getPathsToValidate(doc) {\n  let i;\n  let len;\n  const skipSchemaValidators = {};\n\n  _evaluateRequiredFunctions(doc); // only validate required fields when necessary\n\n\n  let paths = Object.keys(doc.$__.activePaths.states.require).filter(function (path) {\n    if (!doc.isSelected(path) && !doc.isModified(path)) {\n      return false;\n    }\n\n    if (path in doc.$__.cachedRequired) {\n      return doc.$__.cachedRequired[path];\n    }\n\n    return true;\n  });\n  paths = paths.concat(Object.keys(doc.$__.activePaths.states.init));\n  paths = paths.concat(Object.keys(doc.$__.activePaths.states.modify));\n  paths = paths.concat(Object.keys(doc.$__.activePaths.states.default));\n\n  if (!doc.ownerDocument) {\n    const subdocs = doc.$__getAllSubdocs();\n    let subdoc;\n    len = subdocs.length;\n    const modifiedPaths = doc.modifiedPaths();\n\n    for (i = 0; i < len; ++i) {\n      subdoc = subdocs[i];\n\n      if (doc.isModified(subdoc.$basePath, modifiedPaths) && !doc.isDirectModified(subdoc.$basePath) && !doc.$isDefault(subdoc.$basePath)) {\n        // Remove child paths for now, because we'll be validating the whole\n        // subdoc\n        paths = paths.filter(function (p) {\n          return p != null && p.indexOf(subdoc.$basePath + '.') !== 0;\n        });\n        paths.push(subdoc.$basePath);\n        skipSchemaValidators[subdoc.$basePath] = true;\n      }\n    }\n  } // gh-661: if a whole array is modified, make sure to run validation on all\n  // the children as well\n\n\n  len = paths.length;\n\n  for (i = 0; i < len; ++i) {\n    const path = paths[i];\n\n    const _pathType = doc.schema.path(path);\n\n    if (!_pathType || !_pathType.$isMongooseArray || // To avoid potential performance issues, skip doc arrays whose children\n    // are not required. `getPositionalPathType()` may be slow, so avoid\n    // it unless we have a case of #6364\n    _pathType.$isMongooseDocumentArray && !get(_pathType, 'schemaOptions.required')) {\n      continue;\n    }\n\n    const val = doc.$__getValue(path);\n\n    _pushNestedArrayPaths(val, paths, path);\n  }\n\n  function _pushNestedArrayPaths(val, paths, path) {\n    if (val != null) {\n      const numElements = val.length;\n\n      for (let j = 0; j < numElements; ++j) {\n        if (Array.isArray(val[j])) {\n          _pushNestedArrayPaths(val[j], paths, path + '.' + j);\n        } else {\n          paths.push(path + '.' + j);\n        }\n      }\n    }\n  }\n\n  const flattenOptions = {\n    skipArrays: true\n  };\n  len = paths.length;\n\n  for (i = 0; i < len; ++i) {\n    const pathToCheck = paths[i];\n\n    if (doc.schema.nested[pathToCheck]) {\n      let _v = doc.$__getValue(pathToCheck);\n\n      if (isMongooseObject(_v)) {\n        _v = _v.toObject({\n          transform: false\n        });\n      }\n\n      const flat = flatten(_v, pathToCheck, flattenOptions, doc.schema);\n      paths = paths.concat(Object.keys(flat));\n    }\n  }\n\n  len = paths.length;\n\n  for (i = 0; i < len; ++i) {\n    const path = paths[i];\n\n    const _pathType = doc.schema.path(path);\n\n    if (!_pathType || !_pathType.$isSchemaMap) {\n      continue;\n    }\n\n    const val = doc.$__getValue(path);\n\n    if (val == null) {\n      continue;\n    }\n\n    for (const key of val.keys()) {\n      paths.push(path + '.' + key);\n    }\n  }\n\n  return [paths, skipSchemaValidators];\n}\n/*!\n * ignore\n */\n\n\nDocument.prototype.$__validate = function (options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n\n  const hasValidateModifiedOnlyOption = options && typeof options === 'object' && 'validateModifiedOnly' in options;\n  let shouldValidateModifiedOnly;\n\n  if (hasValidateModifiedOnlyOption) {\n    shouldValidateModifiedOnly = !!options.validateModifiedOnly;\n  } else {\n    shouldValidateModifiedOnly = this.schema.options.validateModifiedOnly;\n  }\n\n  const _this = this;\n\n  const _complete = () => {\n    let err = this.$__.validationError;\n    this.$__.validationError = undefined;\n\n    if (shouldValidateModifiedOnly && err != null) {\n      // Remove any validation errors that aren't from modified paths\n      const errors = Object.keys(err.errors);\n\n      for (const errPath of errors) {\n        if (!this.isModified(errPath)) {\n          delete err.errors[errPath];\n        }\n      }\n\n      if (Object.keys(err.errors).length === 0) {\n        err = void 0;\n      }\n    }\n\n    this.$__.cachedRequired = {};\n    this.emit('validate', _this);\n    this.constructor.emit('validate', _this);\n\n    if (err) {\n      for (const key in err.errors) {\n        // Make sure cast errors persist\n        if (!this[documentArrayParent] && err.errors[key] instanceof MongooseError.CastError) {\n          this.invalidate(key, err.errors[key]);\n        }\n      }\n\n      return err;\n    }\n  }; // only validate required fields when necessary\n\n\n  const pathDetails = _getPathsToValidate(this);\n\n  const paths = shouldValidateModifiedOnly ? pathDetails[0].filter(path => this.isModified(path)) : pathDetails[0];\n  const skipSchemaValidators = pathDetails[1];\n\n  if (paths.length === 0) {\n    return process.nextTick(function () {\n      const error = _complete();\n\n      if (error) {\n        return _this.schema.s.hooks.execPost('validate:error', _this, [_this], {\n          error: error\n        }, function (error) {\n          callback(error);\n        });\n      }\n\n      callback(null, _this);\n    });\n  }\n\n  const validated = {};\n  let total = 0;\n\n  const complete = function () {\n    const error = _complete();\n\n    if (error) {\n      return _this.schema.s.hooks.execPost('validate:error', _this, [_this], {\n        error: error\n      }, function (error) {\n        callback(error);\n      });\n    }\n\n    callback(null, _this);\n  };\n\n  const validatePath = function (path) {\n    if (path == null || validated[path]) {\n      return;\n    }\n\n    validated[path] = true;\n    total++;\n    process.nextTick(function () {\n      const p = _this.schema.path(path);\n\n      if (!p) {\n        return --total || complete();\n      } // If user marked as invalid or there was a cast error, don't validate\n\n\n      if (!_this.$isValid(path)) {\n        --total || complete();\n        return;\n      }\n\n      let val = _this.$__getValue(path); // If you `populate()` and get back a null value, required validators\n      // shouldn't fail (gh-8018). We should always fall back to the populated\n      // value.\n\n\n      let pop;\n\n      if (val == null && (pop = _this.populated(path))) {\n        val = pop;\n      }\n\n      const scope = path in _this.$__.pathsToScopes ? _this.$__.pathsToScopes[path] : _this;\n      p.doValidate(val, function (err) {\n        if (err && (!p.$isMongooseDocumentArray || err.$isArrayValidatorError)) {\n          if (p.$isSingleNested && err.name === 'ValidationError' && p.schema.options.storeSubdocValidationError === false) {\n            return --total || complete();\n          }\n\n          _this.invalidate(path, err, undefined, true);\n        }\n\n        --total || complete();\n      }, scope, {\n        skipSchemaValidators: skipSchemaValidators[path],\n        path: path\n      });\n    });\n  };\n\n  const numPaths = paths.length;\n\n  for (let i = 0; i < numPaths; ++i) {\n    validatePath(paths[i]);\n  }\n};\n/**\n * Executes registered validation rules (skipping asynchronous validators) for this document.\n *\n * ####Note:\n *\n * This method is useful if you need synchronous validation.\n *\n * ####Example:\n *\n *     var err = doc.validateSync();\n *     if ( err ){\n *       handleError( err );\n *     } else {\n *       // validation passed\n *     }\n *\n * @param {Array|string} pathsToValidate only validate the given paths\n * @return {ValidationError|undefined} ValidationError if there are errors during validation, or undefined if there is no error.\n * @api public\n */\n\n\nDocument.prototype.validateSync = function (pathsToValidate, options) {\n  const _this = this;\n\n  const hasValidateModifiedOnlyOption = options && typeof options === 'object' && 'validateModifiedOnly' in options;\n  let shouldValidateModifiedOnly;\n\n  if (hasValidateModifiedOnlyOption) {\n    shouldValidateModifiedOnly = !!options.validateModifiedOnly;\n  } else {\n    shouldValidateModifiedOnly = this.schema.options.validateModifiedOnly;\n  }\n\n  if (typeof pathsToValidate === 'string') {\n    pathsToValidate = pathsToValidate.split(' ');\n  } // only validate required fields when necessary\n\n\n  const pathDetails = _getPathsToValidate(this);\n\n  let paths = shouldValidateModifiedOnly ? pathDetails[0].filter(path => this.isModified(path)) : pathDetails[0];\n  const skipSchemaValidators = pathDetails[1];\n\n  if (pathsToValidate && pathsToValidate.length) {\n    const tmp = [];\n\n    for (let i = 0; i < paths.length; ++i) {\n      if (pathsToValidate.indexOf(paths[i]) !== -1) {\n        tmp.push(paths[i]);\n      }\n    }\n\n    paths = tmp;\n  }\n\n  const validating = {};\n  paths.forEach(function (path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n\n    const p = _this.schema.path(path);\n\n    if (!p) {\n      return;\n    }\n\n    if (!_this.$isValid(path)) {\n      return;\n    }\n\n    const val = _this.$__getValue(path);\n\n    const err = p.doValidateSync(val, _this, {\n      skipSchemaValidators: skipSchemaValidators[path],\n      path: path\n    });\n\n    if (err && (!p.$isMongooseDocumentArray || err.$isArrayValidatorError)) {\n      if (p.$isSingleNested && err.name === 'ValidationError' && p.schema.options.storeSubdocValidationError === false) {\n        return;\n      }\n\n      _this.invalidate(path, err, undefined, true);\n    }\n  });\n  const err = _this.$__.validationError;\n  _this.$__.validationError = undefined;\n\n  _this.emit('validate', _this);\n\n  _this.constructor.emit('validate', _this);\n\n  if (err) {\n    for (const key in err.errors) {\n      // Make sure cast errors persist\n      if (err.errors[key] instanceof MongooseError.CastError) {\n        _this.invalidate(key, err.errors[key]);\n      }\n    }\n  }\n\n  return err;\n};\n/**\n * Marks a path as invalid, causing validation to fail.\n *\n * The `errorMsg` argument will become the message of the `ValidationError`.\n *\n * The `value` argument (if passed) will be available through the `ValidationError.value` property.\n *\n *     doc.invalidate('size', 'must be less than 20', 14);\n\n *     doc.validate(function (err) {\n *       console.log(err)\n *       // prints\n *       { message: 'Validation failed',\n *         name: 'ValidationError',\n *         errors:\n *          { size:\n *             { message: 'must be less than 20',\n *               name: 'ValidatorError',\n *               path: 'size',\n *               type: 'user defined',\n *               value: 14 } } }\n *     })\n *\n * @param {String} path the field to invalidate\n * @param {String|Error} errorMsg the error which states the reason `path` was invalid\n * @param {Object|String|Number|any} value optional invalid value\n * @param {String} [kind] optional `kind` property for the error\n * @return {ValidationError} the current ValidationError, with all currently invalidated paths\n * @api public\n */\n\n\nDocument.prototype.invalidate = function (path, err, val, kind) {\n  if (!this.$__.validationError) {\n    this.$__.validationError = new ValidationError(this);\n  }\n\n  if (this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  if (!err || typeof err === 'string') {\n    err = new ValidatorError({\n      path: path,\n      message: err,\n      type: kind || 'user defined',\n      value: val\n    });\n  }\n\n  if (this.$__.validationError === err) {\n    return this.$__.validationError;\n  }\n\n  this.$__.validationError.addError(path, err);\n  return this.$__.validationError;\n};\n/**\n * Marks a path as valid, removing existing validation errors.\n *\n * @param {String} path the field to mark as valid\n * @api public\n * @memberOf Document\n * @instance\n * @method $markValid\n */\n\n\nDocument.prototype.$markValid = function (path) {\n  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  delete this.$__.validationError.errors[path];\n\n  if (Object.keys(this.$__.validationError.errors).length === 0) {\n    this.$__.validationError = null;\n  }\n};\n/**\n * Saves this document.\n *\n * ####Example:\n *\n *     product.sold = Date.now();\n *     product.save(function (err, product) {\n *       if (err) ..\n *     })\n *\n * The callback will receive two parameters\n *\n * 1. `err` if an error occurred\n * 2. `product` which is the saved `product`\n *\n * As an extra measure of flow control, save will return a Promise.\n * ####Example:\n *     product.save().then(function(product) {\n *        ...\n *     });\n *\n * @param {Object} [options] options optional options\n * @param {Object} [options.safe] (DEPRECATED) overrides [schema's safe option](http://mongoosejs.com//docs/guide.html#safe)\n * @param {Boolean} [options.validateBeforeSave] set to false to save without validating.\n * @param {Function} [fn] optional callback\n * @method save\n * @memberOf Document\n * @instance\n * @return {Promise|undefined} Returns undefined if used with callback or a Promise otherwise.\n * @api public\n * @see middleware http://mongoosejs.com/docs/middleware.html\n */\n\n/**\n * Checks if a path is invalid\n *\n * @param {String} path the field to check\n * @method $isValid\n * @memberOf Document\n * @instance\n * @api private\n */\n\n\nDocument.prototype.$isValid = function (path) {\n  return !this.$__.validationError || !this.$__.validationError.errors[path];\n};\n/**\n * Resets the internal modified state of this document.\n *\n * @api private\n * @return {Document}\n * @method $__reset\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.$__reset = function reset() {\n  let _this = this;\n\n  DocumentArray || (DocumentArray = require('./types/documentarray'));\n  this.$__.activePaths.map('init', 'modify', function (i) {\n    return _this.$__getValue(i);\n  }).filter(function (val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  }).forEach(function (array) {\n    let i = array.length;\n\n    while (i--) {\n      const doc = array[i];\n\n      if (!doc) {\n        continue;\n      }\n\n      doc.$__reset();\n    }\n\n    _this.$__.activePaths.init(array.$path());\n\n    array[arrayAtomicsSymbol] = {};\n  });\n  this.$__.activePaths.map('init', 'modify', function (i) {\n    return _this.$__getValue(i);\n  }).filter(function (val) {\n    return val && val.$isSingleNested;\n  }).forEach(function (doc) {\n    doc.$__reset();\n\n    _this.$__.activePaths.init(doc.$basePath);\n  }); // clear atomics\n\n  this.$__dirty().forEach(function (dirt) {\n    const type = dirt.value;\n\n    if (type && type[arrayAtomicsSymbol]) {\n      type[arrayAtomicsSymbol] = {};\n    }\n  }); // Clear 'dirty' cache\n\n  this.$__.activePaths.clear('modify');\n  this.$__.activePaths.clear('default');\n  this.$__.validationError = undefined;\n  this.errors = undefined;\n  _this = this;\n  this.schema.requiredPaths().forEach(function (path) {\n    _this.$__.activePaths.require(path);\n  });\n  return this;\n};\n/**\n * Returns this documents dirty paths / vals.\n *\n * @api private\n * @method $__dirty\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.$__dirty = function () {\n  const _this = this;\n\n  let all = this.$__.activePaths.map('modify', function (path) {\n    return {\n      path: path,\n      value: _this.$__getValue(path),\n      schema: _this.$__path(path)\n    };\n  }); // gh-2558: if we had to set a default and the value is not undefined,\n  // we have to save as well\n\n  all = all.concat(this.$__.activePaths.map('default', function (path) {\n    if (path === '_id' || _this.$__getValue(path) == null) {\n      return;\n    }\n\n    return {\n      path: path,\n      value: _this.$__getValue(path),\n      schema: _this.$__path(path)\n    };\n  })); // Sort dirty paths in a flat hierarchy.\n\n  all.sort(function (a, b) {\n    return a.path < b.path ? -1 : a.path > b.path ? 1 : 0;\n  }); // Ignore \"foo.a\" if \"foo\" is dirty already.\n\n  const minimal = [];\n  let lastPath;\n  let top;\n  all.forEach(function (item) {\n    if (!item) {\n      return;\n    }\n\n    if (lastPath == null || item.path.indexOf(lastPath) !== 0) {\n      lastPath = item.path + '.';\n      minimal.push(item);\n      top = item;\n    } else if (top != null && top.value != null && top.value[arrayAtomicsSymbol] != null && top.value.hasAtomics()) {\n      // special case for top level MongooseArrays\n      // the `top` array itself and a sub path of `top` are being modified.\n      // the only way to honor all of both modifications is through a $set\n      // of entire array.\n      top.value[arrayAtomicsSymbol] = {};\n      top.value[arrayAtomicsSymbol].$set = top.value;\n    }\n  });\n  top = lastPath = null;\n  return minimal;\n};\n/**\n * Assigns/compiles `schema` into this documents prototype.\n *\n * @param {Schema} schema\n * @api private\n * @method $__setSchema\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.$__setSchema = function (schema) {\n  schema.plugin(idGetter, {\n    deduplicate: true\n  });\n  compile(schema.tree, this, undefined, schema.options); // Apply default getters if virtual doesn't have any (gh-6262)\n\n  for (const key of Object.keys(schema.virtuals)) {\n    schema.virtuals[key]._applyDefaultGetters();\n  }\n\n  this.schema = schema;\n  this[documentSchemaSymbol] = schema;\n};\n/**\n * Get active path that were changed and are arrays\n *\n * @api private\n * @method $__getArrayPathsToValidate\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.$__getArrayPathsToValidate = function () {\n  DocumentArray || (DocumentArray = require('./types/documentarray')); // validate all document arrays.\n\n  return this.$__.activePaths.map('init', 'modify', function (i) {\n    return this.$__getValue(i);\n  }.bind(this)).filter(function (val) {\n    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n  }).reduce(function (seed, array) {\n    return seed.concat(array);\n  }, []).filter(function (doc) {\n    return doc;\n  });\n};\n/**\n * Get all subdocs (by bfs)\n *\n * @api private\n * @method $__getAllSubdocs\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.$__getAllSubdocs = function () {\n  DocumentArray || (DocumentArray = require('./types/documentarray'));\n  Embedded = Embedded || require('./types/embedded');\n\n  function docReducer(doc, seed, path) {\n    let val = doc;\n\n    if (path) {\n      if (doc instanceof Document && doc[documentSchemaSymbol].paths[path]) {\n        val = doc._doc[path];\n      } else {\n        val = doc[path];\n      }\n    }\n\n    if (val instanceof Embedded) {\n      seed.push(val);\n    } else if (val instanceof Map) {\n      seed = Array.from(val.keys()).reduce(function (seed, path) {\n        return docReducer(val.get(path), seed, null);\n      }, seed);\n    } else if (val && val.$isSingleNested) {\n      seed = Object.keys(val._doc).reduce(function (seed, path) {\n        return docReducer(val._doc, seed, path);\n      }, seed);\n      seed.push(val);\n    } else if (val && val.isMongooseDocumentArray) {\n      val.forEach(function _docReduce(doc) {\n        if (!doc || !doc._doc) {\n          return;\n        }\n\n        seed = Object.keys(doc._doc).reduce(function (seed, path) {\n          return docReducer(doc._doc, seed, path);\n        }, seed);\n\n        if (doc instanceof Embedded) {\n          seed.push(doc);\n        }\n      });\n    } else if (val instanceof Document && val.$__isNested) {\n      seed = Object.keys(val).reduce(function (seed, path) {\n        return docReducer(val, seed, path);\n      }, seed);\n    }\n\n    return seed;\n  }\n\n  const _this = this;\n\n  const subDocs = Object.keys(this._doc).reduce(function (seed, path) {\n    return docReducer(_this, seed, path);\n  }, []);\n  return subDocs;\n};\n/*!\n * Runs queued functions\n */\n\n\nfunction applyQueue(doc) {\n  const q = doc.schema && doc.schema.callQueue;\n\n  if (!q.length) {\n    return;\n  }\n\n  let pair;\n\n  for (let i = 0; i < q.length; ++i) {\n    pair = q[i];\n\n    if (pair[0] !== 'pre' && pair[0] !== 'post' && pair[0] !== 'on') {\n      doc[pair[0]].apply(doc, pair[1]);\n    }\n  }\n}\n/*!\n * ignore\n */\n\n\nDocument.prototype.$__handleReject = function handleReject(err) {\n  // emit on the Model if listening\n  if (this.listeners('error').length) {\n    this.emit('error', err);\n  } else if (this.constructor.listeners && this.constructor.listeners('error').length) {\n    this.constructor.emit('error', err);\n  } else if (this.listeners && this.listeners('error').length) {\n    this.emit('error', err);\n  }\n};\n/**\n * Internal helper for toObject() and toJSON() that doesn't manipulate options\n *\n * @api private\n * @method $toObject\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.$toObject = function (options, json) {\n  let defaultOptions = {\n    transform: true,\n    flattenDecimals: true\n  };\n  const path = json ? 'toJSON' : 'toObject';\n  const baseOptions = get(this, 'constructor.base.options.' + path, {});\n  const schemaOptions = get(this, 'schema.options', {}); // merge base default options with Schema's set default options if available.\n  // `clone` is necessary here because `utils.options` directly modifies the second input.\n\n  defaultOptions = utils.options(defaultOptions, clone(baseOptions));\n  defaultOptions = utils.options(defaultOptions, clone(schemaOptions[path] || {})); // If options do not exist or is not an object, set it to empty object\n\n  options = utils.isPOJO(options) ? clone(options) : {};\n\n  if (!('flattenMaps' in options)) {\n    options.flattenMaps = defaultOptions.flattenMaps;\n  }\n\n  let _minimize;\n\n  if (options.minimize != null) {\n    _minimize = options.minimize;\n  } else if (defaultOptions.minimize != null) {\n    _minimize = defaultOptions.minimize;\n  } else {\n    _minimize = schemaOptions.minimize;\n  } // The original options that will be passed to `clone()`. Important because\n  // `clone()` will recursively call `$toObject()` on embedded docs, so we\n  // need the original options the user passed in, plus `_isNested` and\n  // `_parentOptions` for checking whether we need to depopulate.\n\n\n  const cloneOptions = Object.assign(utils.clone(options), {\n    _isNested: true,\n    json: json,\n    minimize: _minimize\n  });\n\n  if (utils.hasUserDefinedProperty(options, 'getters')) {\n    cloneOptions.getters = options.getters;\n  }\n\n  if (utils.hasUserDefinedProperty(options, 'virtuals')) {\n    cloneOptions.virtuals = options.virtuals;\n  }\n\n  const depopulate = options.depopulate || get(options, '_parentOptions.depopulate', false); // _isNested will only be true if this is not the top level document, we\n  // should never depopulate\n\n  if (depopulate && options._isNested && this.$__.wasPopulated) {\n    // populated paths that we set to a document\n    return clone(this._id, cloneOptions);\n  } // merge default options with input options.\n\n\n  options = utils.options(defaultOptions, options);\n  options._isNested = true;\n  options.json = json;\n  options.minimize = _minimize;\n  cloneOptions._parentOptions = options;\n  cloneOptions._skipSingleNestedGetters = true;\n  const gettersOptions = Object.assign({}, cloneOptions);\n  gettersOptions._skipSingleNestedGetters = false; // remember the root transform function\n  // to save it from being overwritten by sub-transform functions\n\n  const originalTransform = options.transform;\n  let ret = clone(this._doc, cloneOptions) || {};\n\n  if (options.getters) {\n    applyGetters(this, ret, gettersOptions);\n\n    if (options.minimize) {\n      ret = minimize(ret) || {};\n    }\n  }\n\n  if (options.virtuals || options.getters && options.virtuals !== false) {\n    applyVirtuals(this, ret, gettersOptions, options);\n  }\n\n  if (options.versionKey === false && this.schema.options.versionKey) {\n    delete ret[this.schema.options.versionKey];\n  }\n\n  let transform = options.transform; // In the case where a subdocument has its own transform function, we need to\n  // check and see if the parent has a transform (options.transform) and if the\n  // child schema has a transform (this.schema.options.toObject) In this case,\n  // we need to adjust options.transform to be the child schema's transform and\n  // not the parent schema's\n\n  if (transform === true || schemaOptions.toObject && transform) {\n    const opts = options.json ? schemaOptions.toJSON : schemaOptions.toObject;\n\n    if (opts) {\n      transform = typeof options.transform === 'function' ? options.transform : opts.transform;\n    }\n  } else {\n    options.transform = originalTransform;\n  }\n\n  if (typeof transform === 'function') {\n    const xformed = transform(this, ret, options);\n\n    if (typeof xformed !== 'undefined') {\n      ret = xformed;\n    }\n  }\n\n  return ret;\n};\n/**\n * Converts this document into a plain javascript object, ready for storage in MongoDB.\n *\n * Buffers are converted to instances of [mongodb.Binary](http://mongodb.github.com/node-mongodb-native/api-bson-generated/binary.html) for proper storage.\n *\n * ####Options:\n *\n * - `getters` apply all getters (path and virtual getters), defaults to false\n * - `virtuals` apply virtual getters (can override `getters` option), defaults to false\n * - `minimize` remove empty objects (defaults to true)\n * - `transform` a transform function to apply to the resulting document before returning\n * - `depopulate` depopulate any populated paths, replacing them with their original refs (defaults to false)\n * - `versionKey` whether to include the version key (defaults to true)\n *\n * ####Getters/Virtuals\n *\n * Example of only applying path getters\n *\n *     doc.toObject({ getters: true, virtuals: false })\n *\n * Example of only applying virtual getters\n *\n *     doc.toObject({ virtuals: true })\n *\n * Example of applying both path and virtual getters\n *\n *     doc.toObject({ getters: true })\n *\n * To apply these options to every document of your schema by default, set your [schemas](#schema_Schema) `toObject` option to the same argument.\n *\n *     schema.set('toObject', { virtuals: true })\n *\n * ####Transform\n *\n * We may need to perform a transformation of the resulting object based on some criteria, say to remove some sensitive information or return a custom object. In this case we set the optional `transform` function.\n *\n * Transform functions receive three arguments\n *\n *     function (doc, ret, options) {}\n *\n * - `doc` The mongoose document which is being converted\n * - `ret` The plain object representation which has been converted\n * - `options` The options in use (either schema options or the options passed inline)\n *\n * ####Example\n *\n *     // specify the transform schema option\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       // remove the _id of every document before returning the result\n *       delete ret._id;\n *       return ret;\n *     }\n *\n *     // without the transformation in the schema\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\n *\n *     // with the transformation\n *     doc.toObject(); // { name: 'Wreck-it Ralph' }\n *\n * With transformations we can do a lot more than remove properties. We can even return completely new customized objects:\n *\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       return { movie: ret.name }\n *     }\n *\n *     // without the transformation in the schema\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\n *\n *     // with the transformation\n *     doc.toObject(); // { movie: 'Wreck-it Ralph' }\n *\n * _Note: if a transform function returns `undefined`, the return value will be ignored._\n *\n * Transformations may also be applied inline, overridding any transform set in the options:\n *\n *     function xform (doc, ret, options) {\n *       return { inline: ret.name, custom: true }\n *     }\n *\n *     // pass the transform as an inline option\n *     doc.toObject({ transform: xform }); // { inline: 'Wreck-it Ralph', custom: true }\n *\n * If you want to skip transformations, use `transform: false`:\n *\n *     schema.options.toObject.hide = '_id';\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       if (options.hide) {\n *         options.hide.split(' ').forEach(function (prop) {\n *           delete ret[prop];\n *         });\n *       }\n *       return ret;\n *     }\n *\n *     var doc = new Doc({ _id: 'anId', secret: 47, name: 'Wreck-it Ralph' });\n *     doc.toObject();                                        // { secret: 47, name: 'Wreck-it Ralph' }\n *     doc.toObject({ hide: 'secret _id', transform: false });// { _id: 'anId', secret: 47, name: 'Wreck-it Ralph' }\n *     doc.toObject({ hide: 'secret _id', transform: true }); // { name: 'Wreck-it Ralph' }\n *\n * If you pass a transform in `toObject()` options, Mongoose will apply the transform\n * to [subdocuments](/docs/subdocs.html) in addition to the top-level document.\n * Similarly, `transform: false` skips transforms for all subdocuments.\n * Note that this is behavior is different for transforms defined in the schema:\n * if you define a transform in `schema.options.toObject.transform`, that transform\n * will **not** apply to subdocuments.\n *\n *     const memberSchema = new Schema({ name: String, email: String });\n *     const groupSchema = new Schema({ members: [memberSchema], name: String, email });\n *     const Group = mongoose.model('Group', groupSchema);\n *\n *     const doc = new Group({\n *       name: 'Engineering',\n *       email: 'dev@mongoosejs.io',\n *       members: [{ name: 'Val', email: 'val@mongoosejs.io' }]\n *     });\n *\n *     // Removes `email` from both top-level document **and** array elements\n *     // { name: 'Engineering', members: [{ name: 'Val' }] }\n *     doc.toObject({ transform: (doc, ret) => { delete ret.email; return ret; } });\n *\n * Transforms, like all of these options, are also available for `toJSON`. See [this guide to `JSON.stringify()`](https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html) to learn why `toJSON()` and `toObject()` are separate functions.\n *\n * See [schema options](/docs/guide.html#toObject) for some more details.\n *\n * _During save, no custom options are applied to the document before being sent to the database._\n *\n * @param {Object} [options]\n * @param {Boolean} [options.getters=false] if true, apply all getters, including virtuals\n * @param {Boolean} [options.virtuals=false] if true, apply virtuals, including aliases. Use `{ getters: true, virtuals: false }` to just apply getters, not virtuals\n * @param {Boolean} [options.aliases=true] if `options.virtuals = true`, you can set `options.aliases = false` to skip applying aliases. This option is a no-op if `options.virtuals = false`.\n * @param {Boolean} [options.minimize=true] if true, omit any empty objects from the output\n * @param {Function|null} [options.transform=null] if set, mongoose will call this function to allow you to transform the returned object\n * @param {Boolean} [options.depopulate=false] if true, replace any conventionally populated paths with the original id in the output. Has no affect on virtual populated paths.\n * @param {Boolean} [options.versionKey=true] if false, exclude the version key (`__v` by default) from the output\n * @param {Boolean} [options.flattenMaps=false] if true, convert Maps to POJOs. Useful if you want to `JSON.stringify()` the result of `toObject()`.\n * @return {Object} js object\n * @see mongodb.Binary http://mongodb.github.com/node-mongodb-native/api-bson-generated/binary.html\n * @api public\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.toObject = function (options) {\n  return this.$toObject(options);\n};\n/*!\n * Minimizes an object, removing undefined values and empty objects\n *\n * @param {Object} object to minimize\n * @return {Object}\n */\n\n\nfunction minimize(obj) {\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let hasKeys;\n  let key;\n  let val;\n\n  while (i--) {\n    key = keys[i];\n    val = obj[key];\n\n    if (utils.isObject(val) && !Buffer.isBuffer(val)) {\n      obj[key] = minimize(val);\n    }\n\n    if (undefined === obj[key]) {\n      delete obj[key];\n      continue;\n    }\n\n    hasKeys = true;\n  }\n\n  return hasKeys ? obj : undefined;\n}\n/*!\n * Applies virtuals properties to `json`.\n */\n\n\nfunction applyVirtuals(self, json, options, toObjectOptions) {\n  const schema = self.schema;\n  const paths = Object.keys(schema.virtuals);\n  let i = paths.length;\n  const numPaths = i;\n  let path;\n  let assignPath;\n  let cur = self._doc;\n  let v;\n  const aliases = get(toObjectOptions, 'aliases', true);\n\n  if (!cur) {\n    return json;\n  }\n\n  options = options || {};\n\n  for (i = 0; i < numPaths; ++i) {\n    path = paths[i]; // Allow skipping aliases with `toObject({ virtuals: true, aliases: false })`\n\n    if (!aliases && schema.aliases.hasOwnProperty(path)) {\n      continue;\n    } // We may be applying virtuals to a nested object, for example if calling\n    // `doc.nestedProp.toJSON()`. If so, the path we assign to, `assignPath`,\n    // will be a trailing substring of the `path`.\n\n\n    assignPath = path;\n\n    if (options.path != null) {\n      if (!path.startsWith(options.path + '.')) {\n        continue;\n      }\n\n      assignPath = path.substr(options.path.length + 1);\n    }\n\n    const parts = assignPath.split('.');\n    v = clone(self.get(path), options);\n\n    if (v === void 0) {\n      continue;\n    }\n\n    const plen = parts.length;\n    cur = json;\n\n    for (let j = 0; j < plen - 1; ++j) {\n      cur[parts[j]] = cur[parts[j]] || {};\n      cur = cur[parts[j]];\n    }\n\n    cur[parts[plen - 1]] = v;\n  }\n\n  return json;\n}\n/*!\n * Applies virtuals properties to `json`.\n *\n * @param {Document} self\n * @param {Object} json\n * @return {Object} `json`\n */\n\n\nfunction applyGetters(self, json, options) {\n  const schema = self.schema;\n  const paths = Object.keys(schema.paths);\n  let i = paths.length;\n  let path;\n  let cur = self._doc;\n  let v;\n\n  if (!cur) {\n    return json;\n  }\n\n  while (i--) {\n    path = paths[i];\n    const parts = path.split('.');\n    const plen = parts.length;\n    const last = plen - 1;\n    let branch = json;\n    let part;\n    cur = self._doc;\n\n    if (!self.isSelected(path)) {\n      continue;\n    }\n\n    for (let ii = 0; ii < plen; ++ii) {\n      part = parts[ii];\n      v = cur[part];\n\n      if (ii === last) {\n        const val = self.get(path);\n        branch[part] = clone(val, options);\n      } else if (v == null) {\n        if (part in cur) {\n          branch[part] = v;\n        }\n\n        break;\n      } else {\n        branch = branch[part] || (branch[part] = {});\n      }\n\n      cur = v;\n    }\n  }\n\n  return json;\n}\n/**\n * The return value of this method is used in calls to JSON.stringify(doc).\n *\n * This method accepts the same options as [Document#toObject](#document_Document-toObject). To apply the options to every document of your schema by default, set your [schemas](#schema_Schema) `toJSON` option to the same argument.\n *\n *     schema.set('toJSON', { virtuals: true })\n *\n * See [schema options](/docs/guide.html#toJSON) for details.\n *\n * @param {Object} options\n * @return {Object}\n * @see Document#toObject #document_Document-toObject\n * @see JSON.stringify() in JavaScript https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html\n * @api public\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.toJSON = function (options) {\n  return this.$toObject(options, true);\n};\n/**\n * Helper for console.log\n *\n * @api public\n * @method inspect\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.inspect = function (options) {\n  const isPOJO = utils.isPOJO(options);\n  let opts;\n\n  if (isPOJO) {\n    opts = options;\n    opts.minimize = false;\n  }\n\n  const ret = this.toObject(opts);\n\n  if (ret == null) {\n    // If `toObject()` returns null, `this` is still an object, so if `inspect()`\n    // prints out null this can cause some serious confusion. See gh-7942.\n    return 'MongooseDocument { ' + ret + ' }';\n  }\n\n  return ret;\n};\n\nif (inspect.custom) {\n  /*!\n  * Avoid Node deprecation warning DEP0079\n  */\n  Document.prototype[inspect.custom] = Document.prototype.inspect;\n}\n/**\n * Helper for console.log\n *\n * @api public\n * @method toString\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.toString = function () {\n  const ret = this.inspect();\n\n  if (typeof ret === 'string') {\n    return ret;\n  }\n\n  return inspect(ret);\n};\n/**\n * Returns true if the Document stores the same data as doc.\n *\n * Documents are considered equal when they have matching `_id`s, unless neither\n * document has an `_id`, in which case this function falls back to using\n * `deepEqual()`.\n *\n * @param {Document} doc a document to compare\n * @return {Boolean}\n * @api public\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.equals = function (doc) {\n  if (!doc) {\n    return false;\n  }\n\n  const tid = this.get('_id');\n  const docid = doc.get ? doc.get('_id') : doc;\n\n  if (!tid && !docid) {\n    return deepEqual(this, doc);\n  }\n\n  return tid && tid.equals ? tid.equals(docid) : tid === docid;\n};\n/**\n * Populates document references, executing the `callback` when complete.\n * If you want to use promises instead, use this function with\n * [`execPopulate()`](#document_Document-execPopulate)\n *\n * ####Example:\n *\n *     doc\n *     .populate('company')\n *     .populate({\n *       path: 'notes',\n *       match: /airline/,\n *       select: 'text',\n *       model: 'modelName'\n *       options: opts\n *     }, function (err, user) {\n *       assert(doc._id === user._id) // the document itself is passed\n *     })\n *\n *     // summary\n *     doc.populate(path)                   // not executed\n *     doc.populate(options);               // not executed\n *     doc.populate(path, callback)         // executed\n *     doc.populate(options, callback);     // executed\n *     doc.populate(callback);              // executed\n *     doc.populate(options).execPopulate() // executed, returns promise\n *\n *\n * ####NOTE:\n *\n * Population does not occur unless a `callback` is passed *or* you explicitly\n * call `execPopulate()`.\n * Passing the same path a second time will overwrite the previous path options.\n * See [Model.populate()](#model_Model.populate) for explaination of options.\n *\n * @see Model.populate #model_Model.populate\n * @see Document.execPopulate #document_Document-execPopulate\n * @param {String|Object} [path] The path to populate or an options object\n * @param {Function} [callback] When passed, population is invoked\n * @api public\n * @return {Document} this\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.populate = function populate() {\n  if (arguments.length === 0) {\n    return this;\n  }\n\n  const pop = this.$__.populate || (this.$__.populate = {});\n  const args = utils.args(arguments);\n  let fn;\n\n  if (typeof args[args.length - 1] === 'function') {\n    fn = args.pop();\n  } // allow `doc.populate(callback)`\n\n\n  if (args.length) {\n    // use hash to remove duplicate paths\n    const res = utils.populate.apply(null, args);\n\n    for (let i = 0; i < res.length; ++i) {\n      pop[res[i].path] = res[i];\n    }\n  }\n\n  if (fn) {\n    const paths = utils.object.vals(pop);\n    this.$__.populate = undefined;\n    let topLevelModel = this.constructor;\n\n    if (this.$__isNested) {\n      topLevelModel = this.$__.scope.constructor;\n      const nestedPath = this.$__.nestedPath;\n      paths.forEach(function (populateOptions) {\n        populateOptions.path = nestedPath + '.' + populateOptions.path;\n      });\n    } // Use `$session()` by default if the document has an associated session\n    // See gh-6754\n\n\n    if (this.$session() != null) {\n      const session = this.$session();\n      paths.forEach(path => {\n        if (path.options == null) {\n          path.options = {\n            session: session\n          };\n          return;\n        }\n\n        if (!('session' in path.options)) {\n          path.options.session = session;\n        }\n      });\n    }\n\n    topLevelModel.populate(this, paths, fn);\n  }\n\n  return this;\n};\n/**\n * Explicitly executes population and returns a promise. Useful for ES2015\n * integration.\n *\n * ####Example:\n *\n *     var promise = doc.\n *       populate('company').\n *       populate({\n *         path: 'notes',\n *         match: /airline/,\n *         select: 'text',\n *         model: 'modelName'\n *         options: opts\n *       }).\n *       execPopulate();\n *\n *     // summary\n *     doc.execPopulate().then(resolve, reject);\n *\n *\n * @see Document.populate #document_Document-populate\n * @api public\n * @param {Function} [callback] optional callback. If specified, a promise will **not** be returned\n * @return {Promise} promise that resolves to the document when population is done\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.execPopulate = function (callback) {\n  return utils.promiseOrCallback(callback, cb => {\n    this.populate(cb);\n  }, this.constructor.events);\n};\n/**\n * Gets _id(s) used during population of the given `path`.\n *\n * ####Example:\n *\n *     Model.findOne().populate('author').exec(function (err, doc) {\n *       console.log(doc.author.name)         // Dr.Seuss\n *       console.log(doc.populated('author')) // '5144cf8050f071d979c118a7'\n *     })\n *\n * If the path was not populated, undefined is returned.\n *\n * @param {String} path\n * @return {Array|ObjectId|Number|Buffer|String|undefined}\n * @memberOf Document\n * @instance\n * @api public\n */\n\n\nDocument.prototype.populated = function (path, val, options) {\n  // val and options are internal\n  if (val === null || val === void 0) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n\n    const v = this.$__.populated[path];\n\n    if (v) {\n      return v.value;\n    }\n\n    return undefined;\n  } // internal\n\n\n  if (val === true) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n\n    return this.$__.populated[path];\n  }\n\n  this.$__.populated || (this.$__.populated = {});\n  this.$__.populated[path] = {\n    value: val,\n    options: options\n  }; // If this was a nested populate, make sure each populated doc knows\n  // about its populated children (gh-7685)\n\n  const pieces = path.split('.');\n\n  for (let i = 0; i < pieces.length - 1; ++i) {\n    const subpath = pieces.slice(0, i + 1).join('.');\n    const subdoc = this.get(subpath);\n\n    if (subdoc != null && subdoc.$__ != null && this.populated(subpath)) {\n      const rest = pieces.slice(i + 1).join('.');\n      subdoc.populated(rest, val, options); // No need to continue because the above recursion should take care of\n      // marking the rest of the docs as populated\n\n      break;\n    }\n  }\n\n  return val;\n};\n/**\n * Takes a populated field and returns it to its unpopulated state.\n *\n * ####Example:\n *\n *     Model.findOne().populate('author').exec(function (err, doc) {\n *       console.log(doc.author.name); // Dr.Seuss\n *       console.log(doc.depopulate('author'));\n *       console.log(doc.author); // '5144cf8050f071d979c118a7'\n *     })\n *\n * If the path was not populated, this is a no-op.\n *\n * @param {String} path\n * @return {Document} this\n * @see Document.populate #document_Document-populate\n * @api public\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.depopulate = function (path) {\n  if (typeof path === 'string') {\n    path = path.split(' ');\n  }\n\n  let populatedIds;\n  const virtualKeys = this.$$populatedVirtuals ? Object.keys(this.$$populatedVirtuals) : [];\n  const populated = get(this, '$__.populated', {});\n\n  if (arguments.length === 0) {\n    // Depopulate all\n    for (let i = 0; i < virtualKeys.length; i++) {\n      delete this.$$populatedVirtuals[virtualKeys[i]];\n      delete this._doc[virtualKeys[i]];\n      delete populated[virtualKeys[i]];\n    }\n\n    const keys = Object.keys(populated);\n\n    for (let i = 0; i < keys.length; i++) {\n      populatedIds = this.populated(keys[i]);\n\n      if (!populatedIds) {\n        continue;\n      }\n\n      delete populated[keys[i]];\n      this.$set(keys[i], populatedIds);\n    }\n\n    return this;\n  }\n\n  for (let i = 0; i < path.length; i++) {\n    populatedIds = this.populated(path[i]);\n    delete populated[path[i]];\n\n    if (virtualKeys.indexOf(path[i]) !== -1) {\n      delete this.$$populatedVirtuals[path[i]];\n      delete this._doc[path[i]];\n    } else if (populatedIds) {\n      this.$set(path[i], populatedIds);\n    }\n  }\n\n  return this;\n};\n/**\n * Returns the full path to this document.\n *\n * @param {String} [path]\n * @return {String}\n * @api private\n * @method $__fullPath\n * @memberOf Document\n * @instance\n */\n\n\nDocument.prototype.$__fullPath = function (path) {\n  // overridden in SubDocuments\n  return path || '';\n};\n/*!\n * Module exports.\n */\n\n\nDocument.ValidationError = ValidationError;\nmodule.exports = exports = Document;","map":{"version":3,"sources":["D:/Other/Git/Developer-Connector/node_modules/mongoose/lib/document.js"],"names":["EventEmitter","require","InternalCache","MongooseError","MixedSchema","ObjectExpectedError","ObjectParameterError","Schema","StrictModeError","ValidatorError","VirtualType","cleanModifiedSubpaths","compile","defineKey","flatten","get","getEmbeddedDiscriminatorPath","idGetter","isDefiningProjection","isExclusive","inspect","internalToObjectOptions","mpath","utils","ValidationError","clone","deepEqual","isMongooseObject","arrayAtomicsSymbol","documentArrayParent","documentSchemaSymbol","getSymbol","populateModelSymbol","DocumentArray","MongooseArray","Embedded","specialProperties","Document","obj","fields","skipId","options","schema","_schema","isObject","instanceOfSchema","$__setSchema","arguments","$__","emitter","isNew","errors","undefined","$options","strictMode","strict","selected","required","requiredPaths","i","length","activePaths","setMaxListeners","exclude","isPOJO","hasIncludedChildren","$__hasIncludedChildren","_doc","$__buildDoc","$__applyDefaults","$__original_set","$set","willInit","prototype","once","call","skipDefaults","_id","$locals","_this","keys","Object","forEach","key","tree","applyQueue","each","emitterFn","apply","constructor","defineProperty","configurable","enumerable","writable","id","j","parts","split","c","k","push","join","doc","isBeforeSetters","pathsToSkip","paths","plen","def","curPath","p","type","path","len","included","doc_","piece","defaultValue","$runBeforeSetters","getDefault","default","filter","includes","ii","last","toBSON","toObject","init","opts","fn","$__init","$init","populated","String","item","isVirtual","getValue","_docs","markArraySubdocsPopulated","emit","pieces","subpath","slice","rest","val","isMongooseDocumentArray","self","prefix","index","_init","$isRootDiscriminator","isSelected","intCache","wasPopulated","cast","e","invalidate","message","value","isModified","update","args","unshift","query","$session","session","updateOne","callback","_pre","cb","_middleware","execPre","_post","execPost","exec","replaceOne","ownerDocument","subdocs","$__getAllSubdocs","child","overwrite","Array","from","Set","concat","versionKey","merge","adhoc","constructing","adhocs","pathtype","adhocPaths","interpretAsType","_","$__isNested","minimize","_handleIndex","$setCalled","add","pathName","pathType","isNativeObject","isMongooseType","$__path","ref","typeOnly","$isSingleNested","virtuals","transform","$__setValue","markModified","skipDocArrays","CastError","aliases","mixed","set","virtualpath","applySetters","cur","unmarkModified","$__getValue","pathToMark","getters","priorVal","priorDoc","$__set","shouldSet","refMatches","model","modelName","baseModelName","refPath","didPopulate","popOpts","isArray","typeKey","$__fullPath","map","v","singleNestedPaths","$isMongooseDocumentArray","populatedPaths","populatedPath","$markValid","isImmutableError","instance","isDirectModified","$__shouldModify","states","shouldModify","isMongooseArray","_registerAtomic","__parentArray","modifiedPath","startsWith","ignore","l","next","has","Map","setValue","virtual","applyGetters","nested","applyVirtuals","adhocType","hasOwnProperty","scope","modify","pathsToScopes","$ignore","directModifiedPaths","$isEmpty","isEmptyOptions","_isEmpty","modifiedPaths","reduce","list","chains","part","chain","indexOf","includeChildren","modified","childPath","isModifiedChild","some","mod","$isDefault","$isDeleted","isDeleted","isInit","inclusive","pathDot","isDirectSelected","validate","promiseOrCallback","$__validate","error","events","_evaluateRequiredFunctions","originalRequiredValue","cachedRequired","_getPathsToValidate","skipSchemaValidators","subdoc","$basePath","_pathType","$isMongooseArray","_pushNestedArrayPaths","numElements","flattenOptions","skipArrays","pathToCheck","_v","flat","$isSchemaMap","hasValidateModifiedOnlyOption","shouldValidateModifiedOnly","validateModifiedOnly","_complete","err","validationError","errPath","pathDetails","process","nextTick","s","hooks","validated","total","complete","validatePath","$isValid","pop","doValidate","$isArrayValidatorError","name","storeSubdocValidationError","numPaths","validateSync","pathsToValidate","tmp","validating","doValidateSync","kind","addError","$__reset","reset","array","$path","$__dirty","dirt","clear","all","sort","a","b","minimal","lastPath","top","hasAtomics","plugin","deduplicate","_applyDefaultGetters","$__getArrayPathsToValidate","bind","seed","docReducer","_docReduce","subDocs","q","callQueue","pair","$__handleReject","handleReject","listeners","$toObject","json","defaultOptions","flattenDecimals","baseOptions","schemaOptions","flattenMaps","_minimize","cloneOptions","assign","_isNested","hasUserDefinedProperty","depopulate","_parentOptions","_skipSingleNestedGetters","gettersOptions","originalTransform","ret","toJSON","xformed","hasKeys","Buffer","isBuffer","toObjectOptions","assignPath","substr","branch","custom","toString","equals","tid","docid","populate","res","object","vals","topLevelModel","nestedPath","populateOptions","execPopulate","populatedIds","virtualKeys","$$populatedVirtuals","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst EventEmitter = require('events').EventEmitter;\nconst InternalCache = require('./internal');\nconst MongooseError = require('./error/index');\nconst MixedSchema = require('./schema/mixed');\nconst ObjectExpectedError = require('./error/objectExpected');\nconst ObjectParameterError = require('./error/objectParameter');\nconst Schema = require('./schema');\nconst StrictModeError = require('./error/strict');\nconst ValidatorError = require('./schematype').ValidatorError;\nconst VirtualType = require('./virtualtype');\nconst cleanModifiedSubpaths = require('./helpers/document/cleanModifiedSubpaths');\nconst compile = require('./helpers/document/compile').compile;\nconst defineKey = require('./helpers/document/compile').defineKey;\nconst flatten = require('./helpers/common').flatten;\nconst get = require('./helpers/get');\nconst getEmbeddedDiscriminatorPath = require('./helpers/document/getEmbeddedDiscriminatorPath');\nconst idGetter = require('./plugins/idGetter');\nconst isDefiningProjection = require('./helpers/projection/isDefiningProjection');\nconst isExclusive = require('./helpers/projection/isExclusive');\nconst inspect = require('util').inspect;\nconst internalToObjectOptions = require('./options').internalToObjectOptions;\nconst mpath = require('mpath');\nconst utils = require('./utils');\n\nconst ValidationError = MongooseError.ValidationError;\nconst clone = utils.clone;\nconst deepEqual = utils.deepEqual;\nconst isMongooseObject = utils.isMongooseObject;\n\nconst arrayAtomicsSymbol = require('./helpers/symbols').arrayAtomicsSymbol;\nconst documentArrayParent = require('./helpers/symbols').documentArrayParent;\nconst documentSchemaSymbol = require('./helpers/symbols').documentSchemaSymbol;\nconst getSymbol = require('./helpers/symbols').getSymbol;\nconst populateModelSymbol = require('./helpers/symbols').populateModelSymbol;\n\nlet DocumentArray;\nlet MongooseArray;\nlet Embedded;\n\nconst specialProperties = utils.specialProperties;\n\n/**\n * The core Mongoose document constructor. You should not call this directly,\n * the Mongoose [Model constructor](./api.html#Model) calls this for you.\n *\n * @param {Object} obj the values to set\n * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data\n * @param {Boolean} [skipId] bool, should we auto create an ObjectId _id\n * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter\n * @event `init`: Emitted on a document after it has was retreived from the db and fully hydrated by Mongoose.\n * @event `save`: Emitted when the document is successfully saved\n * @api private\n */\n\nfunction Document(obj, fields, skipId, options) {\n  if (typeof skipId === 'object' && skipId != null) {\n    options = skipId;\n    skipId = options.skipId;\n  }\n  options = options || {};\n\n  // Support `browserDocument.js` syntax\n  if (this.schema == null) {\n    const _schema = utils.isObject(fields) && !fields.instanceOfSchema ?\n      new Schema(fields) :\n      fields;\n    this.$__setSchema(_schema);\n    fields = skipId;\n    skipId = options;\n    options = arguments[4] || {};\n  }\n\n  this.$__ = new InternalCache;\n  this.$__.emitter = new EventEmitter();\n  this.isNew = 'isNew' in options ? options.isNew : true;\n  this.errors = undefined;\n  this.$__.$options = options || {};\n\n  if (obj != null && typeof obj !== 'object') {\n    throw new ObjectParameterError(obj, 'obj', 'Document');\n  }\n\n  const schema = this.schema;\n\n  if (typeof fields === 'boolean') {\n    this.$__.strictMode = fields;\n    fields = undefined;\n  } else {\n    this.$__.strictMode = schema.options.strict;\n    this.$__.selected = fields;\n  }\n\n  const required = schema.requiredPaths(true);\n  for (let i = 0; i < required.length; ++i) {\n    this.$__.activePaths.require(required[i]);\n  }\n\n  this.$__.emitter.setMaxListeners(0);\n\n  let exclude = null;\n\n  // determine if this doc is a result of a query with\n  // excluded fields\n  if (utils.isPOJO(fields)) {\n    exclude = isExclusive(fields);\n  }\n\n  const hasIncludedChildren = exclude === false && fields ?\n    $__hasIncludedChildren(fields) :\n    {};\n\n  if (this._doc == null) {\n    this.$__buildDoc(obj, fields, skipId, exclude, hasIncludedChildren, false);\n\n    // By default, defaults get applied **before** setting initial values\n    // Re: gh-6155\n    $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, true, {\n      isNew: this.isNew\n    });\n  }\n\n  if (obj) {\n    if (obj instanceof Document) {\n      this.isNew = obj.isNew;\n    }\n    // Skip set hooks\n    if (this.$__original_set) {\n      this.$__original_set(obj, undefined, true);\n    } else {\n      this.$set(obj, undefined, true);\n    }\n  }\n\n  // Function defaults get applied **after** setting initial values so they\n  // see the full doc rather than an empty one, unless they opt out.\n  // Re: gh-3781, gh-6155\n  if (options.willInit) {\n    EventEmitter.prototype.once.call(this, 'init', () => {\n      $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, false, options.skipDefaults, {\n        isNew: this.isNew\n      });\n    });\n  } else {\n    $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, false, options.skipDefaults, {\n      isNew: this.isNew\n    });\n  }\n\n  this.$__._id = this._id;\n  this.$locals = {};\n\n  if (!schema.options.strict && obj) {\n    const _this = this;\n    const keys = Object.keys(this._doc);\n\n    keys.forEach(function(key) {\n      if (!(key in schema.tree)) {\n        defineKey(key, null, _this);\n      }\n    });\n  }\n\n  applyQueue(this);\n}\n\n/*!\n * Document exposes the NodeJS event emitter API, so you can use\n * `on`, `once`, etc.\n */\nutils.each(\n  ['on', 'once', 'emit', 'listeners', 'removeListener', 'setMaxListeners',\n    'removeAllListeners', 'addListener'],\n  function(emitterFn) {\n    Document.prototype[emitterFn] = function() {\n      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n    };\n  });\n\nDocument.prototype.constructor = Document;\n\nfor (const i in EventEmitter.prototype) {\n  Document[i] = EventEmitter.prototype[i];\n}\n\n/**\n * The documents schema.\n *\n * @api public\n * @property schema\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.schema;\n\n/**\n * Empty object that you can use for storing properties on the document. This\n * is handy for passing data to middleware without conflicting with Mongoose\n * internals.\n *\n * ####Example:\n *\n *     schema.pre('save', function() {\n *       // Mongoose will set `isNew` to `false` if `save()` succeeds\n *       this.$locals.wasNew = this.isNew;\n *     });\n *\n *     schema.post('save', function() {\n *       // Prints true if `isNew` was set before `save()`\n *       console.log(this.$locals.wasNew);\n *     });\n *\n * @api public\n * @property $locals\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, '$locals', {\n  configurable: false,\n  enumerable: false,\n  writable: true\n});\n\n/**\n * Boolean flag specifying if the document is new.\n *\n * @api public\n * @property isNew\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.isNew;\n\n/**\n * The string version of this documents _id.\n *\n * ####Note:\n *\n * This getter exists on all documents by default. The getter can be disabled by setting the `id` [option](/docs/guide.html#id) of its `Schema` to false at construction time.\n *\n *     new Schema({ name: String }, { id: false });\n *\n * @api public\n * @see Schema options /docs/guide.html#options\n * @property id\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.id;\n\n/**\n * Hash containing current validation errors.\n *\n * @api public\n * @property errors\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.errors;\n\n/*!\n * ignore\n */\n\nfunction $__hasIncludedChildren(fields) {\n  const hasIncludedChildren = {};\n  const keys = Object.keys(fields);\n  for (let j = 0; j < keys.length; ++j) {\n    const parts = keys[j].split('.');\n    const c = [];\n    for (let k = 0; k < parts.length; ++k) {\n      c.push(parts[k]);\n      hasIncludedChildren[c.join('.')] = 1;\n    }\n  }\n\n  return hasIncludedChildren;\n}\n\n/*!\n * ignore\n */\n\nfunction $__applyDefaults(doc, fields, skipId, exclude, hasIncludedChildren, isBeforeSetters, pathsToSkip) {\n  const paths = Object.keys(doc.schema.paths);\n  const plen = paths.length;\n\n  for (let i = 0; i < plen; ++i) {\n    let def;\n    let curPath = '';\n    const p = paths[i];\n\n    if (p === '_id' && skipId) {\n      continue;\n    }\n\n    const type = doc.schema.paths[p];\n    const path = p.split('.');\n    const len = path.length;\n    let included = false;\n    let doc_ = doc._doc;\n\n    for (let j = 0; j < len; ++j) {\n      if (doc_ == null) {\n        break;\n      }\n\n      const piece = path[j];\n      curPath += (!curPath.length ? '' : '.') + piece;\n\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (j === len - 1) {\n        if (doc_[piece] !== void 0) {\n          break;\n        }\n\n        if (typeof type.defaultValue === 'function') {\n          if (!type.defaultValue.$runBeforeSetters && isBeforeSetters) {\n            break;\n          }\n          if (type.defaultValue.$runBeforeSetters && !isBeforeSetters) {\n            break;\n          }\n        } else if (!isBeforeSetters) {\n          // Non-function defaults should always run **before** setters\n          continue;\n        }\n\n        if (pathsToSkip && pathsToSkip[curPath]) {\n          break;\n        }\n\n        if (fields && exclude !== null) {\n          if (exclude === true) {\n            // apply defaults to all non-excluded fields\n            if (p in fields) {\n              continue;\n            }\n\n            def = type.getDefault(doc, false);\n            if (typeof def !== 'undefined') {\n              doc_[piece] = def;\n              doc.$__.activePaths.default(p);\n            }\n          } else if (included) {\n            // selected field\n            def = type.getDefault(doc, false);\n            if (typeof def !== 'undefined') {\n              doc_[piece] = def;\n              doc.$__.activePaths.default(p);\n            }\n          }\n        } else {\n          def = type.getDefault(doc, false);\n          if (typeof def !== 'undefined') {\n            doc_[piece] = def;\n            doc.$__.activePaths.default(p);\n          }\n        }\n      } else {\n        doc_ = doc_[piece];\n      }\n    }\n  }\n}\n\n/**\n * Builds the default doc structure\n *\n * @param {Object} obj\n * @param {Object} [fields]\n * @param {Boolean} [skipId]\n * @api private\n * @method $__buildDoc\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__buildDoc = function(obj, fields, skipId, exclude, hasIncludedChildren) {\n  const doc = {};\n\n  const paths = Object.keys(this.schema.paths).\n    // Don't build up any paths that are underneath a map, we don't know\n    // what the keys will be\n    filter(p => !p.includes('$*'));\n  const plen = paths.length;\n  let ii = 0;\n\n  for (; ii < plen; ++ii) {\n    const p = paths[ii];\n\n    if (p === '_id') {\n      if (skipId) {\n        continue;\n      }\n      if (obj && '_id' in obj) {\n        continue;\n      }\n    }\n\n    const path = p.split('.');\n    const len = path.length;\n    const last = len - 1;\n    let curPath = '';\n    let doc_ = doc;\n    let included = false;\n\n    for (let i = 0; i < len; ++i) {\n      const piece = path[i];\n\n      curPath += (!curPath.length ? '' : '.') + piece;\n\n      // support excluding intermediary levels\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (i < last) {\n        doc_ = doc_[piece] || (doc_[piece] = {});\n      }\n    }\n  }\n\n  this._doc = doc;\n};\n\n/*!\n * Converts to POJO when you use the document for querying\n */\n\nDocument.prototype.toBSON = function() {\n  return this.toObject(internalToObjectOptions);\n};\n\n/**\n * Initializes the document without setters or marking anything modified.\n *\n * Called internally after a document is returned from mongodb. Normally,\n * you do **not** need to call this function on your own.\n *\n * This function triggers `init` [middleware](/docs/middleware.html).\n * Note that `init` hooks are [synchronous](/docs/middleware.html#synchronous).\n *\n * @param {Object} doc document returned by mongo\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.init = function(doc, opts, fn) {\n  if (typeof opts === 'function') {\n    fn = opts;\n    opts = null;\n  }\n\n  this.$__init(doc, opts);\n\n  if (fn) {\n    fn(null, this);\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__init = function(doc, opts) {\n  this.isNew = false;\n  this.$init = true;\n  opts = opts || {};\n\n  // handle docs with populated paths\n  // If doc._id is not null or undefined\n  if (doc._id != null && opts.populated && opts.populated.length) {\n    const id = String(doc._id);\n    for (let i = 0; i < opts.populated.length; ++i) {\n      const item = opts.populated[i];\n      if (item.isVirtual) {\n        this.populated(item.path, utils.getValue(item.path, doc), item);\n      } else {\n        this.populated(item.path, item._docs[id], item);\n      }\n    }\n  }\n\n  init(this, doc, this._doc, opts);\n\n  markArraySubdocsPopulated(this, opts.populated);\n\n  this.emit('init', this);\n  this.constructor.emit('init', this);\n\n  this.$__._id = this._id;\n\n  return this;\n};\n\n/*!\n * If populating a path within a document array, make sure each\n * subdoc within the array knows its subpaths are populated.\n *\n * ####Example:\n *     const doc = await Article.findOne().populate('comments.author');\n *     doc.comments[0].populated('author'); // Should be set\n */\n\nfunction markArraySubdocsPopulated(doc, populated) {\n  if (doc._id == null || populated == null || populated.length === 0) {\n    return;\n  }\n\n  const id = String(doc._id);\n  for (const item of populated) {\n    if (item.isVirtual) {\n      continue;\n    }\n    const path = item.path;\n    const pieces = path.split('.');\n    for (let i = 0; i < pieces.length - 1; ++i) {\n      const subpath = pieces.slice(0, i + 1).join('.');\n      const rest = pieces.slice(i + 1).join('.');\n      const val = doc.get(subpath);\n      if (val == null) {\n        continue;\n      }\n      if (val.isMongooseDocumentArray) {\n        for (let j = 0; j < val.length; ++j) {\n          val[j].populated(rest, item._docs[id][j], item);\n        }\n        break;\n      }\n    }\n  }\n}\n\n/*!\n * Init helper.\n *\n * @param {Object} self document instance\n * @param {Object} obj raw mongodb doc\n * @param {Object} doc object we are initializing\n * @api private\n */\n\nfunction init(self, obj, doc, opts, prefix) {\n  prefix = prefix || '';\n\n  const keys = Object.keys(obj);\n  const len = keys.length;\n  let schema;\n  let path;\n  let i;\n  let index = 0;\n\n  while (index < len) {\n    _init(index++);\n  }\n\n  function _init(index) {\n    i = keys[index];\n    path = prefix + i;\n    schema = self.schema.path(path);\n\n    // Should still work if not a model-level discriminator, but should not be\n    // necessary. This is *only* to catch the case where we queried using the\n    // base model and the discriminated model has a projection\n    if (self.schema.$isRootDiscriminator && !self.isSelected(path)) {\n      return;\n    }\n\n    if (!schema && utils.isPOJO(obj[i])) {\n      // assume nested object\n      if (!doc[i]) {\n        doc[i] = {};\n      }\n      init(self, obj[i], doc[i], opts, path + '.');\n    } else if (!schema) {\n      doc[i] = obj[i];\n    } else {\n      if (obj[i] === null) {\n        doc[i] = null;\n      } else if (obj[i] !== undefined) {\n        const intCache = obj[i].$__ || {};\n        const wasPopulated = intCache.wasPopulated || null;\n\n        if (schema && !wasPopulated) {\n          try {\n            doc[i] = schema.cast(obj[i], self, true);\n          } catch (e) {\n            self.invalidate(e.path, new ValidatorError({\n              path: e.path,\n              message: e.message,\n              type: 'cast',\n              value: e.value\n            }));\n          }\n        } else {\n          doc[i] = obj[i];\n        }\n      }\n      // mark as hydrated\n      if (!self.isModified(path)) {\n        self.$__.activePaths.init(path);\n      }\n    }\n  }\n}\n\n/**\n * Sends an update command with this document `_id` as the query selector.\n *\n * ####Example:\n *\n *     weirdCar.update({$inc: {wheels:1}}, { w: 1 }, callback);\n *\n * ####Valid options:\n *\n *  - same as in [Model.update](#model_Model.update)\n *\n * @see Model.update #model_Model.update\n * @param {Object} doc\n * @param {Object} options\n * @param {Function} callback\n * @return {Query}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.update = function update() {\n  const args = utils.args(arguments);\n  args.unshift({_id: this._id});\n  const query = this.constructor.update.apply(this.constructor, args);\n\n  if (this.$session() != null) {\n    if (!('session' in query.options)) {\n      query.options.session = this.$session();\n    }\n  }\n\n  return query;\n};\n\n/**\n * Sends an updateOne command with this document `_id` as the query selector.\n *\n * ####Example:\n *\n *     weirdCar.updateOne({$inc: {wheels:1}}, { w: 1 }, callback);\n *\n * ####Valid options:\n *\n *  - same as in [Model.updateOne](#model_Model.updateOne)\n *\n * @see Model.updateOne #model_Model.updateOne\n * @param {Object} doc\n * @param {Object} options\n * @param {Function} callback\n * @return {Query}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.updateOne = function updateOne(doc, options, callback) {\n  const query = this.constructor.updateOne({_id: this._id}, doc, options);\n  query._pre(cb => {\n    this.constructor._middleware.execPre('updateOne', this, [], cb);\n  });\n  query._post(cb => {\n    this.constructor._middleware.execPost('updateOne', this, [], {}, cb);\n  });\n\n  if (this.$session() != null) {\n    if (!('session' in query.options)) {\n      query.options.session = this.$session();\n    }\n  }\n\n  if (callback != null) {\n    return query.exec(callback);\n  }\n\n  return query;\n};\n\n/**\n * Sends a replaceOne command with this document `_id` as the query selector.\n *\n * ####Valid options:\n *\n *  - same as in [Model.replaceOne](#model_Model.replaceOne)\n *\n * @see Model.replaceOne #model_Model.replaceOne\n * @param {Object} doc\n * @param {Object} options\n * @param {Function} callback\n * @return {Query}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.replaceOne = function replaceOne() {\n  const args = utils.args(arguments);\n  args.unshift({ _id: this._id });\n  return this.constructor.replaceOne.apply(this.constructor, args);\n};\n\n/**\n * Getter/setter around the session associated with this document. Used to\n * automatically set `session` if you `save()` a doc that you got from a\n * query with an associated session.\n *\n * ####Example:\n *\n *     const session = MyModel.startSession();\n *     const doc = await MyModel.findOne().session(session);\n *     doc.$session() === session; // true\n *     doc.$session(null);\n *     doc.$session() === null; // true\n *\n * If this is a top-level document, setting the session propagates to all child\n * docs.\n *\n * @param {ClientSession} [session] overwrite the current session\n * @return {ClientSession}\n * @method $session\n * @api public\n * @memberOf Document\n */\n\nDocument.prototype.$session = function $session(session) {\n  if (arguments.length === 0) {\n    return this.$__.session;\n  }\n  this.$__.session = session;\n\n  if (!this.ownerDocument) {\n    const subdocs = this.$__getAllSubdocs();\n    for (const child of subdocs) {\n      child.$session(session);\n    }\n  }\n\n  return session;\n};\n\n/**\n * Overwrite all values in this document with the values of `obj`, except\n * for immutable properties. Behaves similarly to `set()`, except for it\n * unsets all properties that aren't in `obj`.\n *\n * @param {Object} obj the object to overwrite this document with\n * @method overwrite\n * @name overwrite\n * @memberOf Document\n * @instance\n * @api public\n */\n\nDocument.prototype.overwrite = function overwrite(obj) {\n  const keys = Array.from(new Set(Object.keys(this._doc).concat(Object.keys(obj))));\n\n  for (const key of keys) {\n    if (key === '_id') {\n      continue;\n    }\n    // Explicitly skip version key\n    if (this.schema.options.versionKey && key === this.schema.options.versionKey) {\n      continue;\n    }\n    this.$set(key, obj[key]);\n  }\n\n  return this;\n};\n\n/**\n * Alias for `set()`, used internally to avoid conflicts\n *\n * @param {String|Object} path path or object of key/vals to set\n * @param {Any} val the value to set\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for \"on-the-fly\" attributes\n * @param {Object} [options] optionally specify options that modify the behavior of the set\n * @method $set\n * @name $set\n * @memberOf Document\n * @instance\n * @api public\n */\n\nDocument.prototype.$set = function $set(path, val, type, options) {\n  if (utils.isPOJO(type)) {\n    options = type;\n    type = undefined;\n  }\n\n  options = options || {};\n  const merge = options.merge;\n  const adhoc = type && type !== true;\n  const constructing = type === true;\n  let adhocs;\n  let keys;\n  let i = 0;\n  let pathtype;\n  let key;\n  let prefix;\n\n  const strict = 'strict' in options\n    ? options.strict\n    : this.$__.strictMode;\n\n  if (adhoc) {\n    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n    adhocs[path] = this.schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  if (typeof path !== 'string') {\n    // new Document({ key: val })\n    if (path === null || path === void 0) {\n      const _ = path;\n      path = val;\n      val = _;\n    } else {\n      prefix = val ? val + '.' : '';\n\n      if (path instanceof Document) {\n        if (path.$__isNested) {\n          path = path.toObject();\n        } else {\n          path = path._doc;\n        }\n      }\n\n      keys = Object.keys(path);\n      const len = keys.length;\n\n      if (len === 0 && !this.schema.options.minimize) {\n        if (val) {\n          this.$set(val, {});\n        }\n        return this;\n      }\n\n      while (i < len) {\n        _handleIndex.call(this, i++);\n      }\n\n      return this;\n    }\n  } else {\n    this.$__.$setCalled.add(path);\n  }\n\n  function _handleIndex(i) {\n    key = keys[i];\n    const pathName = prefix + key;\n    pathtype = this.schema.pathType(pathName);\n\n    // On initial set, delete any nested keys if we're going to overwrite\n    // them to ensure we keep the user's key order.\n    if (type === true &&\n        !prefix &&\n        path[key] != null &&\n        pathtype === 'nested' &&\n        this._doc[key] != null &&\n        Object.keys(this._doc[key]).length === 0) {\n      delete this._doc[key];\n    }\n\n    if (typeof path[key] === 'object' &&\n        !utils.isNativeObject(path[key]) &&\n        !utils.isMongooseType(path[key]) &&\n        path[key] != null &&\n        pathtype !== 'virtual' &&\n        pathtype !== 'real' &&\n        !(this.$__path(pathName) instanceof MixedSchema) &&\n        !(this.schema.paths[pathName] &&\n        this.schema.paths[pathName].options &&\n        this.schema.paths[pathName].options.ref)) {\n      this.$__.$setCalled.add(prefix + key);\n      this.$set(path[key], prefix + key, constructing, options);\n    } else if (strict) {\n      // Don't overwrite defaults with undefined keys (gh-3981)\n      if (constructing && path[key] === void 0 &&\n          this.get(key) !== void 0) {\n        return;\n      }\n\n      if (pathtype === 'adhocOrUndefined') {\n        pathtype = getEmbeddedDiscriminatorPath(this, pathName, { typeOnly: true });\n      }\n\n      if (pathtype === 'real' || pathtype === 'virtual') {\n        // Check for setting single embedded schema to document (gh-3535)\n        let p = path[key];\n        if (this.schema.paths[pathName] &&\n            this.schema.paths[pathName].$isSingleNested &&\n            path[key] instanceof Document) {\n          p = p.toObject({ virtuals: false, transform: false });\n        }\n        this.$set(prefix + key, p, constructing, options);\n      } else if (pathtype === 'nested' && path[key] instanceof Document) {\n        this.$set(prefix + key,\n          path[key].toObject({transform: false}), constructing, options);\n      } else if (strict === 'throw') {\n        if (pathtype === 'nested') {\n          throw new ObjectExpectedError(key, path[key]);\n        } else {\n          throw new StrictModeError(key);\n        }\n      }\n    } else if (path[key] !== void 0) {\n      this.$set(prefix + key, path[key], constructing, options);\n    }\n  }\n\n  let pathType = this.schema.pathType(path);\n  if (pathType === 'adhocOrUndefined') {\n    pathType = getEmbeddedDiscriminatorPath(this, path, { typeOnly: true });\n  }\n\n  // Assume this is a Mongoose document that was copied into a POJO using\n  // `Object.assign()` or `{...doc}`\n  if (utils.isPOJO(val) && val.$__ != null && val._doc != null) {\n    val = val._doc;\n  }\n\n  if (pathType === 'nested' && val) {\n    if (typeof val === 'object' && val != null) {\n      if (!merge) {\n        this.$__setValue(path, null);\n        cleanModifiedSubpaths(this, path);\n      } else {\n        return this.$set(val, path, constructing);\n      }\n\n      const keys = Object.keys(val);\n      this.$__setValue(path, {});\n      for (const key of keys) {\n        this.$set(path + '.' + key, val[key], constructing);\n      }\n      this.markModified(path);\n      cleanModifiedSubpaths(this, path, { skipDocArrays: true });\n      return this;\n    }\n    this.invalidate(path, new MongooseError.CastError('Object', val, path));\n    return this;\n  }\n\n  let schema;\n  const parts = path.split('.');\n\n  // Might need to change path for top-level alias\n  if (typeof this.schema.aliases[parts[0]] == 'string') {\n    parts[0] = this.schema.aliases[parts[0]];\n  }\n\n  if (pathType === 'adhocOrUndefined' && strict) {\n    // check for roots that are Mixed types\n    let mixed;\n\n    for (i = 0; i < parts.length; ++i) {\n      const subpath = parts.slice(0, i + 1).join('.');\n\n      // If path is underneath a virtual, bypass everything and just set it.\n      if (i + 1 < parts.length && this.schema.pathType(subpath) === 'virtual') {\n        mpath.set(path, val, this);\n        return this;\n      }\n\n      schema = this.schema.path(subpath);\n      if (schema == null) {\n        continue;\n      }\n\n      if (schema instanceof MixedSchema) {\n        // allow changes to sub paths of mixed types\n        mixed = true;\n        break;\n      }\n    }\n\n    if (schema == null) {\n      // Check for embedded discriminators\n      schema = getEmbeddedDiscriminatorPath(this, path);\n    }\n\n    if (!mixed && !schema) {\n      if (strict === 'throw') {\n        throw new StrictModeError(path);\n      }\n      return this;\n    }\n  } else if (pathType === 'virtual') {\n    schema = this.schema.virtualpath(path);\n    schema.applySetters(val, this);\n    return this;\n  } else {\n    schema = this.$__path(path);\n  }\n\n  // gh-4578, if setting a deeply nested path that doesn't exist yet, create it\n  let cur = this._doc;\n  let curPath = '';\n  for (i = 0; i < parts.length - 1; ++i) {\n    cur = cur[parts[i]];\n    curPath += (curPath.length > 0 ? '.' : '') + parts[i];\n    if (!cur) {\n      this.$set(curPath, {});\n      // Hack re: gh-5800. If nested field is not selected, it probably exists\n      // so `MongoError: cannot use the part (nested of nested.num) to\n      // traverse the element ({nested: null})` is not likely. If user gets\n      // that error, its their fault for now. We should reconsider disallowing\n      // modifying not selected paths for 6.x\n      if (!this.isSelected(curPath)) {\n        this.unmarkModified(curPath);\n      }\n      cur = this.$__getValue(curPath);\n    }\n  }\n\n  let pathToMark;\n\n  // When using the $set operator the path to the field must already exist.\n  // Else mongodb throws: \"LEFT_SUBFIELD only supports Object\"\n\n  if (parts.length <= 1) {\n    pathToMark = path;\n  } else {\n    for (i = 0; i < parts.length; ++i) {\n      const subpath = parts.slice(0, i + 1).join('.');\n      if (this.get(subpath, null, { getters: false }) === null) {\n        pathToMark = subpath;\n        break;\n      }\n    }\n\n    if (!pathToMark) {\n      pathToMark = path;\n    }\n  }\n\n  // if this doc is being constructed we should not trigger getters\n  const priorVal = (() => {\n    if (this.$__.$options.priorDoc != null) {\n      return this.$__.$options.priorDoc.$__getValue(path);\n    }\n    if (constructing) {\n      return void 0;\n    }\n    return this.$__getValue(path);\n  })();\n\n  if (!schema) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n    return this;\n  }\n\n  if (schema.$isSingleNested && val != null && merge) {\n    if (val instanceof Document) {\n      val = val.toObject({ virtuals: false, transform: false });\n    }\n    const keys = Object.keys(val);\n    for (const key of keys) {\n      this.$set(path + '.' + key, val[key], constructing, options);\n    }\n\n    return this;\n  }\n\n  let shouldSet = true;\n  try {\n    // If the user is trying to set a ref path to a document with\n    // the correct model name, treat it as populated\n    const refMatches = (() => {\n      if (schema.options == null) {\n        return false;\n      }\n      if (!(val instanceof Document)) {\n        return false;\n      }\n      const model = val.constructor;\n\n      // Check ref\n      const ref = schema.options.ref;\n      if (ref != null && (ref === model.modelName || ref === model.baseModelName)) {\n        return true;\n      }\n\n      // Check refPath\n      const refPath = schema.options.refPath;\n      if (refPath == null) {\n        return false;\n      }\n      const modelName = val.get(refPath);\n      if (modelName === model.modelName || modelName === model.baseModelName) {\n        return true;\n      }\n      return false;\n    })();\n\n    let didPopulate = false;\n    if (refMatches && val instanceof Document) {\n      this.populated(path, val._id, { [populateModelSymbol]: val.constructor });\n      didPopulate = true;\n    }\n\n    let popOpts;\n    if (schema.options &&\n        Array.isArray(schema.options[this.schema.options.typeKey]) &&\n        schema.options[this.schema.options.typeKey].length &&\n        schema.options[this.schema.options.typeKey][0].ref &&\n        Array.isArray(val) &&\n        val.length > 0 &&\n        val[0] instanceof Document &&\n        val[0].constructor.modelName &&\n        (schema.options[this.schema.options.typeKey][0].ref === val[0].constructor.baseModelName || schema.options[this.schema.options.typeKey][0].ref === val[0].constructor.modelName)) {\n      if (this.ownerDocument) {\n        popOpts = { [populateModelSymbol]: val[0].constructor };\n        this.ownerDocument().populated(this.$__fullPath(path),\n          val.map(function(v) { return v._id; }), popOpts);\n      } else {\n        popOpts = { [populateModelSymbol]: val[0].constructor };\n        this.populated(path, val.map(function(v) { return v._id; }), popOpts);\n      }\n      didPopulate = true;\n    }\n\n    if (this.schema.singleNestedPaths[path] == null) {\n      // If this path is underneath a single nested schema, we'll call the setter\n      // later in `$__set()` because we don't take `_doc` when we iterate through\n      // a single nested doc. That's to make sure we get the correct context.\n      // Otherwise we would double-call the setter, see gh-7196.\n      val = schema.applySetters(val, this, false, priorVal);\n    }\n\n    if (schema.$isMongooseDocumentArray &&\n        Array.isArray(val) &&\n        val.length > 0 &&\n        val[0] != null &&\n        val[0].$__ != null &&\n        val[0].$__.populated != null) {\n      const populatedPaths = Object.keys(val[0].$__.populated);\n      for (const populatedPath of populatedPaths) {\n        this.populated(path + '.' + populatedPath,\n          val.map(v => v.populated(populatedPath)),\n          val[0].$__.populated[populatedPath].options);\n      }\n      didPopulate = true;\n    }\n\n    if (!didPopulate && this.$__.populated) {\n      delete this.$__.populated[path];\n    }\n\n    this.$markValid(path);\n  } catch (e) {\n    if (e instanceof MongooseError.StrictModeError && e.isImmutableError) {\n      this.invalidate(path, e);\n    } else {\n      this.invalidate(path,\n        new MongooseError.CastError(schema.instance, val, path, e));\n    }\n    shouldSet = false;\n  }\n\n  if (shouldSet) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n  }\n\n  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {\n    cleanModifiedSubpaths(this, path);\n  }\n\n  return this;\n};\n\n/**\n * Sets the value of a path, or many paths.\n *\n * ####Example:\n *\n *     // path, value\n *     doc.set(path, value)\n *\n *     // object\n *     doc.set({\n *         path  : value\n *       , path2 : {\n *            path  : value\n *         }\n *     })\n *\n *     // on-the-fly cast to number\n *     doc.set(path, value, Number)\n *\n *     // on-the-fly cast to string\n *     doc.set(path, value, String)\n *\n *     // changing strict mode behavior\n *     doc.set(path, value, { strict: false });\n *\n * @param {String|Object} path path or object of key/vals to set\n * @param {Any} val the value to set\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for \"on-the-fly\" attributes\n * @param {Object} [options] optionally specify options that modify the behavior of the set\n * @api public\n * @method set\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.set = Document.prototype.$set;\n\n/**\n * Determine if we should mark this change as modified.\n *\n * @return {Boolean}\n * @api private\n * @method $__shouldModify\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__shouldModify = function(pathToMark, path, constructing, parts, schema, val, priorVal) {\n  if (this.isNew) {\n    return true;\n  }\n\n  // Re: the note about gh-7196, `val` is the raw value without casting or\n  // setters if the full path is under a single nested subdoc because we don't\n  // want to double run setters. So don't set it as modified. See gh-7264.\n  if (this.schema.singleNestedPaths[path] != null) {\n    return false;\n  }\n\n  if (val === void 0 && !this.isSelected(path)) {\n    // when a path is not selected in a query, its initial\n    // value will be undefined.\n    return true;\n  }\n\n  if (val === void 0 && path in this.$__.activePaths.states.default) {\n    // we're just unsetting the default value which was never saved\n    return false;\n  }\n\n  // gh-3992: if setting a populated field to a doc, don't mark modified\n  // if they have the same _id\n  if (this.populated(path) &&\n      val instanceof Document &&\n      deepEqual(val._id, priorVal)) {\n    return false;\n  }\n\n  if (!deepEqual(val, priorVal || this.get(path))) {\n    return true;\n  }\n\n  if (!constructing &&\n      val !== null &&\n      val !== undefined &&\n      path in this.$__.activePaths.states.default &&\n      deepEqual(val, schema.getDefault(this, constructing))) {\n    // a path with a default was $unset on the server\n    // and the user is setting it to the same value again\n    return true;\n  }\n  return false;\n};\n\n/**\n * Handles the actual setting of the value and marking the path modified if appropriate.\n *\n * @api private\n * @method $__set\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__set = function(pathToMark, path, constructing, parts, schema, val, priorVal) {\n  Embedded = Embedded || require('./types/embedded');\n\n  const shouldModify = this.$__shouldModify(pathToMark, path, constructing, parts,\n    schema, val, priorVal);\n  const _this = this;\n\n  if (shouldModify) {\n    this.markModified(pathToMark);\n\n    // handle directly setting arrays (gh-1126)\n    MongooseArray || (MongooseArray = require('./types/array'));\n    if (val && val.isMongooseArray) {\n      val._registerAtomic('$set', val);\n\n      // Update embedded document parent references (gh-5189)\n      if (val.isMongooseDocumentArray) {\n        val.forEach(function(item) {\n          item && item.__parentArray && (item.__parentArray = val);\n        });\n      }\n\n      // Small hack for gh-1638: if we're overwriting the entire array, ignore\n      // paths that were modified before the array overwrite\n      this.$__.activePaths.forEach(function(modifiedPath) {\n        if (modifiedPath.startsWith(path + '.')) {\n          _this.$__.activePaths.ignore(modifiedPath);\n        }\n      });\n    }\n  }\n\n  let obj = this._doc;\n  let i = 0;\n  const l = parts.length;\n  let cur = '';\n\n  for (; i < l; i++) {\n    const next = i + 1;\n    const last = next === l;\n    cur += (cur ? '.' + parts[i] : parts[i]);\n    if (specialProperties.has(parts[i])) {\n      return;\n    }\n\n    if (last) {\n      if (obj instanceof Map) {\n        obj.set(parts[i], val);\n      } else {\n        obj[parts[i]] = val;\n      }\n    } else {\n      if (utils.isPOJO(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]].$isSingleNested) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else {\n        obj[parts[i]] = obj[parts[i]] || {};\n        obj = obj[parts[i]];\n      }\n    }\n  }\n};\n\n/**\n * Gets a raw value from a path (no getters)\n *\n * @param {String} path\n * @api private\n */\n\nDocument.prototype.$__getValue = function(path) {\n  return utils.getValue(path, this._doc);\n};\n\n/**\n * Sets a raw value for a path (no casting, setters, transformations)\n *\n * @param {String} path\n * @param {Object} value\n * @api private\n */\n\nDocument.prototype.$__setValue = function(path, val) {\n  utils.setValue(path, val, this._doc);\n  return this;\n};\n\n/**\n * Returns the value of a path.\n *\n * ####Example\n *\n *     // path\n *     doc.get('age') // 47\n *\n *     // dynamic casting to a string\n *     doc.get('age', String) // \"47\"\n *\n * @param {String} path\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for on-the-fly attributes\n * @param {Object} [options]\n * @param {Boolean} [options.virtuals=false] Apply virtuals before getting this path\n * @param {Boolean} [options.getters=true] If false, skip applying getters and just get the raw value\n * @api public\n */\n\nDocument.prototype.get = function(path, type, options) {\n  let adhoc;\n  options = options || {};\n  if (type) {\n    adhoc = this.schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  let schema = this.$__path(path);\n  if (schema == null) {\n    schema = this.schema.virtualpath(path);\n  }\n  if (schema instanceof MixedSchema) {\n    const virtual = this.schema.virtualpath(path);\n    if (virtual != null) {\n      schema = virtual;\n    }\n  }\n  const pieces = path.split('.');\n  let obj = this._doc;\n\n  if (schema instanceof VirtualType) {\n    if (schema.getters.length === 0) {\n      return void 0;\n    }\n    return schema.applyGetters(null, this);\n  }\n\n  // Might need to change path for top-level alias\n  if (typeof this.schema.aliases[pieces[0]] == 'string') {\n    pieces[0] = this.schema.aliases[pieces[0]];\n  }\n\n  for (let i = 0, l = pieces.length; i < l; i++) {\n    if (obj && obj._doc) {\n      obj = obj._doc;\n    }\n\n    if (obj == null) {\n      obj = void 0;\n    } else if (obj instanceof Map) {\n      obj = obj.get(pieces[i]);\n    } else if (i === l - 1) {\n      obj = utils.getValue(pieces[i], obj);\n    } else {\n      obj = obj[pieces[i]];\n    }\n  }\n\n  if (adhoc) {\n    obj = adhoc.cast(obj);\n  }\n\n  if (schema != null && options.getters !== false) {\n    obj = schema.applyGetters(obj, this);\n  } else if (this.schema.nested[path] && options.virtuals) {\n    // Might need to apply virtuals if this is a nested path\n    return applyVirtuals(this, utils.clone(obj) || {}, { path: path });\n  }\n\n  return obj;\n};\n\n/*!\n * ignore\n */\n\nDocument.prototype[getSymbol] = Document.prototype.get;\n\n/**\n * Returns the schematype for the given `path`.\n *\n * @param {String} path\n * @api private\n * @method $__path\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__path = function(path) {\n  const adhocs = this.$__.adhocPaths;\n  const adhocType = adhocs && adhocs.hasOwnProperty(path) ? adhocs[path] : null;\n\n  if (adhocType) {\n    return adhocType;\n  }\n  return this.schema.path(path);\n};\n\n/**\n * Marks the path as having pending changes to write to the db.\n *\n * _Very helpful when using [Mixed](./schematypes.html#mixed) types._\n *\n * ####Example:\n *\n *     doc.mixed.type = 'changed';\n *     doc.markModified('mixed.type');\n *     doc.save() // changes to mixed.type are now persisted\n *\n * @param {String} path the path to mark modified\n * @param {Document} [scope] the scope to run validators with\n * @api public\n */\n\nDocument.prototype.markModified = function(path, scope) {\n  this.$__.activePaths.modify(path);\n  if (scope != null && !this.ownerDocument) {\n    this.$__.pathsToScopes[path] = scope;\n  }\n};\n\n/**\n * Clears the modified state on the specified path.\n *\n * ####Example:\n *\n *     doc.foo = 'bar';\n *     doc.unmarkModified('foo');\n *     doc.save(); // changes to foo will not be persisted\n *\n * @param {String} path the path to unmark modified\n * @api public\n */\n\nDocument.prototype.unmarkModified = function(path) {\n  this.$__.activePaths.init(path);\n  delete this.$__.pathsToScopes[path];\n};\n\n/**\n * Don't run validation on this path or persist changes to this path.\n *\n * ####Example:\n *\n *     doc.foo = null;\n *     doc.$ignore('foo');\n *     doc.save(); // changes to foo will not be persisted and validators won't be run\n *\n * @memberOf Document\n * @instance\n * @method $ignore\n * @param {String} path the path to ignore\n * @api public\n */\n\nDocument.prototype.$ignore = function(path) {\n  this.$__.activePaths.ignore(path);\n};\n\n/**\n * Returns the list of paths that have been directly modified. A direct\n * modified path is a path that you explicitly set, whether via `doc.foo = 'bar'`,\n * `Object.assign(doc, { foo: 'bar' })`, or `doc.set('foo', 'bar')`.\n *\n * A path `a` may be in `modifiedPaths()` but not in `directModifiedPaths()`\n * because a child of `a` was directly modified.\n *\n * ####Example\n *     const schema = new Schema({ foo: String, nested: { bar: String } });\n *     const Model = mongoose.model('Test', schema);\n *     await Model.create({ foo: 'original', nested: { bar: 'original' } });\n *\n *     const doc = await Model.findOne();\n *     doc.nested.bar = 'modified';\n *     doc.directModifiedPaths(); // ['nested.bar']\n *     doc.modifiedPaths(); // ['nested', 'nested.bar']\n *\n * @return {Array}\n * @api public\n */\n\nDocument.prototype.directModifiedPaths = function() {\n  return Object.keys(this.$__.activePaths.states.modify);\n};\n\n/**\n * Returns true if the given path is nullish or only contains empty objects.\n * Useful for determining whether this subdoc will get stripped out by the\n * [minimize option](/docs/guide.html#minimize).\n *\n * ####Example:\n *     const schema = new Schema({ nested: { foo: String } });\n *     const Model = mongoose.model('Test', schema);\n *     const doc = new Model({});\n *     doc.$isEmpty('nested'); // true\n *     doc.nested.$isEmpty(); // true\n *\n *     doc.nested.foo = 'bar';\n *     doc.$isEmpty('nested'); // false\n *     doc.nested.$isEmpty(); // false\n *\n * @memberOf Document\n * @instance\n * @api public\n * @method $isEmpty\n * @return {Boolean}\n */\n\nDocument.prototype.$isEmpty = function(path) {\n  const isEmptyOptions = {\n    minimize: true,\n    virtuals: false,\n    getters: false,\n    transform: false\n  };\n\n  if (arguments.length > 0) {\n    const v = this.get(path);\n    if (v == null) {\n      return true;\n    }\n    if (typeof v !== 'object') {\n      return false;\n    }\n    if (utils.isPOJO(v)) {\n      return _isEmpty(v);\n    }\n    return Object.keys(v.toObject(isEmptyOptions)).length === 0;\n  }\n\n  return Object.keys(this.toObject(isEmptyOptions)).length === 0;\n};\n\nfunction _isEmpty(v) {\n  if (v == null) {\n    return true;\n  }\n  if (typeof v !== 'object' || Array.isArray(v)) {\n    return false;\n  }\n  for (const key of Object.keys(v)) {\n    if (!_isEmpty(v[key])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Returns the list of paths that have been modified.\n *\n * @param {Object} [options]\n * @param {Boolean} [options.includeChildren=false] if true, returns children of modified paths as well. For example, if false, the list of modified paths for `doc.colors = { primary: 'blue' };` will **not** contain `colors.primary`. If true, `modifiedPaths()` will return an array that contains `colors.primary`.\n * @return {Array}\n * @api public\n */\n\nDocument.prototype.modifiedPaths = function(options) {\n  options = options || {};\n  const directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n  const _this = this;\n  return directModifiedPaths.reduce(function(list, path) {\n    const parts = path.split('.');\n    list = list.concat(parts.reduce(function(chains, part, i) {\n      return chains.concat(parts.slice(0, i).concat(part).join('.'));\n    }, []).filter(function(chain) {\n      return (list.indexOf(chain) === -1);\n    }));\n\n    if (!options.includeChildren) {\n      return list;\n    }\n\n    let cur = _this.get(path);\n    if (cur != null && typeof cur === 'object') {\n      if (cur._doc) {\n        cur = cur._doc;\n      }\n      if (Array.isArray(cur)) {\n        const len = cur.length;\n        for (let i = 0; i < len; ++i) {\n          if (list.indexOf(path + '.' + i) === -1) {\n            list.push(path + '.' + i);\n            if (cur[i] != null && cur[i].$__) {\n              const modified = cur[i].modifiedPaths();\n              for (const childPath of modified) {\n                list.push(path + '.' + i + '.' + childPath);\n              }\n            }\n          }\n        }\n      } else {\n        Object.keys(cur).\n          filter(function(key) {\n            return list.indexOf(path + '.' + key) === -1;\n          }).\n          forEach(function(key) {\n            list.push(path + '.' + key);\n          });\n      }\n    }\n\n    return list;\n  }, []);\n};\n\n/**\n * Returns true if this document was modified, else false.\n *\n * If `path` is given, checks if a path or any full path containing `path` as part of its path chain has been modified.\n *\n * ####Example\n *\n *     doc.set('documents.0.title', 'changed');\n *     doc.isModified()                      // true\n *     doc.isModified('documents')           // true\n *     doc.isModified('documents.0.title')   // true\n *     doc.isModified('documents otherProp') // true\n *     doc.isDirectModified('documents')     // false\n *\n * @param {String} [path] optional\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isModified = function(paths, modifiedPaths) {\n  if (paths) {\n    if (!Array.isArray(paths)) {\n      paths = paths.split(' ');\n    }\n    const modified = modifiedPaths || this.modifiedPaths();\n    const directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n    const isModifiedChild = paths.some(function(path) {\n      return !!~modified.indexOf(path);\n    });\n    return isModifiedChild || paths.some(function(path) {\n      return directModifiedPaths.some(function(mod) {\n        return mod === path || path.startsWith(mod + '.');\n      });\n    });\n  }\n  return this.$__.activePaths.some('modify');\n};\n\n/**\n * Checks if a path is set to its default.\n *\n * ####Example\n *\n *     MyModel = mongoose.model('test', { name: { type: String, default: 'Val '} });\n *     var m = new MyModel();\n *     m.$isDefault('name'); // true\n *\n * @memberOf Document\n * @instance\n * @method $isDefault\n * @param {String} [path]\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.$isDefault = function(path) {\n  return (path in this.$__.activePaths.states.default);\n};\n\n/**\n * Getter/setter, determines whether the document was removed or not.\n *\n * ####Example:\n *     product.remove(function (err, product) {\n *       product.$isDeleted(); // true\n *       product.remove(); // no-op, doesn't send anything to the db\n *\n *       product.$isDeleted(false);\n *       product.$isDeleted(); // false\n *       product.remove(); // will execute a remove against the db\n *     })\n *\n * @param {Boolean} [val] optional, overrides whether mongoose thinks the doc is deleted\n * @return {Boolean} whether mongoose thinks this doc is deleted.\n * @method $isDeleted\n * @memberOf Document\n * @instance\n * @api public\n */\n\nDocument.prototype.$isDeleted = function(val) {\n  if (arguments.length === 0) {\n    return !!this.$__.isDeleted;\n  }\n\n  this.$__.isDeleted = !!val;\n  return this;\n};\n\n/**\n * Returns true if `path` was directly set and modified, else false.\n *\n * ####Example\n *\n *     doc.set('documents.0.title', 'changed');\n *     doc.isDirectModified('documents.0.title') // true\n *     doc.isDirectModified('documents') // false\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isDirectModified = function(path) {\n  return (path in this.$__.activePaths.states.modify);\n};\n\n/**\n * Checks if `path` was initialized.\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isInit = function(path) {\n  return (path in this.$__.activePaths.states.init);\n};\n\n/**\n * Checks if `path` was selected in the source query which initialized this document.\n *\n * ####Example\n *\n *     Thing.findOne().select('name').exec(function (err, doc) {\n *        doc.isSelected('name') // true\n *        doc.isSelected('age')  // false\n *     })\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isSelected = function isSelected(path) {\n  if (this.$__.selected) {\n    if (path === '_id') {\n      return this.$__.selected._id !== 0;\n    }\n\n    const paths = Object.keys(this.$__.selected);\n    let i = paths.length;\n    let inclusive = null;\n    let cur;\n\n    if (i === 1 && paths[0] === '_id') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === '_id') {\n        continue;\n      }\n      if (!isDefiningProjection(this.$__.selected[cur])) {\n        continue;\n      }\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    i = paths.length;\n    const pathDot = path + '.';\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === '_id') {\n        continue;\n      }\n\n      if (cur.startsWith(pathDot)) {\n        return inclusive || cur !== pathDot;\n      }\n\n      if (pathDot.startsWith(cur + '.')) {\n        return inclusive;\n      }\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n};\n\n/**\n * Checks if `path` was explicitly selected. If no projection, always returns\n * true.\n *\n * ####Example\n *\n *     Thing.findOne().select('nested.name').exec(function (err, doc) {\n *        doc.isDirectSelected('nested.name') // true\n *        doc.isDirectSelected('nested.otherName') // false\n *        doc.isDirectSelected('nested')  // false\n *     })\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isDirectSelected = function isDirectSelected(path) {\n  if (this.$__.selected) {\n    if (path === '_id') {\n      return this.$__.selected._id !== 0;\n    }\n\n    const paths = Object.keys(this.$__.selected);\n    let i = paths.length;\n    let inclusive = null;\n    let cur;\n\n    if (i === 1 && paths[0] === '_id') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === '_id') {\n        continue;\n      }\n      if (!isDefiningProjection(this.$__.selected[cur])) {\n        continue;\n      }\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n};\n\n/**\n * Executes registered validation rules for this document.\n *\n * ####Note:\n *\n * This method is called `pre` save and if a validation rule is violated, [save](#model_Model-save) is aborted and the error is returned to your `callback`.\n *\n * ####Example:\n *\n *     doc.validate(function (err) {\n *       if (err) handleError(err);\n *       else // validation passed\n *     });\n *\n * @param {Object} optional options internal options\n * @param {Function} callback optional callback called after validation completes, passing an error if one occurred\n * @return {Promise} Promise\n * @api public\n */\n\nDocument.prototype.validate = function(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n\n  return utils.promiseOrCallback(callback, cb => {\n    this.$__validate(options, function(error) {\n      cb(error);\n    });\n  }, this.constructor.events);\n};\n\n/*!\n * ignore\n */\n\nfunction _evaluateRequiredFunctions(doc) {\n  Object.keys(doc.$__.activePaths.states.require).forEach(path => {\n    const p = doc.schema.path(path);\n\n    if (p != null && typeof p.originalRequiredValue === 'function') {\n      doc.$__.cachedRequired[path] = p.originalRequiredValue.call(doc);\n    }\n  });\n}\n\n/*!\n * ignore\n */\n\nfunction _getPathsToValidate(doc) {\n  let i;\n  let len;\n  const skipSchemaValidators = {};\n\n  _evaluateRequiredFunctions(doc);\n\n  // only validate required fields when necessary\n  let paths = Object.keys(doc.$__.activePaths.states.require).filter(function(path) {\n    if (!doc.isSelected(path) && !doc.isModified(path)) {\n      return false;\n    }\n    if (path in doc.$__.cachedRequired) {\n      return doc.$__.cachedRequired[path];\n    }\n    return true;\n  });\n\n  paths = paths.concat(Object.keys(doc.$__.activePaths.states.init));\n  paths = paths.concat(Object.keys(doc.$__.activePaths.states.modify));\n  paths = paths.concat(Object.keys(doc.$__.activePaths.states.default));\n\n  if (!doc.ownerDocument) {\n    const subdocs = doc.$__getAllSubdocs();\n    let subdoc;\n    len = subdocs.length;\n    const modifiedPaths = doc.modifiedPaths();\n    for (i = 0; i < len; ++i) {\n      subdoc = subdocs[i];\n      if (doc.isModified(subdoc.$basePath, modifiedPaths) &&\n          !doc.isDirectModified(subdoc.$basePath) &&\n          !doc.$isDefault(subdoc.$basePath)) {\n        // Remove child paths for now, because we'll be validating the whole\n        // subdoc\n        paths = paths.filter(function(p) {\n          return p != null && p.indexOf(subdoc.$basePath + '.') !== 0;\n        });\n        paths.push(subdoc.$basePath);\n        skipSchemaValidators[subdoc.$basePath] = true;\n      }\n    }\n  }\n\n  // gh-661: if a whole array is modified, make sure to run validation on all\n  // the children as well\n  len = paths.length;\n  for (i = 0; i < len; ++i) {\n    const path = paths[i];\n\n    const _pathType = doc.schema.path(path);\n    if (!_pathType ||\n        !_pathType.$isMongooseArray ||\n        // To avoid potential performance issues, skip doc arrays whose children\n        // are not required. `getPositionalPathType()` may be slow, so avoid\n        // it unless we have a case of #6364\n        (_pathType.$isMongooseDocumentArray && !get(_pathType, 'schemaOptions.required'))) {\n      continue;\n    }\n\n    const val = doc.$__getValue(path);\n    _pushNestedArrayPaths(val, paths, path);\n  }\n\n  function _pushNestedArrayPaths(val, paths, path) {\n    if (val != null) {\n      const numElements = val.length;\n      for (let j = 0; j < numElements; ++j) {\n        if (Array.isArray(val[j])) {\n          _pushNestedArrayPaths(val[j], paths, path + '.' + j);\n        } else {\n          paths.push(path + '.' + j);\n        }\n      }\n    }\n  }\n\n  const flattenOptions = { skipArrays: true };\n  len = paths.length;\n  for (i = 0; i < len; ++i) {\n    const pathToCheck = paths[i];\n    if (doc.schema.nested[pathToCheck]) {\n      let _v = doc.$__getValue(pathToCheck);\n      if (isMongooseObject(_v)) {\n        _v = _v.toObject({ transform: false });\n      }\n      const flat = flatten(_v, pathToCheck, flattenOptions, doc.schema);\n      paths = paths.concat(Object.keys(flat));\n    }\n  }\n\n  len = paths.length;\n  for (i = 0; i < len; ++i) {\n    const path = paths[i];\n    const _pathType = doc.schema.path(path);\n    if (!_pathType || !_pathType.$isSchemaMap) {\n      continue;\n    }\n\n    const val = doc.$__getValue(path);\n    if (val == null) {\n      continue;\n    }\n    for (const key of val.keys()) {\n      paths.push(path + '.' + key);\n    }\n  }\n\n  return [paths, skipSchemaValidators];\n}\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__validate = function(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n\n  const hasValidateModifiedOnlyOption = options &&\n      (typeof options === 'object') &&\n      ('validateModifiedOnly' in options);\n\n  let shouldValidateModifiedOnly;\n  if (hasValidateModifiedOnlyOption) {\n    shouldValidateModifiedOnly = !!options.validateModifiedOnly;\n  } else {\n    shouldValidateModifiedOnly = this.schema.options.validateModifiedOnly;\n  }\n\n  const _this = this;\n  const _complete = () => {\n    let err = this.$__.validationError;\n    this.$__.validationError = undefined;\n\n    if (shouldValidateModifiedOnly && err != null) {\n      // Remove any validation errors that aren't from modified paths\n      const errors = Object.keys(err.errors);\n      for (const errPath of errors) {\n        if (!this.isModified(errPath)) {\n          delete err.errors[errPath];\n        }\n      }\n      if (Object.keys(err.errors).length === 0) {\n        err = void 0;\n      }\n    }\n\n    this.$__.cachedRequired = {};\n    this.emit('validate', _this);\n    this.constructor.emit('validate', _this);\n    if (err) {\n      for (const key in err.errors) {\n        // Make sure cast errors persist\n        if (!this[documentArrayParent] && err.errors[key] instanceof MongooseError.CastError) {\n          this.invalidate(key, err.errors[key]);\n        }\n      }\n\n      return err;\n    }\n  };\n\n  // only validate required fields when necessary\n  const pathDetails = _getPathsToValidate(this);\n  const paths = shouldValidateModifiedOnly ?\n    pathDetails[0].filter((path) => this.isModified(path)) :\n    pathDetails[0];\n  const skipSchemaValidators = pathDetails[1];\n\n  if (paths.length === 0) {\n    return process.nextTick(function() {\n      const error = _complete();\n      if (error) {\n        return _this.schema.s.hooks.execPost('validate:error', _this, [ _this], { error: error }, function(error) {\n          callback(error);\n        });\n      }\n      callback(null, _this);\n    });\n  }\n\n  const validated = {};\n  let total = 0;\n\n  const complete = function() {\n    const error = _complete();\n    if (error) {\n      return _this.schema.s.hooks.execPost('validate:error', _this, [ _this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n    callback(null, _this);\n  };\n\n  const validatePath = function(path) {\n    if (path == null || validated[path]) {\n      return;\n    }\n\n    validated[path] = true;\n    total++;\n\n    process.nextTick(function() {\n      const p = _this.schema.path(path);\n\n      if (!p) {\n        return --total || complete();\n      }\n\n      // If user marked as invalid or there was a cast error, don't validate\n      if (!_this.$isValid(path)) {\n        --total || complete();\n        return;\n      }\n\n      let val = _this.$__getValue(path);\n\n      // If you `populate()` and get back a null value, required validators\n      // shouldn't fail (gh-8018). We should always fall back to the populated\n      // value.\n      let pop;\n      if (val == null && (pop = _this.populated(path))) {\n        val = pop;\n      }\n      const scope = path in _this.$__.pathsToScopes ?\n        _this.$__.pathsToScopes[path] :\n        _this;\n\n      p.doValidate(val, function(err) {\n        if (err && (!p.$isMongooseDocumentArray || err.$isArrayValidatorError)) {\n          if (p.$isSingleNested &&\n              err.name === 'ValidationError' &&\n              p.schema.options.storeSubdocValidationError === false) {\n            return --total || complete();\n          }\n          _this.invalidate(path, err, undefined, true);\n        }\n        --total || complete();\n      }, scope, { skipSchemaValidators: skipSchemaValidators[path], path: path });\n    });\n  };\n\n  const numPaths = paths.length;\n  for (let i = 0; i < numPaths; ++i) {\n    validatePath(paths[i]);\n  }\n};\n\n/**\n * Executes registered validation rules (skipping asynchronous validators) for this document.\n *\n * ####Note:\n *\n * This method is useful if you need synchronous validation.\n *\n * ####Example:\n *\n *     var err = doc.validateSync();\n *     if ( err ){\n *       handleError( err );\n *     } else {\n *       // validation passed\n *     }\n *\n * @param {Array|string} pathsToValidate only validate the given paths\n * @return {ValidationError|undefined} ValidationError if there are errors during validation, or undefined if there is no error.\n * @api public\n */\n\nDocument.prototype.validateSync = function(pathsToValidate, options) {\n  const _this = this;\n\n  const hasValidateModifiedOnlyOption = options &&\n      (typeof options === 'object') &&\n      ('validateModifiedOnly' in options);\n\n  let shouldValidateModifiedOnly;\n  if (hasValidateModifiedOnlyOption) {\n    shouldValidateModifiedOnly = !!options.validateModifiedOnly;\n  } else {\n    shouldValidateModifiedOnly = this.schema.options.validateModifiedOnly;\n  }\n\n  if (typeof pathsToValidate === 'string') {\n    pathsToValidate = pathsToValidate.split(' ');\n  }\n\n  // only validate required fields when necessary\n  const pathDetails = _getPathsToValidate(this);\n  let paths = shouldValidateModifiedOnly ?\n    pathDetails[0].filter((path) => this.isModified(path)) :\n    pathDetails[0];\n  const skipSchemaValidators = pathDetails[1];\n\n  if (pathsToValidate && pathsToValidate.length) {\n    const tmp = [];\n    for (let i = 0; i < paths.length; ++i) {\n      if (pathsToValidate.indexOf(paths[i]) !== -1) {\n        tmp.push(paths[i]);\n      }\n    }\n    paths = tmp;\n  }\n\n  const validating = {};\n\n  paths.forEach(function(path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n\n    const p = _this.schema.path(path);\n    if (!p) {\n      return;\n    }\n    if (!_this.$isValid(path)) {\n      return;\n    }\n\n    const val = _this.$__getValue(path);\n    const err = p.doValidateSync(val, _this, {\n      skipSchemaValidators: skipSchemaValidators[path],\n      path: path\n    });\n    if (err && (!p.$isMongooseDocumentArray || err.$isArrayValidatorError)) {\n      if (p.$isSingleNested &&\n          err.name === 'ValidationError' &&\n          p.schema.options.storeSubdocValidationError === false) {\n        return;\n      }\n      _this.invalidate(path, err, undefined, true);\n    }\n  });\n\n  const err = _this.$__.validationError;\n  _this.$__.validationError = undefined;\n  _this.emit('validate', _this);\n  _this.constructor.emit('validate', _this);\n\n  if (err) {\n    for (const key in err.errors) {\n      // Make sure cast errors persist\n      if (err.errors[key] instanceof MongooseError.CastError) {\n        _this.invalidate(key, err.errors[key]);\n      }\n    }\n  }\n\n  return err;\n};\n\n/**\n * Marks a path as invalid, causing validation to fail.\n *\n * The `errorMsg` argument will become the message of the `ValidationError`.\n *\n * The `value` argument (if passed) will be available through the `ValidationError.value` property.\n *\n *     doc.invalidate('size', 'must be less than 20', 14);\n\n *     doc.validate(function (err) {\n *       console.log(err)\n *       // prints\n *       { message: 'Validation failed',\n *         name: 'ValidationError',\n *         errors:\n *          { size:\n *             { message: 'must be less than 20',\n *               name: 'ValidatorError',\n *               path: 'size',\n *               type: 'user defined',\n *               value: 14 } } }\n *     })\n *\n * @param {String} path the field to invalidate\n * @param {String|Error} errorMsg the error which states the reason `path` was invalid\n * @param {Object|String|Number|any} value optional invalid value\n * @param {String} [kind] optional `kind` property for the error\n * @return {ValidationError} the current ValidationError, with all currently invalidated paths\n * @api public\n */\n\nDocument.prototype.invalidate = function(path, err, val, kind) {\n  if (!this.$__.validationError) {\n    this.$__.validationError = new ValidationError(this);\n  }\n\n  if (this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  if (!err || typeof err === 'string') {\n    err = new ValidatorError({\n      path: path,\n      message: err,\n      type: kind || 'user defined',\n      value: val\n    });\n  }\n\n  if (this.$__.validationError === err) {\n    return this.$__.validationError;\n  }\n\n  this.$__.validationError.addError(path, err);\n  return this.$__.validationError;\n};\n\n/**\n * Marks a path as valid, removing existing validation errors.\n *\n * @param {String} path the field to mark as valid\n * @api public\n * @memberOf Document\n * @instance\n * @method $markValid\n */\n\nDocument.prototype.$markValid = function(path) {\n  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  delete this.$__.validationError.errors[path];\n  if (Object.keys(this.$__.validationError.errors).length === 0) {\n    this.$__.validationError = null;\n  }\n};\n\n/**\n * Saves this document.\n *\n * ####Example:\n *\n *     product.sold = Date.now();\n *     product.save(function (err, product) {\n *       if (err) ..\n *     })\n *\n * The callback will receive two parameters\n *\n * 1. `err` if an error occurred\n * 2. `product` which is the saved `product`\n *\n * As an extra measure of flow control, save will return a Promise.\n * ####Example:\n *     product.save().then(function(product) {\n *        ...\n *     });\n *\n * @param {Object} [options] options optional options\n * @param {Object} [options.safe] (DEPRECATED) overrides [schema's safe option](http://mongoosejs.com//docs/guide.html#safe)\n * @param {Boolean} [options.validateBeforeSave] set to false to save without validating.\n * @param {Function} [fn] optional callback\n * @method save\n * @memberOf Document\n * @instance\n * @return {Promise|undefined} Returns undefined if used with callback or a Promise otherwise.\n * @api public\n * @see middleware http://mongoosejs.com/docs/middleware.html\n */\n\n/**\n * Checks if a path is invalid\n *\n * @param {String} path the field to check\n * @method $isValid\n * @memberOf Document\n * @instance\n * @api private\n */\n\nDocument.prototype.$isValid = function(path) {\n  return !this.$__.validationError || !this.$__.validationError.errors[path];\n};\n\n/**\n * Resets the internal modified state of this document.\n *\n * @api private\n * @return {Document}\n * @method $__reset\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__reset = function reset() {\n  let _this = this;\n  DocumentArray || (DocumentArray = require('./types/documentarray'));\n\n  this.$__.activePaths\n    .map('init', 'modify', function(i) {\n      return _this.$__getValue(i);\n    })\n    .filter(function(val) {\n      return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n    })\n    .forEach(function(array) {\n      let i = array.length;\n      while (i--) {\n        const doc = array[i];\n        if (!doc) {\n          continue;\n        }\n        doc.$__reset();\n      }\n\n      _this.$__.activePaths.init(array.$path());\n\n      array[arrayAtomicsSymbol] = {};\n    });\n\n  this.$__.activePaths.\n    map('init', 'modify', function(i) {\n      return _this.$__getValue(i);\n    }).\n    filter(function(val) {\n      return val && val.$isSingleNested;\n    }).\n    forEach(function(doc) {\n      doc.$__reset();\n      _this.$__.activePaths.init(doc.$basePath);\n    });\n\n  // clear atomics\n  this.$__dirty().forEach(function(dirt) {\n    const type = dirt.value;\n\n    if (type && type[arrayAtomicsSymbol]) {\n      type[arrayAtomicsSymbol] = {};\n    }\n  });\n\n  // Clear 'dirty' cache\n  this.$__.activePaths.clear('modify');\n  this.$__.activePaths.clear('default');\n  this.$__.validationError = undefined;\n  this.errors = undefined;\n  _this = this;\n  this.schema.requiredPaths().forEach(function(path) {\n    _this.$__.activePaths.require(path);\n  });\n\n  return this;\n};\n\n/**\n * Returns this documents dirty paths / vals.\n *\n * @api private\n * @method $__dirty\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__dirty = function() {\n  const _this = this;\n\n  let all = this.$__.activePaths.map('modify', function(path) {\n    return {\n      path: path,\n      value: _this.$__getValue(path),\n      schema: _this.$__path(path)\n    };\n  });\n\n  // gh-2558: if we had to set a default and the value is not undefined,\n  // we have to save as well\n  all = all.concat(this.$__.activePaths.map('default', function(path) {\n    if (path === '_id' || _this.$__getValue(path) == null) {\n      return;\n    }\n    return {\n      path: path,\n      value: _this.$__getValue(path),\n      schema: _this.$__path(path)\n    };\n  }));\n\n  // Sort dirty paths in a flat hierarchy.\n  all.sort(function(a, b) {\n    return (a.path < b.path ? -1 : (a.path > b.path ? 1 : 0));\n  });\n\n  // Ignore \"foo.a\" if \"foo\" is dirty already.\n  const minimal = [];\n  let lastPath;\n  let top;\n\n  all.forEach(function(item) {\n    if (!item) {\n      return;\n    }\n    if (lastPath == null || item.path.indexOf(lastPath) !== 0) {\n      lastPath = item.path + '.';\n      minimal.push(item);\n      top = item;\n    } else if (top != null &&\n        top.value != null &&\n        top.value[arrayAtomicsSymbol] != null &&\n        top.value.hasAtomics()) {\n      // special case for top level MongooseArrays\n      // the `top` array itself and a sub path of `top` are being modified.\n      // the only way to honor all of both modifications is through a $set\n      // of entire array.\n      top.value[arrayAtomicsSymbol] = {};\n      top.value[arrayAtomicsSymbol].$set = top.value;\n    }\n  });\n\n  top = lastPath = null;\n  return minimal;\n};\n\n/**\n * Assigns/compiles `schema` into this documents prototype.\n *\n * @param {Schema} schema\n * @api private\n * @method $__setSchema\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__setSchema = function(schema) {\n  schema.plugin(idGetter, { deduplicate: true });\n  compile(schema.tree, this, undefined, schema.options);\n\n  // Apply default getters if virtual doesn't have any (gh-6262)\n  for (const key of Object.keys(schema.virtuals)) {\n    schema.virtuals[key]._applyDefaultGetters();\n  }\n\n  this.schema = schema;\n  this[documentSchemaSymbol] = schema;\n};\n\n\n/**\n * Get active path that were changed and are arrays\n *\n * @api private\n * @method $__getArrayPathsToValidate\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__getArrayPathsToValidate = function() {\n  DocumentArray || (DocumentArray = require('./types/documentarray'));\n\n  // validate all document arrays.\n  return this.$__.activePaths\n    .map('init', 'modify', function(i) {\n      return this.$__getValue(i);\n    }.bind(this))\n    .filter(function(val) {\n      return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n    }).reduce(function(seed, array) {\n      return seed.concat(array);\n    }, [])\n    .filter(function(doc) {\n      return doc;\n    });\n};\n\n\n/**\n * Get all subdocs (by bfs)\n *\n * @api private\n * @method $__getAllSubdocs\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__getAllSubdocs = function() {\n  DocumentArray || (DocumentArray = require('./types/documentarray'));\n  Embedded = Embedded || require('./types/embedded');\n\n  function docReducer(doc, seed, path) {\n    let val = doc;\n    if (path) {\n      if (doc instanceof Document && doc[documentSchemaSymbol].paths[path]) {\n        val = doc._doc[path];\n      } else {\n        val = doc[path];\n      }\n    }\n    if (val instanceof Embedded) {\n      seed.push(val);\n    } else if (val instanceof Map) {\n      seed = Array.from(val.keys()).reduce(function(seed, path) {\n        return docReducer(val.get(path), seed, null);\n      }, seed);\n    } else if (val && val.$isSingleNested) {\n      seed = Object.keys(val._doc).reduce(function(seed, path) {\n        return docReducer(val._doc, seed, path);\n      }, seed);\n      seed.push(val);\n    } else if (val && val.isMongooseDocumentArray) {\n      val.forEach(function _docReduce(doc) {\n        if (!doc || !doc._doc) {\n          return;\n        }\n        seed = Object.keys(doc._doc).reduce(function(seed, path) {\n          return docReducer(doc._doc, seed, path);\n        }, seed);\n        if (doc instanceof Embedded) {\n          seed.push(doc);\n        }\n      });\n    } else if (val instanceof Document && val.$__isNested) {\n      seed = Object.keys(val).reduce(function(seed, path) {\n        return docReducer(val, seed, path);\n      }, seed);\n    }\n    return seed;\n  }\n\n  const _this = this;\n  const subDocs = Object.keys(this._doc).reduce(function(seed, path) {\n    return docReducer(_this, seed, path);\n  }, []);\n\n  return subDocs;\n};\n\n/*!\n * Runs queued functions\n */\n\nfunction applyQueue(doc) {\n  const q = doc.schema && doc.schema.callQueue;\n  if (!q.length) {\n    return;\n  }\n  let pair;\n\n  for (let i = 0; i < q.length; ++i) {\n    pair = q[i];\n    if (pair[0] !== 'pre' && pair[0] !== 'post' && pair[0] !== 'on') {\n      doc[pair[0]].apply(doc, pair[1]);\n    }\n  }\n}\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__handleReject = function handleReject(err) {\n  // emit on the Model if listening\n  if (this.listeners('error').length) {\n    this.emit('error', err);\n  } else if (this.constructor.listeners && this.constructor.listeners('error').length) {\n    this.constructor.emit('error', err);\n  } else if (this.listeners && this.listeners('error').length) {\n    this.emit('error', err);\n  }\n};\n\n/**\n * Internal helper for toObject() and toJSON() that doesn't manipulate options\n *\n * @api private\n * @method $toObject\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$toObject = function(options, json) {\n  let defaultOptions = {\n    transform: true,\n    flattenDecimals: true\n  };\n\n  const path = json ? 'toJSON' : 'toObject';\n  const baseOptions = get(this, 'constructor.base.options.' + path, {});\n  const schemaOptions = get(this, 'schema.options', {});\n  // merge base default options with Schema's set default options if available.\n  // `clone` is necessary here because `utils.options` directly modifies the second input.\n  defaultOptions = utils.options(defaultOptions, clone(baseOptions));\n  defaultOptions = utils.options(defaultOptions, clone(schemaOptions[path] || {}));\n\n  // If options do not exist or is not an object, set it to empty object\n  options = utils.isPOJO(options) ? clone(options) : {};\n\n  if (!('flattenMaps' in options)) {\n    options.flattenMaps = defaultOptions.flattenMaps;\n  }\n\n  let _minimize;\n  if (options.minimize != null) {\n    _minimize = options.minimize;\n  } else if (defaultOptions.minimize != null) {\n    _minimize = defaultOptions.minimize;\n  } else {\n    _minimize = schemaOptions.minimize;\n  }\n\n  // The original options that will be passed to `clone()`. Important because\n  // `clone()` will recursively call `$toObject()` on embedded docs, so we\n  // need the original options the user passed in, plus `_isNested` and\n  // `_parentOptions` for checking whether we need to depopulate.\n  const cloneOptions = Object.assign(utils.clone(options), {\n    _isNested: true,\n    json: json,\n    minimize: _minimize\n  });\n\n  if (utils.hasUserDefinedProperty(options, 'getters')) {\n    cloneOptions.getters = options.getters;\n  }\n  if (utils.hasUserDefinedProperty(options, 'virtuals')) {\n    cloneOptions.virtuals = options.virtuals;\n  }\n\n  const depopulate = options.depopulate ||\n    get(options, '_parentOptions.depopulate', false);\n  // _isNested will only be true if this is not the top level document, we\n  // should never depopulate\n  if (depopulate && options._isNested && this.$__.wasPopulated) {\n    // populated paths that we set to a document\n    return clone(this._id, cloneOptions);\n  }\n\n  // merge default options with input options.\n  options = utils.options(defaultOptions, options);\n  options._isNested = true;\n  options.json = json;\n  options.minimize = _minimize;\n\n  cloneOptions._parentOptions = options;\n  cloneOptions._skipSingleNestedGetters = true;\n\n  const gettersOptions = Object.assign({}, cloneOptions);\n  gettersOptions._skipSingleNestedGetters = false;\n\n  // remember the root transform function\n  // to save it from being overwritten by sub-transform functions\n  const originalTransform = options.transform;\n\n  let ret = clone(this._doc, cloneOptions) || {};\n\n  if (options.getters) {\n    applyGetters(this, ret, gettersOptions);\n\n    if (options.minimize) {\n      ret = minimize(ret) || {};\n    }\n  }\n\n  if (options.virtuals || (options.getters && options.virtuals !== false)) {\n    applyVirtuals(this, ret, gettersOptions, options);\n  }\n\n  if (options.versionKey === false && this.schema.options.versionKey) {\n    delete ret[this.schema.options.versionKey];\n  }\n\n  let transform = options.transform;\n\n  // In the case where a subdocument has its own transform function, we need to\n  // check and see if the parent has a transform (options.transform) and if the\n  // child schema has a transform (this.schema.options.toObject) In this case,\n  // we need to adjust options.transform to be the child schema's transform and\n  // not the parent schema's\n  if (transform === true || (schemaOptions.toObject && transform)) {\n    const opts = options.json ? schemaOptions.toJSON : schemaOptions.toObject;\n\n    if (opts) {\n      transform = (typeof options.transform === 'function' ? options.transform : opts.transform);\n    }\n  } else {\n    options.transform = originalTransform;\n  }\n\n  if (typeof transform === 'function') {\n    const xformed = transform(this, ret, options);\n    if (typeof xformed !== 'undefined') {\n      ret = xformed;\n    }\n  }\n\n  return ret;\n};\n\n/**\n * Converts this document into a plain javascript object, ready for storage in MongoDB.\n *\n * Buffers are converted to instances of [mongodb.Binary](http://mongodb.github.com/node-mongodb-native/api-bson-generated/binary.html) for proper storage.\n *\n * ####Options:\n *\n * - `getters` apply all getters (path and virtual getters), defaults to false\n * - `virtuals` apply virtual getters (can override `getters` option), defaults to false\n * - `minimize` remove empty objects (defaults to true)\n * - `transform` a transform function to apply to the resulting document before returning\n * - `depopulate` depopulate any populated paths, replacing them with their original refs (defaults to false)\n * - `versionKey` whether to include the version key (defaults to true)\n *\n * ####Getters/Virtuals\n *\n * Example of only applying path getters\n *\n *     doc.toObject({ getters: true, virtuals: false })\n *\n * Example of only applying virtual getters\n *\n *     doc.toObject({ virtuals: true })\n *\n * Example of applying both path and virtual getters\n *\n *     doc.toObject({ getters: true })\n *\n * To apply these options to every document of your schema by default, set your [schemas](#schema_Schema) `toObject` option to the same argument.\n *\n *     schema.set('toObject', { virtuals: true })\n *\n * ####Transform\n *\n * We may need to perform a transformation of the resulting object based on some criteria, say to remove some sensitive information or return a custom object. In this case we set the optional `transform` function.\n *\n * Transform functions receive three arguments\n *\n *     function (doc, ret, options) {}\n *\n * - `doc` The mongoose document which is being converted\n * - `ret` The plain object representation which has been converted\n * - `options` The options in use (either schema options or the options passed inline)\n *\n * ####Example\n *\n *     // specify the transform schema option\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       // remove the _id of every document before returning the result\n *       delete ret._id;\n *       return ret;\n *     }\n *\n *     // without the transformation in the schema\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\n *\n *     // with the transformation\n *     doc.toObject(); // { name: 'Wreck-it Ralph' }\n *\n * With transformations we can do a lot more than remove properties. We can even return completely new customized objects:\n *\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       return { movie: ret.name }\n *     }\n *\n *     // without the transformation in the schema\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\n *\n *     // with the transformation\n *     doc.toObject(); // { movie: 'Wreck-it Ralph' }\n *\n * _Note: if a transform function returns `undefined`, the return value will be ignored._\n *\n * Transformations may also be applied inline, overridding any transform set in the options:\n *\n *     function xform (doc, ret, options) {\n *       return { inline: ret.name, custom: true }\n *     }\n *\n *     // pass the transform as an inline option\n *     doc.toObject({ transform: xform }); // { inline: 'Wreck-it Ralph', custom: true }\n *\n * If you want to skip transformations, use `transform: false`:\n *\n *     schema.options.toObject.hide = '_id';\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       if (options.hide) {\n *         options.hide.split(' ').forEach(function (prop) {\n *           delete ret[prop];\n *         });\n *       }\n *       return ret;\n *     }\n *\n *     var doc = new Doc({ _id: 'anId', secret: 47, name: 'Wreck-it Ralph' });\n *     doc.toObject();                                        // { secret: 47, name: 'Wreck-it Ralph' }\n *     doc.toObject({ hide: 'secret _id', transform: false });// { _id: 'anId', secret: 47, name: 'Wreck-it Ralph' }\n *     doc.toObject({ hide: 'secret _id', transform: true }); // { name: 'Wreck-it Ralph' }\n *\n * If you pass a transform in `toObject()` options, Mongoose will apply the transform\n * to [subdocuments](/docs/subdocs.html) in addition to the top-level document.\n * Similarly, `transform: false` skips transforms for all subdocuments.\n * Note that this is behavior is different for transforms defined in the schema:\n * if you define a transform in `schema.options.toObject.transform`, that transform\n * will **not** apply to subdocuments.\n *\n *     const memberSchema = new Schema({ name: String, email: String });\n *     const groupSchema = new Schema({ members: [memberSchema], name: String, email });\n *     const Group = mongoose.model('Group', groupSchema);\n *\n *     const doc = new Group({\n *       name: 'Engineering',\n *       email: 'dev@mongoosejs.io',\n *       members: [{ name: 'Val', email: 'val@mongoosejs.io' }]\n *     });\n *\n *     // Removes `email` from both top-level document **and** array elements\n *     // { name: 'Engineering', members: [{ name: 'Val' }] }\n *     doc.toObject({ transform: (doc, ret) => { delete ret.email; return ret; } });\n *\n * Transforms, like all of these options, are also available for `toJSON`. See [this guide to `JSON.stringify()`](https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html) to learn why `toJSON()` and `toObject()` are separate functions.\n *\n * See [schema options](/docs/guide.html#toObject) for some more details.\n *\n * _During save, no custom options are applied to the document before being sent to the database._\n *\n * @param {Object} [options]\n * @param {Boolean} [options.getters=false] if true, apply all getters, including virtuals\n * @param {Boolean} [options.virtuals=false] if true, apply virtuals, including aliases. Use `{ getters: true, virtuals: false }` to just apply getters, not virtuals\n * @param {Boolean} [options.aliases=true] if `options.virtuals = true`, you can set `options.aliases = false` to skip applying aliases. This option is a no-op if `options.virtuals = false`.\n * @param {Boolean} [options.minimize=true] if true, omit any empty objects from the output\n * @param {Function|null} [options.transform=null] if set, mongoose will call this function to allow you to transform the returned object\n * @param {Boolean} [options.depopulate=false] if true, replace any conventionally populated paths with the original id in the output. Has no affect on virtual populated paths.\n * @param {Boolean} [options.versionKey=true] if false, exclude the version key (`__v` by default) from the output\n * @param {Boolean} [options.flattenMaps=false] if true, convert Maps to POJOs. Useful if you want to `JSON.stringify()` the result of `toObject()`.\n * @return {Object} js object\n * @see mongodb.Binary http://mongodb.github.com/node-mongodb-native/api-bson-generated/binary.html\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.toObject = function(options) {\n  return this.$toObject(options);\n};\n\n/*!\n * Minimizes an object, removing undefined values and empty objects\n *\n * @param {Object} object to minimize\n * @return {Object}\n */\n\nfunction minimize(obj) {\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let hasKeys;\n  let key;\n  let val;\n\n  while (i--) {\n    key = keys[i];\n    val = obj[key];\n\n    if (utils.isObject(val) && !Buffer.isBuffer(val)) {\n      obj[key] = minimize(val);\n    }\n\n    if (undefined === obj[key]) {\n      delete obj[key];\n      continue;\n    }\n\n    hasKeys = true;\n  }\n\n  return hasKeys\n    ? obj\n    : undefined;\n}\n\n/*!\n * Applies virtuals properties to `json`.\n */\n\nfunction applyVirtuals(self, json, options, toObjectOptions) {\n  const schema = self.schema;\n  const paths = Object.keys(schema.virtuals);\n  let i = paths.length;\n  const numPaths = i;\n  let path;\n  let assignPath;\n  let cur = self._doc;\n  let v;\n  const aliases = get(toObjectOptions, 'aliases', true);\n\n  if (!cur) {\n    return json;\n  }\n\n  options = options || {};\n  for (i = 0; i < numPaths; ++i) {\n    path = paths[i];\n\n    // Allow skipping aliases with `toObject({ virtuals: true, aliases: false })`\n    if (!aliases && schema.aliases.hasOwnProperty(path)) {\n      continue;\n    }\n\n    // We may be applying virtuals to a nested object, for example if calling\n    // `doc.nestedProp.toJSON()`. If so, the path we assign to, `assignPath`,\n    // will be a trailing substring of the `path`.\n    assignPath = path;\n    if (options.path != null) {\n      if (!path.startsWith(options.path + '.')) {\n        continue;\n      }\n      assignPath = path.substr(options.path.length + 1);\n    }\n    const parts = assignPath.split('.');\n    v = clone(self.get(path), options);\n    if (v === void 0) {\n      continue;\n    }\n    const plen = parts.length;\n    cur = json;\n    for (let j = 0; j < plen - 1; ++j) {\n      cur[parts[j]] = cur[parts[j]] || {};\n      cur = cur[parts[j]];\n    }\n    cur[parts[plen - 1]] = v;\n  }\n\n  return json;\n}\n\n/*!\n * Applies virtuals properties to `json`.\n *\n * @param {Document} self\n * @param {Object} json\n * @return {Object} `json`\n */\n\nfunction applyGetters(self, json, options) {\n  const schema = self.schema;\n  const paths = Object.keys(schema.paths);\n  let i = paths.length;\n  let path;\n  let cur = self._doc;\n  let v;\n\n  if (!cur) {\n    return json;\n  }\n\n  while (i--) {\n    path = paths[i];\n\n    const parts = path.split('.');\n    const plen = parts.length;\n    const last = plen - 1;\n    let branch = json;\n    let part;\n    cur = self._doc;\n\n    if (!self.isSelected(path)) {\n      continue;\n    }\n\n    for (let ii = 0; ii < plen; ++ii) {\n      part = parts[ii];\n      v = cur[part];\n      if (ii === last) {\n        const val = self.get(path);\n        branch[part] = clone(val, options);\n      } else if (v == null) {\n        if (part in cur) {\n          branch[part] = v;\n        }\n        break;\n      } else {\n        branch = branch[part] || (branch[part] = {});\n      }\n      cur = v;\n    }\n  }\n\n  return json;\n}\n\n/**\n * The return value of this method is used in calls to JSON.stringify(doc).\n *\n * This method accepts the same options as [Document#toObject](#document_Document-toObject). To apply the options to every document of your schema by default, set your [schemas](#schema_Schema) `toJSON` option to the same argument.\n *\n *     schema.set('toJSON', { virtuals: true })\n *\n * See [schema options](/docs/guide.html#toJSON) for details.\n *\n * @param {Object} options\n * @return {Object}\n * @see Document#toObject #document_Document-toObject\n * @see JSON.stringify() in JavaScript https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.toJSON = function(options) {\n  return this.$toObject(options, true);\n};\n\n/**\n * Helper for console.log\n *\n * @api public\n * @method inspect\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.inspect = function(options) {\n  const isPOJO = utils.isPOJO(options);\n  let opts;\n  if (isPOJO) {\n    opts = options;\n    opts.minimize = false;\n  }\n  const ret = this.toObject(opts);\n\n  if (ret == null) {\n    // If `toObject()` returns null, `this` is still an object, so if `inspect()`\n    // prints out null this can cause some serious confusion. See gh-7942.\n    return 'MongooseDocument { ' + ret + ' }';\n  }\n\n  return ret;\n};\n\nif (inspect.custom) {\n  /*!\n  * Avoid Node deprecation warning DEP0079\n  */\n\n  Document.prototype[inspect.custom] = Document.prototype.inspect;\n}\n\n/**\n * Helper for console.log\n *\n * @api public\n * @method toString\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.toString = function() {\n  const ret = this.inspect();\n  if (typeof ret === 'string') {\n    return ret;\n  }\n  return inspect(ret);\n};\n\n/**\n * Returns true if the Document stores the same data as doc.\n *\n * Documents are considered equal when they have matching `_id`s, unless neither\n * document has an `_id`, in which case this function falls back to using\n * `deepEqual()`.\n *\n * @param {Document} doc a document to compare\n * @return {Boolean}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.equals = function(doc) {\n  if (!doc) {\n    return false;\n  }\n\n  const tid = this.get('_id');\n  const docid = doc.get ? doc.get('_id') : doc;\n  if (!tid && !docid) {\n    return deepEqual(this, doc);\n  }\n  return tid && tid.equals\n    ? tid.equals(docid)\n    : tid === docid;\n};\n\n/**\n * Populates document references, executing the `callback` when complete.\n * If you want to use promises instead, use this function with\n * [`execPopulate()`](#document_Document-execPopulate)\n *\n * ####Example:\n *\n *     doc\n *     .populate('company')\n *     .populate({\n *       path: 'notes',\n *       match: /airline/,\n *       select: 'text',\n *       model: 'modelName'\n *       options: opts\n *     }, function (err, user) {\n *       assert(doc._id === user._id) // the document itself is passed\n *     })\n *\n *     // summary\n *     doc.populate(path)                   // not executed\n *     doc.populate(options);               // not executed\n *     doc.populate(path, callback)         // executed\n *     doc.populate(options, callback);     // executed\n *     doc.populate(callback);              // executed\n *     doc.populate(options).execPopulate() // executed, returns promise\n *\n *\n * ####NOTE:\n *\n * Population does not occur unless a `callback` is passed *or* you explicitly\n * call `execPopulate()`.\n * Passing the same path a second time will overwrite the previous path options.\n * See [Model.populate()](#model_Model.populate) for explaination of options.\n *\n * @see Model.populate #model_Model.populate\n * @see Document.execPopulate #document_Document-execPopulate\n * @param {String|Object} [path] The path to populate or an options object\n * @param {Function} [callback] When passed, population is invoked\n * @api public\n * @return {Document} this\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.populate = function populate() {\n  if (arguments.length === 0) {\n    return this;\n  }\n\n  const pop = this.$__.populate || (this.$__.populate = {});\n  const args = utils.args(arguments);\n  let fn;\n\n  if (typeof args[args.length - 1] === 'function') {\n    fn = args.pop();\n  }\n\n  // allow `doc.populate(callback)`\n  if (args.length) {\n    // use hash to remove duplicate paths\n    const res = utils.populate.apply(null, args);\n    for (let i = 0; i < res.length; ++i) {\n      pop[res[i].path] = res[i];\n    }\n  }\n\n  if (fn) {\n    const paths = utils.object.vals(pop);\n    this.$__.populate = undefined;\n    let topLevelModel = this.constructor;\n    if (this.$__isNested) {\n      topLevelModel = this.$__.scope.constructor;\n      const nestedPath = this.$__.nestedPath;\n      paths.forEach(function(populateOptions) {\n        populateOptions.path = nestedPath + '.' + populateOptions.path;\n      });\n    }\n\n    // Use `$session()` by default if the document has an associated session\n    // See gh-6754\n    if (this.$session() != null) {\n      const session = this.$session();\n      paths.forEach(path => {\n        if (path.options == null) {\n          path.options = { session: session };\n          return;\n        }\n        if (!('session' in path.options)) {\n          path.options.session = session;\n        }\n      });\n    }\n\n    topLevelModel.populate(this, paths, fn);\n  }\n\n  return this;\n};\n\n/**\n * Explicitly executes population and returns a promise. Useful for ES2015\n * integration.\n *\n * ####Example:\n *\n *     var promise = doc.\n *       populate('company').\n *       populate({\n *         path: 'notes',\n *         match: /airline/,\n *         select: 'text',\n *         model: 'modelName'\n *         options: opts\n *       }).\n *       execPopulate();\n *\n *     // summary\n *     doc.execPopulate().then(resolve, reject);\n *\n *\n * @see Document.populate #document_Document-populate\n * @api public\n * @param {Function} [callback] optional callback. If specified, a promise will **not** be returned\n * @return {Promise} promise that resolves to the document when population is done\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.execPopulate = function(callback) {\n  return utils.promiseOrCallback(callback, cb => {\n    this.populate(cb);\n  }, this.constructor.events);\n};\n\n/**\n * Gets _id(s) used during population of the given `path`.\n *\n * ####Example:\n *\n *     Model.findOne().populate('author').exec(function (err, doc) {\n *       console.log(doc.author.name)         // Dr.Seuss\n *       console.log(doc.populated('author')) // '5144cf8050f071d979c118a7'\n *     })\n *\n * If the path was not populated, undefined is returned.\n *\n * @param {String} path\n * @return {Array|ObjectId|Number|Buffer|String|undefined}\n * @memberOf Document\n * @instance\n * @api public\n */\n\nDocument.prototype.populated = function(path, val, options) {\n  // val and options are internal\n  if (val === null || val === void 0) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    const v = this.$__.populated[path];\n    if (v) {\n      return v.value;\n    }\n    return undefined;\n  }\n\n  // internal\n  if (val === true) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    return this.$__.populated[path];\n  }\n\n  this.$__.populated || (this.$__.populated = {});\n  this.$__.populated[path] = {value: val, options: options};\n\n  // If this was a nested populate, make sure each populated doc knows\n  // about its populated children (gh-7685)\n  const pieces = path.split('.');\n  for (let i = 0; i < pieces.length - 1; ++i) {\n    const subpath = pieces.slice(0, i + 1).join('.');\n    const subdoc = this.get(subpath);\n    if (subdoc != null && subdoc.$__ != null && this.populated(subpath)) {\n      const rest = pieces.slice(i + 1).join('.');\n      subdoc.populated(rest, val, options);\n      // No need to continue because the above recursion should take care of\n      // marking the rest of the docs as populated\n      break;\n    }\n  }\n\n  return val;\n};\n\n/**\n * Takes a populated field and returns it to its unpopulated state.\n *\n * ####Example:\n *\n *     Model.findOne().populate('author').exec(function (err, doc) {\n *       console.log(doc.author.name); // Dr.Seuss\n *       console.log(doc.depopulate('author'));\n *       console.log(doc.author); // '5144cf8050f071d979c118a7'\n *     })\n *\n * If the path was not populated, this is a no-op.\n *\n * @param {String} path\n * @return {Document} this\n * @see Document.populate #document_Document-populate\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.depopulate = function(path) {\n  if (typeof path === 'string') {\n    path = path.split(' ');\n  }\n  let populatedIds;\n  const virtualKeys = this.$$populatedVirtuals ? Object.keys(this.$$populatedVirtuals) : [];\n  const populated = get(this, '$__.populated', {});\n\n  if (arguments.length === 0) {\n    // Depopulate all\n    for (let i = 0; i < virtualKeys.length; i++) {\n      delete this.$$populatedVirtuals[virtualKeys[i]];\n      delete this._doc[virtualKeys[i]];\n      delete populated[virtualKeys[i]];\n    }\n\n    const keys = Object.keys(populated);\n\n    for (let i = 0; i < keys.length; i++) {\n      populatedIds = this.populated(keys[i]);\n      if (!populatedIds) {\n        continue;\n      }\n      delete populated[keys[i]];\n      this.$set(keys[i], populatedIds);\n    }\n    return this;\n  }\n\n  for (let i = 0; i < path.length; i++) {\n    populatedIds = this.populated(path[i]);\n    delete populated[path[i]];\n\n    if (virtualKeys.indexOf(path[i]) !== -1) {\n      delete this.$$populatedVirtuals[path[i]];\n      delete this._doc[path[i]];\n    } else if (populatedIds) {\n      this.$set(path[i], populatedIds);\n    }\n  }\n  return this;\n};\n\n\n/**\n * Returns the full path to this document.\n *\n * @param {String} [path]\n * @return {String}\n * @api private\n * @method $__fullPath\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__fullPath = function(path) {\n  // overridden in SubDocuments\n  return path || '';\n};\n\n/*!\n * Module exports.\n */\n\nDocument.ValidationError = ValidationError;\nmodule.exports = exports = Document;\n"]},"metadata":{},"sourceType":"script"}