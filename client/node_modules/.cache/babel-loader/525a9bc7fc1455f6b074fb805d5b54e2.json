{"ast":null,"code":"'use strict';\n/*!\n * Module dependencies.\n */\n\nconst $exists = require('./operators/exists');\n\nconst $type = require('./operators/type');\n\nconst MongooseError = require('../error/mongooseError');\n\nconst SchemaArrayOptions = require('../options/SchemaArrayOptions');\n\nconst SchemaType = require('../schematype');\n\nconst CastError = SchemaType.CastError;\n\nconst Mixed = require('./mixed');\n\nconst cast = require('../cast');\n\nconst get = require('../helpers/get');\n\nconst util = require('util');\n\nconst utils = require('../utils');\n\nconst castToNumber = require('./operators/helpers').castToNumber;\n\nconst geospatial = require('./operators/geospatial');\n\nconst getDiscriminatorByValue = require('../helpers/discriminator/getDiscriminatorByValue');\n\nlet MongooseArray;\nlet EmbeddedDoc;\n/**\n * Array SchemaType constructor\n *\n * @param {String} key\n * @param {SchemaType} cast\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaArray(key, cast, options, schemaOptions) {\n  // lazy load\n  EmbeddedDoc || (EmbeddedDoc = require('../types').Embedded);\n  let typeKey = 'type';\n\n  if (schemaOptions && schemaOptions.typeKey) {\n    typeKey = schemaOptions.typeKey;\n  }\n\n  this.schemaOptions = schemaOptions;\n\n  if (cast) {\n    let castOptions = {};\n\n    if (utils.isPOJO(cast)) {\n      if (cast[typeKey]) {\n        // support { type: Woot }\n        castOptions = utils.clone(cast); // do not alter user arguments\n\n        delete castOptions[typeKey];\n        cast = cast[typeKey];\n      } else {\n        cast = Mixed;\n      }\n    }\n\n    if (cast === Object) {\n      cast = Mixed;\n    } // support { type: 'String' }\n\n\n    const name = typeof cast === 'string' ? cast : utils.getFunctionName(cast);\n\n    const Types = require('./index.js');\n\n    const caster = Types.hasOwnProperty(name) ? Types[name] : cast;\n    this.casterConstructor = caster;\n\n    if (typeof caster === 'function' && !caster.$isArraySubdocument && !caster.$isSchemaMap) {\n      this.caster = new caster(null, castOptions);\n    } else {\n      this.caster = caster;\n    }\n\n    if (!(this.caster instanceof EmbeddedDoc)) {\n      this.caster.path = key;\n    }\n  }\n\n  this.$isMongooseArray = true;\n  SchemaType.call(this, key, options, 'Array');\n  let defaultArr;\n  let fn;\n\n  if (this.defaultValue != null) {\n    defaultArr = this.defaultValue;\n    fn = typeof defaultArr === 'function';\n  }\n\n  if (!('defaultValue' in this) || this.defaultValue !== void 0) {\n    const defaultFn = function () {\n      let arr = [];\n\n      if (fn) {\n        arr = defaultArr.call(this);\n      } else if (defaultArr != null) {\n        arr = arr.concat(defaultArr);\n      } // Leave it up to `cast()` to convert the array\n\n\n      return arr;\n    };\n\n    defaultFn.$runBeforeSetters = true;\n    this.default(defaultFn);\n  }\n}\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\n\n\nSchemaArray.schemaName = 'Array';\n/**\n * Options for all arrays.\n *\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n *\n * @static options\n * @api public\n */\n\nSchemaArray.options = {\n  castNonArrays: true\n};\n/*!\n * Inherits from SchemaType.\n */\n\nSchemaArray.prototype = Object.create(SchemaType.prototype);\nSchemaArray.prototype.constructor = SchemaArray;\nSchemaArray.prototype.OptionsConstructor = SchemaArrayOptions;\n/*!\n * ignore\n */\n\nSchemaArray._checkRequired = SchemaType.prototype.checkRequired;\n/**\n * Override the function the required validator uses to check whether an array\n * passes the `required` check.\n *\n * ####Example:\n *\n *     // Require non-empty array to pass `required` check\n *     mongoose.Schema.Types.Array.checkRequired(v => Array.isArray(v) && v.length);\n *\n *     const M = mongoose.model({ arr: { type: Array, required: true } });\n *     new M({ arr: [] }).validateSync(); // `null`, validation fails!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaArray.checkRequired = SchemaType.checkRequired;\n/**\n * Check if the given value satisfies the `required` validator.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaArray.prototype.checkRequired = function checkRequired(value, doc) {\n  if (SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  } // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n\n\n  const _checkRequired = typeof this.constructor.checkRequired == 'function' ? this.constructor.checkRequired() : SchemaArray.checkRequired();\n\n  return _checkRequired(value);\n};\n/**\n * Adds an enum validator if this is an array of strings. Equivalent to\n * `SchemaString.prototype.enum()`\n *\n * @param {String|Object} [args...] enumeration values\n * @return {SchemaType} this\n */\n\n\nSchemaArray.prototype.enum = function () {\n  let arr = this;\n\n  while (true) {\n    const instance = get(arr, 'caster.instance');\n\n    if (instance === 'Array') {\n      arr = arr.caster;\n      continue;\n    }\n\n    if (instance !== 'String') {\n      throw new Error('`enum` can only be set on an array of strings, not ' + instance);\n    }\n\n    break;\n  }\n\n  arr.caster.enum.apply(arr.caster, arguments);\n  return this;\n};\n/**\n * Overrides the getters application for the population special-case\n *\n * @param {Object} value\n * @param {Object} scope\n * @api private\n */\n\n\nSchemaArray.prototype.applyGetters = function (value, scope) {\n  if (this.caster.options && this.caster.options.ref) {\n    // means the object id was populated\n    return value;\n  }\n\n  return SchemaType.prototype.applyGetters.call(this, value, scope);\n};\n/**\n * Casts values for set().\n *\n * @param {Object} value\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\n\nSchemaArray.prototype.cast = function (value, doc, init) {\n  // lazy load\n  MongooseArray || (MongooseArray = require('../types').Array);\n  let i;\n  let l;\n\n  if (Array.isArray(value)) {\n    if (!value.length && doc) {\n      const indexes = doc.schema.indexedPaths();\n      const arrayPath = this.path;\n\n      for (i = 0, l = indexes.length; i < l; ++i) {\n        const pathIndex = indexes[i][0][arrayPath];\n\n        if (pathIndex === '2dsphere' || pathIndex === '2d') {\n          return;\n        }\n      } // Special case: if this index is on the parent of what looks like\n      // GeoJSON, skip setting the default to empty array re: #1668, #3233\n\n\n      const arrayGeojsonPath = this.path.endsWith('.coordinates') ? this.path.substr(0, this.path.lastIndexOf('.')) : null;\n\n      if (arrayGeojsonPath != null) {\n        for (i = 0, l = indexes.length; i < l; ++i) {\n          const pathIndex = indexes[i][0][arrayGeojsonPath];\n\n          if (pathIndex === '2dsphere') {\n            return;\n          }\n        }\n      }\n    }\n\n    if (!(value && value.isMongooseArray)) {\n      value = new MongooseArray(value, this.path, doc);\n    } else if (value && value.isMongooseArray) {\n      // We need to create a new array, otherwise change tracking will\n      // update the old doc (gh-4449)\n      value = new MongooseArray(value, this.path, doc);\n    }\n\n    const isPopulated = doc != null && doc.$__ != null && doc.populated(this.path);\n\n    if (isPopulated) {\n      return value;\n    }\n\n    if (this.caster && this.casterConstructor !== Mixed) {\n      try {\n        for (i = 0, l = value.length; i < l; i++) {\n          value[i] = this.caster.cast(value[i], doc, init);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path, e);\n      }\n    }\n\n    return value;\n  }\n\n  if (init || SchemaArray.options.castNonArrays) {\n    // gh-2442: if we're loading this from the db and its not an array, mark\n    // the whole array as modified.\n    if (!!doc && !!init) {\n      doc.markModified(this.path);\n    }\n\n    return this.cast([value], doc, init);\n  }\n\n  throw new CastError('Array', util.inspect(value), this.path);\n};\n/*!\n * Ignore\n */\n\n\nSchemaArray.prototype.discriminator = function (name, schema) {\n  let arr = this; // eslint-disable-line consistent-this\n\n  while (arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {\n    arr = arr.casterConstructor;\n\n    if (arr == null || typeof arr === 'function') {\n      throw new MongooseError('You can only add an embedded discriminator on ' + 'a document array, ' + this.path + ' is a plain array');\n    }\n  }\n\n  return arr.discriminator(name, schema);\n};\n/*!\n * ignore\n */\n\n\nSchemaArray.prototype.clone = function () {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, this.caster, options, this.schemaOptions);\n  schematype.validators = this.validators.slice();\n  return schematype;\n};\n/**\n * Casts values for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\n\nSchemaArray.prototype.castForQuery = function ($conditional, value) {\n  let handler;\n  let val;\n\n  if (arguments.length === 2) {\n    handler = this.$conditionalHandlers[$conditional];\n\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with Array.');\n    }\n\n    val = handler.call(this, value);\n  } else {\n    val = $conditional;\n    let Constructor = this.casterConstructor;\n\n    if (val && Constructor.discriminators && Constructor.schema && Constructor.schema.options && Constructor.schema.options.discriminatorKey) {\n      if (typeof val[Constructor.schema.options.discriminatorKey] === 'string' && Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]]) {\n        Constructor = Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]];\n      } else {\n        const constructorByValue = getDiscriminatorByValue(Constructor, val[Constructor.schema.options.discriminatorKey]);\n\n        if (constructorByValue) {\n          Constructor = constructorByValue;\n        }\n      }\n    }\n\n    const proto = this.casterConstructor.prototype;\n    let method = proto && (proto.castForQuery || proto.cast);\n\n    if (!method && Constructor.castForQuery) {\n      method = Constructor.castForQuery;\n    }\n\n    const caster = this.caster;\n\n    if (Array.isArray(val)) {\n      this.setters.reverse().forEach(setter => {\n        val = setter.call(this, val, this);\n      });\n      val = val.map(function (v) {\n        if (utils.isObject(v) && v.$elemMatch) {\n          return v;\n        }\n\n        if (method) {\n          v = method.call(caster, v);\n          return v;\n        }\n\n        if (v != null) {\n          v = new Constructor(v);\n          return v;\n        }\n\n        return v;\n      });\n    } else if (method) {\n      val = method.call(caster, val);\n    } else if (val != null) {\n      val = new Constructor(val);\n    }\n  }\n\n  return val;\n};\n\nfunction cast$all(val) {\n  if (!Array.isArray(val)) {\n    val = [val];\n  }\n\n  val = val.map(function (v) {\n    if (utils.isObject(v)) {\n      const o = {};\n      o[this.path] = v;\n      return cast(this.casterConstructor.schema, o)[this.path];\n    }\n\n    return v;\n  }, this);\n  return this.castForQuery(val);\n}\n\nfunction cast$elemMatch(val) {\n  const keys = Object.keys(val);\n  const numKeys = keys.length;\n\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    const value = val[key];\n\n    if (key.startsWith('$') && value) {\n      val[key] = this.castForQuery(key, value);\n    }\n  } // Is this an embedded discriminator and is the discriminator key set?\n  // If so, use the discriminator schema. See gh-7449\n\n\n  const discriminatorKey = get(this, 'casterConstructor.schema.options.discriminatorKey');\n  const discriminators = get(this, 'casterConstructor.schema.discriminators', {});\n\n  if (discriminatorKey != null && val[discriminatorKey] != null && discriminators[val[discriminatorKey]] != null) {\n    return cast(discriminators[val[discriminatorKey]], val);\n  }\n\n  return cast(this.casterConstructor.schema, val);\n}\n\nconst handle = SchemaArray.prototype.$conditionalHandlers = {};\nhandle.$all = cast$all;\nhandle.$options = String;\nhandle.$elemMatch = cast$elemMatch;\nhandle.$geoIntersects = geospatial.cast$geoIntersects;\n\nhandle.$or = handle.$and = function (val) {\n  if (!Array.isArray(val)) {\n    throw new TypeError('conditional $or/$and require array');\n  }\n\n  const ret = [];\n\n  for (let i = 0; i < val.length; ++i) {\n    ret.push(cast(this.casterConstructor.schema, val[i]));\n  }\n\n  return ret;\n};\n\nhandle.$near = handle.$nearSphere = geospatial.cast$near;\nhandle.$within = handle.$geoWithin = geospatial.cast$within;\nhandle.$size = handle.$minDistance = handle.$maxDistance = castToNumber;\nhandle.$exists = $exists;\nhandle.$type = $type;\nhandle.$eq = handle.$gt = handle.$gte = handle.$lt = handle.$lte = handle.$ne = handle.$regex = SchemaArray.prototype.castForQuery; // `$in` is special because you can also include an empty array in the query\n// like `$in: [1, []]`, see gh-5913\n\nhandle.$nin = SchemaType.prototype.$conditionalHandlers.$nin;\nhandle.$in = SchemaType.prototype.$conditionalHandlers.$in;\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaArray;","map":{"version":3,"sources":["D:/Other/Git/Developer-Connector/node_modules/mongoose/lib/schema/array.js"],"names":["$exists","require","$type","MongooseError","SchemaArrayOptions","SchemaType","CastError","Mixed","cast","get","util","utils","castToNumber","geospatial","getDiscriminatorByValue","MongooseArray","EmbeddedDoc","SchemaArray","key","options","schemaOptions","Embedded","typeKey","castOptions","isPOJO","clone","Object","name","getFunctionName","Types","caster","hasOwnProperty","casterConstructor","$isArraySubdocument","$isSchemaMap","path","$isMongooseArray","call","defaultArr","fn","defaultValue","defaultFn","arr","concat","$runBeforeSetters","default","schemaName","castNonArrays","prototype","create","constructor","OptionsConstructor","_checkRequired","checkRequired","value","doc","_isRef","enum","instance","Error","apply","arguments","applyGetters","scope","ref","init","Array","i","l","isArray","length","indexes","schema","indexedPaths","arrayPath","pathIndex","arrayGeojsonPath","endsWith","substr","lastIndexOf","isMongooseArray","isPopulated","$__","populated","e","kind","inspect","markModified","discriminator","$isMongooseDocumentArray","assign","schematype","validators","slice","castForQuery","$conditional","handler","val","$conditionalHandlers","Constructor","discriminators","discriminatorKey","constructorByValue","proto","method","setters","reverse","forEach","setter","map","v","isObject","$elemMatch","cast$all","o","cast$elemMatch","keys","numKeys","startsWith","handle","$all","$options","String","$geoIntersects","cast$geoIntersects","$or","$and","TypeError","ret","push","$near","$nearSphere","cast$near","$within","$geoWithin","cast$within","$size","$minDistance","$maxDistance","$eq","$gt","$gte","$lt","$lte","$ne","$regex","$nin","$in","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst $exists = require('./operators/exists');\nconst $type = require('./operators/type');\nconst MongooseError = require('../error/mongooseError');\nconst SchemaArrayOptions = require('../options/SchemaArrayOptions');\nconst SchemaType = require('../schematype');\nconst CastError = SchemaType.CastError;\nconst Mixed = require('./mixed');\nconst cast = require('../cast');\nconst get = require('../helpers/get');\nconst util = require('util');\nconst utils = require('../utils');\nconst castToNumber = require('./operators/helpers').castToNumber;\nconst geospatial = require('./operators/geospatial');\nconst getDiscriminatorByValue = require('../helpers/discriminator/getDiscriminatorByValue');\n\nlet MongooseArray;\nlet EmbeddedDoc;\n\n/**\n * Array SchemaType constructor\n *\n * @param {String} key\n * @param {SchemaType} cast\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaArray(key, cast, options, schemaOptions) {\n  // lazy load\n  EmbeddedDoc || (EmbeddedDoc = require('../types').Embedded);\n\n  let typeKey = 'type';\n  if (schemaOptions && schemaOptions.typeKey) {\n    typeKey = schemaOptions.typeKey;\n  }\n  this.schemaOptions = schemaOptions;\n\n  if (cast) {\n    let castOptions = {};\n\n    if (utils.isPOJO(cast)) {\n      if (cast[typeKey]) {\n        // support { type: Woot }\n        castOptions = utils.clone(cast); // do not alter user arguments\n        delete castOptions[typeKey];\n        cast = cast[typeKey];\n      } else {\n        cast = Mixed;\n      }\n    }\n\n    if (cast === Object) {\n      cast = Mixed;\n    }\n\n    // support { type: 'String' }\n    const name = typeof cast === 'string'\n      ? cast\n      : utils.getFunctionName(cast);\n\n    const Types = require('./index.js');\n    const caster = Types.hasOwnProperty(name) ? Types[name] : cast;\n\n    this.casterConstructor = caster;\n\n    if (typeof caster === 'function' &&\n        !caster.$isArraySubdocument &&\n        !caster.$isSchemaMap) {\n      this.caster = new caster(null, castOptions);\n    } else {\n      this.caster = caster;\n    }\n\n    if (!(this.caster instanceof EmbeddedDoc)) {\n      this.caster.path = key;\n    }\n  }\n\n  this.$isMongooseArray = true;\n\n  SchemaType.call(this, key, options, 'Array');\n\n  let defaultArr;\n  let fn;\n\n  if (this.defaultValue != null) {\n    defaultArr = this.defaultValue;\n    fn = typeof defaultArr === 'function';\n  }\n\n  if (!('defaultValue' in this) || this.defaultValue !== void 0) {\n    const defaultFn = function() {\n      let arr = [];\n      if (fn) {\n        arr = defaultArr.call(this);\n      } else if (defaultArr != null) {\n        arr = arr.concat(defaultArr);\n      }\n      // Leave it up to `cast()` to convert the array\n      return arr;\n    };\n    defaultFn.$runBeforeSetters = true;\n    this.default(defaultFn);\n  }\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaArray.schemaName = 'Array';\n\n/**\n * Options for all arrays.\n *\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n *\n * @static options\n * @api public\n */\n\nSchemaArray.options = { castNonArrays: true };\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaArray.prototype = Object.create(SchemaType.prototype);\nSchemaArray.prototype.constructor = SchemaArray;\nSchemaArray.prototype.OptionsConstructor = SchemaArrayOptions;\n\n/*!\n * ignore\n */\n\nSchemaArray._checkRequired = SchemaType.prototype.checkRequired;\n\n/**\n * Override the function the required validator uses to check whether an array\n * passes the `required` check.\n *\n * ####Example:\n *\n *     // Require non-empty array to pass `required` check\n *     mongoose.Schema.Types.Array.checkRequired(v => Array.isArray(v) && v.length);\n *\n *     const M = mongoose.model({ arr: { type: Array, required: true } });\n *     new M({ arr: [] }).validateSync(); // `null`, validation fails!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaArray.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies the `required` validator.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaArray.prototype.checkRequired = function checkRequired(value, doc) {\n  if (SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired == 'function' ?\n    this.constructor.checkRequired() :\n    SchemaArray.checkRequired();\n\n  return _checkRequired(value);\n};\n\n/**\n * Adds an enum validator if this is an array of strings. Equivalent to\n * `SchemaString.prototype.enum()`\n *\n * @param {String|Object} [args...] enumeration values\n * @return {SchemaType} this\n */\n\nSchemaArray.prototype.enum = function() {\n  let arr = this;\n  while (true) {\n    const instance = get(arr, 'caster.instance');\n    if (instance === 'Array') {\n      arr = arr.caster;\n      continue;\n    }\n    if (instance !== 'String') {\n      throw new Error('`enum` can only be set on an array of strings, not ' + instance);\n    }\n    break;\n  }\n  arr.caster.enum.apply(arr.caster, arguments);\n  return this;\n};\n\n/**\n * Overrides the getters application for the population special-case\n *\n * @param {Object} value\n * @param {Object} scope\n * @api private\n */\n\nSchemaArray.prototype.applyGetters = function(value, scope) {\n  if (this.caster.options && this.caster.options.ref) {\n    // means the object id was populated\n    return value;\n  }\n\n  return SchemaType.prototype.applyGetters.call(this, value, scope);\n};\n\n/**\n * Casts values for set().\n *\n * @param {Object} value\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\nSchemaArray.prototype.cast = function(value, doc, init) {\n  // lazy load\n  MongooseArray || (MongooseArray = require('../types').Array);\n\n  let i;\n  let l;\n\n  if (Array.isArray(value)) {\n    if (!value.length && doc) {\n      const indexes = doc.schema.indexedPaths();\n\n      const arrayPath = this.path;\n      for (i = 0, l = indexes.length; i < l; ++i) {\n        const pathIndex = indexes[i][0][arrayPath];\n        if (pathIndex === '2dsphere' || pathIndex === '2d') {\n          return;\n        }\n      }\n\n      // Special case: if this index is on the parent of what looks like\n      // GeoJSON, skip setting the default to empty array re: #1668, #3233\n      const arrayGeojsonPath = this.path.endsWith('.coordinates') ?\n        this.path.substr(0, this.path.lastIndexOf('.')) : null;\n      if (arrayGeojsonPath != null) {\n        for (i = 0, l = indexes.length; i < l; ++i) {\n          const pathIndex = indexes[i][0][arrayGeojsonPath];\n          if (pathIndex === '2dsphere') {\n            return;\n          }\n        }\n      }\n    }\n\n    if (!(value && value.isMongooseArray)) {\n      value = new MongooseArray(value, this.path, doc);\n    } else if (value && value.isMongooseArray) {\n      // We need to create a new array, otherwise change tracking will\n      // update the old doc (gh-4449)\n      value = new MongooseArray(value, this.path, doc);\n    }\n\n    const isPopulated = doc != null && doc.$__ != null && doc.populated(this.path);\n    if (isPopulated) {\n      return value;\n    }\n\n    if (this.caster && this.casterConstructor !== Mixed) {\n      try {\n        for (i = 0, l = value.length; i < l; i++) {\n          value[i] = this.caster.cast(value[i], doc, init);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path, e);\n      }\n    }\n\n    return value;\n  }\n\n  if (init || SchemaArray.options.castNonArrays) {\n    // gh-2442: if we're loading this from the db and its not an array, mark\n    // the whole array as modified.\n    if (!!doc && !!init) {\n      doc.markModified(this.path);\n    }\n    return this.cast([value], doc, init);\n  }\n\n  throw new CastError('Array', util.inspect(value), this.path);\n};\n\n/*!\n * Ignore\n */\n\nSchemaArray.prototype.discriminator = function(name, schema) {\n  let arr = this; // eslint-disable-line consistent-this\n  while (arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {\n    arr = arr.casterConstructor;\n    if (arr == null || typeof arr === 'function') {\n      throw new MongooseError('You can only add an embedded discriminator on ' +\n        'a document array, ' + this.path + ' is a plain array');\n    }\n  }\n  return arr.discriminator(name, schema);\n};\n\n/*!\n * ignore\n */\n\nSchemaArray.prototype.clone = function() {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, this.caster, options, this.schemaOptions);\n  schematype.validators = this.validators.slice();\n  return schematype;\n};\n\n/**\n * Casts values for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaArray.prototype.castForQuery = function($conditional, value) {\n  let handler;\n  let val;\n\n  if (arguments.length === 2) {\n    handler = this.$conditionalHandlers[$conditional];\n\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with Array.');\n    }\n\n    val = handler.call(this, value);\n  } else {\n    val = $conditional;\n    let Constructor = this.casterConstructor;\n\n    if (val &&\n        Constructor.discriminators &&\n        Constructor.schema &&\n        Constructor.schema.options &&\n        Constructor.schema.options.discriminatorKey) {\n      if (typeof val[Constructor.schema.options.discriminatorKey] === 'string' &&\n          Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]]) {\n        Constructor = Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]];\n      } else {\n        const constructorByValue = getDiscriminatorByValue(Constructor, val[Constructor.schema.options.discriminatorKey]);\n        if (constructorByValue) {\n          Constructor = constructorByValue;\n        }\n      }\n    }\n\n    const proto = this.casterConstructor.prototype;\n    let method = proto && (proto.castForQuery || proto.cast);\n    if (!method && Constructor.castForQuery) {\n      method = Constructor.castForQuery;\n    }\n    const caster = this.caster;\n\n    if (Array.isArray(val)) {\n      this.setters.reverse().forEach(setter => {\n        val = setter.call(this, val, this);\n      });\n      val = val.map(function(v) {\n        if (utils.isObject(v) && v.$elemMatch) {\n          return v;\n        }\n        if (method) {\n          v = method.call(caster, v);\n          return v;\n        }\n        if (v != null) {\n          v = new Constructor(v);\n          return v;\n        }\n        return v;\n      });\n    } else if (method) {\n      val = method.call(caster, val);\n    } else if (val != null) {\n      val = new Constructor(val);\n    }\n  }\n\n  return val;\n};\n\nfunction cast$all(val) {\n  if (!Array.isArray(val)) {\n    val = [val];\n  }\n\n  val = val.map(function(v) {\n    if (utils.isObject(v)) {\n      const o = {};\n      o[this.path] = v;\n      return cast(this.casterConstructor.schema, o)[this.path];\n    }\n    return v;\n  }, this);\n\n  return this.castForQuery(val);\n}\n\nfunction cast$elemMatch(val) {\n  const keys = Object.keys(val);\n  const numKeys = keys.length;\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    const value = val[key];\n    if (key.startsWith('$') && value) {\n      val[key] = this.castForQuery(key, value);\n    }\n  }\n\n  // Is this an embedded discriminator and is the discriminator key set?\n  // If so, use the discriminator schema. See gh-7449\n  const discriminatorKey = get(this,\n    'casterConstructor.schema.options.discriminatorKey');\n  const discriminators = get(this, 'casterConstructor.schema.discriminators', {});\n  if (discriminatorKey != null &&\n      val[discriminatorKey] != null &&\n      discriminators[val[discriminatorKey]] != null) {\n    return cast(discriminators[val[discriminatorKey]], val);\n  }\n\n  return cast(this.casterConstructor.schema, val);\n}\n\nconst handle = SchemaArray.prototype.$conditionalHandlers = {};\n\nhandle.$all = cast$all;\nhandle.$options = String;\nhandle.$elemMatch = cast$elemMatch;\nhandle.$geoIntersects = geospatial.cast$geoIntersects;\nhandle.$or = handle.$and = function(val) {\n  if (!Array.isArray(val)) {\n    throw new TypeError('conditional $or/$and require array');\n  }\n\n  const ret = [];\n  for (let i = 0; i < val.length; ++i) {\n    ret.push(cast(this.casterConstructor.schema, val[i]));\n  }\n\n  return ret;\n};\n\nhandle.$near =\nhandle.$nearSphere = geospatial.cast$near;\n\nhandle.$within =\nhandle.$geoWithin = geospatial.cast$within;\n\nhandle.$size =\nhandle.$minDistance =\nhandle.$maxDistance = castToNumber;\n\nhandle.$exists = $exists;\nhandle.$type = $type;\n\nhandle.$eq =\nhandle.$gt =\nhandle.$gte =\nhandle.$lt =\nhandle.$lte =\nhandle.$ne =\nhandle.$regex = SchemaArray.prototype.castForQuery;\n\n// `$in` is special because you can also include an empty array in the query\n// like `$in: [1, []]`, see gh-5913\nhandle.$nin = SchemaType.prototype.$conditionalHandlers.$nin;\nhandle.$in = SchemaType.prototype.$conditionalHandlers.$in;\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaArray;\n"]},"metadata":{},"sourceType":"script"}