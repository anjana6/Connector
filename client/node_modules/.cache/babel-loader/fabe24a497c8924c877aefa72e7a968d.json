{"ast":null,"code":"'use strict';\n\nconst defineKey = require('../document/compile').defineKey;\n\nconst get = require('../get');\n\nconst utils = require('../../utils');\n\nconst CUSTOMIZABLE_DISCRIMINATOR_OPTIONS = {\n  toJSON: true,\n  toObject: true,\n  _id: true,\n  id: true\n};\n/*!\n * ignore\n */\n\nmodule.exports = function discriminator(model, name, schema, tiedValue, applyPlugins) {\n  if (!(schema && schema.instanceOfSchema)) {\n    throw new Error('You must pass a valid discriminator Schema');\n  }\n\n  if (model.schema.discriminatorMapping && !model.schema.discriminatorMapping.isRoot) {\n    throw new Error('Discriminator \"' + name + '\" can only be a discriminator of the root model');\n  }\n\n  if (applyPlugins) {\n    const applyPluginsToDiscriminators = get(model.base, 'options.applyPluginsToDiscriminators', false); // Even if `applyPluginsToDiscriminators` isn't set, we should still apply\n    // global plugins to schemas embedded in the discriminator schema (gh-7370)\n\n    model.base._applyPlugins(schema, {\n      skipTopLevel: !applyPluginsToDiscriminators\n    });\n  }\n\n  const key = model.schema.options.discriminatorKey;\n  const existingPath = model.schema.path(key);\n\n  if (existingPath != null) {\n    if (!utils.hasUserDefinedProperty(existingPath.options, 'select')) {\n      existingPath.options.select = true;\n    }\n\n    existingPath.options.$skipDiscriminatorCheck = true;\n  } else {\n    const baseSchemaAddition = {};\n    baseSchemaAddition[key] = {\n      default: void 0,\n      select: true,\n      $skipDiscriminatorCheck: true\n    };\n    baseSchemaAddition[key][model.schema.options.typeKey] = String;\n    model.schema.add(baseSchemaAddition);\n    defineKey(key, null, model.prototype, null, [key], model.schema.options);\n  }\n\n  if (schema.path(key) && schema.path(key).options.$skipDiscriminatorCheck !== true) {\n    throw new Error('Discriminator \"' + name + '\" cannot have field with name \"' + key + '\"');\n  }\n\n  let value = name;\n\n  if (typeof tiedValue == 'string' && tiedValue.length) {\n    value = tiedValue;\n  }\n\n  function merge(schema, baseSchema) {\n    // Retain original schema before merging base schema\n    schema._baseSchema = baseSchema;\n\n    if (baseSchema.paths._id && baseSchema.paths._id.options && !baseSchema.paths._id.options.auto) {\n      const originalSchema = schema;\n      utils.merge(schema, originalSchema);\n      delete schema.paths._id;\n      delete schema.tree._id;\n    } // Find conflicting paths: if something is a path in the base schema\n    // and a nested path in the child schema, overwrite the base schema path.\n    // See gh-6076\n\n\n    const baseSchemaPaths = Object.keys(baseSchema.paths);\n    const conflictingPaths = [];\n\n    for (let i = 0; i < baseSchemaPaths.length; ++i) {\n      if (schema.nested[baseSchemaPaths[i]]) {\n        conflictingPaths.push(baseSchemaPaths[i]);\n      }\n    }\n\n    utils.merge(schema, baseSchema, {\n      omit: {\n        discriminators: true\n      },\n      omitNested: conflictingPaths.reduce((cur, path) => {\n        cur['tree.' + path] = true;\n        return cur;\n      }, {})\n    }); // Clean up conflicting paths _after_ merging re: gh-6076\n\n    for (let i = 0; i < conflictingPaths.length; ++i) {\n      delete schema.paths[conflictingPaths[i]];\n    } // Rebuild schema models because schemas may have been merged re: #7884\n\n\n    schema.childSchemas.forEach(obj => {\n      obj.model.prototype.$__setSchema(obj.schema);\n    });\n    const obj = {};\n    obj[key] = {\n      default: value,\n      select: true,\n      set: function (newName) {\n        if (newName === value) {\n          return value;\n        }\n\n        throw new Error('Can\\'t set discriminator key \"' + key + '\"');\n      },\n      $skipDiscriminatorCheck: true\n    };\n    obj[key][schema.options.typeKey] = existingPath ? existingPath.instance : String;\n    schema.add(obj);\n    schema.discriminatorMapping = {\n      key: key,\n      value: value,\n      isRoot: false\n    };\n\n    if (baseSchema.options.collection) {\n      schema.options.collection = baseSchema.options.collection;\n    }\n\n    const toJSON = schema.options.toJSON;\n    const toObject = schema.options.toObject;\n    const _id = schema.options._id;\n    const id = schema.options.id;\n    const keys = Object.keys(schema.options);\n    schema.options.discriminatorKey = baseSchema.options.discriminatorKey;\n\n    for (let i = 0; i < keys.length; ++i) {\n      const _key = keys[i];\n\n      if (!CUSTOMIZABLE_DISCRIMINATOR_OPTIONS[_key]) {\n        if (!utils.deepEqual(schema.options[_key], baseSchema.options[_key])) {\n          throw new Error('Can\\'t customize discriminator option ' + _key + ' (can only modify ' + Object.keys(CUSTOMIZABLE_DISCRIMINATOR_OPTIONS).join(', ') + ')');\n        }\n      }\n    }\n\n    schema.options = utils.clone(baseSchema.options);\n    if (toJSON) schema.options.toJSON = toJSON;\n    if (toObject) schema.options.toObject = toObject;\n\n    if (typeof _id !== 'undefined') {\n      schema.options._id = _id;\n    }\n\n    schema.options.id = id;\n    schema.s.hooks = model.schema.s.hooks.merge(schema.s.hooks);\n    schema.plugins = Array.prototype.slice(baseSchema.plugins);\n    schema.callQueue = baseSchema.callQueue.concat(schema.callQueue);\n    delete schema._requiredpaths; // reset just in case Schema#requiredPaths() was called on either schema\n  } // merges base schema into new discriminator schema and sets new type field.\n\n\n  merge(schema, model.schema);\n\n  if (!model.discriminators) {\n    model.discriminators = {};\n  }\n\n  if (!model.schema.discriminatorMapping) {\n    model.schema.discriminatorMapping = {\n      key: key,\n      value: null,\n      isRoot: true\n    };\n  }\n\n  if (!model.schema.discriminators) {\n    model.schema.discriminators = {};\n  }\n\n  model.schema.discriminators[name] = schema;\n\n  if (model.discriminators[name]) {\n    throw new Error('Discriminator with name \"' + name + '\" already exists');\n  }\n\n  return schema;\n};","map":{"version":3,"sources":["D:/Other/Git/Developer-Connector/node_modules/mongoose/lib/helpers/model/discriminator.js"],"names":["defineKey","require","get","utils","CUSTOMIZABLE_DISCRIMINATOR_OPTIONS","toJSON","toObject","_id","id","module","exports","discriminator","model","name","schema","tiedValue","applyPlugins","instanceOfSchema","Error","discriminatorMapping","isRoot","applyPluginsToDiscriminators","base","_applyPlugins","skipTopLevel","key","options","discriminatorKey","existingPath","path","hasUserDefinedProperty","select","$skipDiscriminatorCheck","baseSchemaAddition","default","typeKey","String","add","prototype","value","length","merge","baseSchema","_baseSchema","paths","auto","originalSchema","tree","baseSchemaPaths","Object","keys","conflictingPaths","i","nested","push","omit","discriminators","omitNested","reduce","cur","childSchemas","forEach","obj","$__setSchema","set","newName","instance","collection","_key","deepEqual","join","clone","s","hooks","plugins","Array","slice","callQueue","concat","_requiredpaths"],"mappings":"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","sourcesContent":["'use strict';\n\nconst defineKey = require('../document/compile').defineKey;\nconst get = require('../get');\nconst utils = require('../../utils');\n\nconst CUSTOMIZABLE_DISCRIMINATOR_OPTIONS = {\n  toJSON: true,\n  toObject: true,\n  _id: true,\n  id: true\n};\n\n/*!\n * ignore\n */\n\nmodule.exports = function discriminator(model, name, schema, tiedValue, applyPlugins) {\n  if (!(schema && schema.instanceOfSchema)) {\n    throw new Error('You must pass a valid discriminator Schema');\n  }\n\n  if (model.schema.discriminatorMapping &&\n      !model.schema.discriminatorMapping.isRoot) {\n    throw new Error('Discriminator \"' + name +\n        '\" can only be a discriminator of the root model');\n  }\n\n  if (applyPlugins) {\n    const applyPluginsToDiscriminators = get(model.base,\n      'options.applyPluginsToDiscriminators', false);\n    // Even if `applyPluginsToDiscriminators` isn't set, we should still apply\n    // global plugins to schemas embedded in the discriminator schema (gh-7370)\n    model.base._applyPlugins(schema, {\n      skipTopLevel: !applyPluginsToDiscriminators\n    });\n  }\n\n  const key = model.schema.options.discriminatorKey;\n\n  const existingPath = model.schema.path(key);\n  if (existingPath != null) {\n    if (!utils.hasUserDefinedProperty(existingPath.options, 'select')) {\n      existingPath.options.select = true;\n    }\n    existingPath.options.$skipDiscriminatorCheck = true;\n  } else {\n    const baseSchemaAddition = {};\n    baseSchemaAddition[key] = {\n      default: void 0,\n      select: true,\n      $skipDiscriminatorCheck: true\n    };\n    baseSchemaAddition[key][model.schema.options.typeKey] = String;\n    model.schema.add(baseSchemaAddition);\n    defineKey(key, null, model.prototype, null, [key], model.schema.options);\n  }\n\n  if (schema.path(key) && schema.path(key).options.$skipDiscriminatorCheck !== true) {\n    throw new Error('Discriminator \"' + name +\n        '\" cannot have field with name \"' + key + '\"');\n  }\n\n  let value = name;\n  if (typeof tiedValue == 'string' && tiedValue.length) {\n    value = tiedValue;\n  }\n\n  function merge(schema, baseSchema) {\n    // Retain original schema before merging base schema\n    schema._baseSchema = baseSchema;\n    if (baseSchema.paths._id &&\n        baseSchema.paths._id.options &&\n        !baseSchema.paths._id.options.auto) {\n      const originalSchema = schema;\n      utils.merge(schema, originalSchema);\n      delete schema.paths._id;\n      delete schema.tree._id;\n    }\n\n    // Find conflicting paths: if something is a path in the base schema\n    // and a nested path in the child schema, overwrite the base schema path.\n    // See gh-6076\n    const baseSchemaPaths = Object.keys(baseSchema.paths);\n    const conflictingPaths = [];\n    for (let i = 0; i < baseSchemaPaths.length; ++i) {\n      if (schema.nested[baseSchemaPaths[i]]) {\n        conflictingPaths.push(baseSchemaPaths[i]);\n      }\n    }\n\n    utils.merge(schema, baseSchema, {\n      omit: { discriminators: true },\n      omitNested: conflictingPaths.reduce((cur, path) => {\n        cur['tree.' + path] = true;\n        return cur;\n      }, {})\n    });\n\n    // Clean up conflicting paths _after_ merging re: gh-6076\n    for (let i = 0; i < conflictingPaths.length; ++i) {\n      delete schema.paths[conflictingPaths[i]];\n    }\n\n    // Rebuild schema models because schemas may have been merged re: #7884\n    schema.childSchemas.forEach(obj => {\n      obj.model.prototype.$__setSchema(obj.schema);\n    });\n\n    const obj = {};\n    obj[key] = {\n      default: value,\n      select: true,\n      set: function(newName) {\n        if (newName === value) {\n          return value;\n        }\n        throw new Error('Can\\'t set discriminator key \"' + key + '\"');\n      },\n      $skipDiscriminatorCheck: true\n    };\n    obj[key][schema.options.typeKey] = existingPath ?\n      existingPath.instance :\n      String;\n    schema.add(obj);\n    schema.discriminatorMapping = {key: key, value: value, isRoot: false};\n\n    if (baseSchema.options.collection) {\n      schema.options.collection = baseSchema.options.collection;\n    }\n\n    const toJSON = schema.options.toJSON;\n    const toObject = schema.options.toObject;\n    const _id = schema.options._id;\n    const id = schema.options.id;\n\n    const keys = Object.keys(schema.options);\n    schema.options.discriminatorKey = baseSchema.options.discriminatorKey;\n\n    for (let i = 0; i < keys.length; ++i) {\n      const _key = keys[i];\n      if (!CUSTOMIZABLE_DISCRIMINATOR_OPTIONS[_key]) {\n        if (!utils.deepEqual(schema.options[_key], baseSchema.options[_key])) {\n          throw new Error('Can\\'t customize discriminator option ' + _key +\n              ' (can only modify ' +\n              Object.keys(CUSTOMIZABLE_DISCRIMINATOR_OPTIONS).join(', ') +\n              ')');\n        }\n      }\n    }\n\n    schema.options = utils.clone(baseSchema.options);\n    if (toJSON) schema.options.toJSON = toJSON;\n    if (toObject) schema.options.toObject = toObject;\n    if (typeof _id !== 'undefined') {\n      schema.options._id = _id;\n    }\n    schema.options.id = id;\n    schema.s.hooks = model.schema.s.hooks.merge(schema.s.hooks);\n\n    schema.plugins = Array.prototype.slice(baseSchema.plugins);\n    schema.callQueue = baseSchema.callQueue.concat(schema.callQueue);\n    delete schema._requiredpaths; // reset just in case Schema#requiredPaths() was called on either schema\n  }\n\n  // merges base schema into new discriminator schema and sets new type field.\n  merge(schema, model.schema);\n\n  if (!model.discriminators) {\n    model.discriminators = {};\n  }\n\n  if (!model.schema.discriminatorMapping) {\n    model.schema.discriminatorMapping = {key: key, value: null, isRoot: true};\n  }\n  if (!model.schema.discriminators) {\n    model.schema.discriminators = {};\n  }\n\n  model.schema.discriminators[name] = schema;\n\n  if (model.discriminators[name]) {\n    throw new Error('Discriminator with name \"' + name + '\" already exists');\n  }\n\n  return schema;\n};\n"]},"metadata":{},"sourceType":"script"}