{"ast":null,"code":"/*!\n * Module requirements.\n */\n'use strict';\n\nconst MongooseError = require('../error/index');\n\nconst SchemaDateOptions = require('../options/SchemaDateOptions');\n\nconst SchemaType = require('../schematype');\n\nconst castDate = require('../cast/date');\n\nconst utils = require('../utils');\n\nconst CastError = SchemaType.CastError;\n/**\n * Date SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaDate(key, options) {\n  SchemaType.call(this, key, options, 'Date');\n}\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\n\n\nSchemaDate.schemaName = 'Date';\n/*!\n * Inherits from SchemaType.\n */\n\nSchemaDate.prototype = Object.create(SchemaType.prototype);\nSchemaDate.prototype.constructor = SchemaDate;\nSchemaDate.prototype.OptionsConstructor = SchemaDateOptions;\n/*!\n * ignore\n */\n\nSchemaDate._cast = castDate;\n/**\n * Get/set the function used to cast arbitrary values to dates.\n *\n * ####Example:\n *\n *     // Mongoose converts empty string '' into `null` for date types. You\n *     // can create a custom caster to disable it.\n *     const original = mongoose.Schema.Types.Date.cast();\n *     mongoose.Schema.Types.Date.cast(v => {\n *       assert.ok(v !== '');\n *       return original(v);\n *     });\n *\n *     // Or disable casting entirely\n *     mongoose.Schema.Types.Date.cast(false);\n *\n * @param {Function} caster\n * @return {Function}\n * @function get\n * @static\n * @api public\n */\n\nSchemaDate.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n\n  if (caster === false) {\n    caster = v => {\n      if (v != null && !(v instanceof Date)) {\n        throw new Error();\n      }\n\n      return v;\n    };\n  }\n\n  this._cast = caster;\n  return this._cast;\n};\n/**\n * Declares a TTL index (rounded to the nearest second) for _Date_ types only.\n *\n * This sets the `expireAfterSeconds` index option available in MongoDB >= 2.1.2.\n * This index type is only compatible with Date types.\n *\n * ####Example:\n *\n *     // expire in 24 hours\n *     new Schema({ createdAt: { type: Date, expires: 60*60*24 }});\n *\n * `expires` utilizes the `ms` module from [guille](https://github.com/guille/) allowing us to use a friendlier syntax:\n *\n * ####Example:\n *\n *     // expire in 24 hours\n *     new Schema({ createdAt: { type: Date, expires: '24h' }});\n *\n *     // expire in 1.5 hours\n *     new Schema({ createdAt: { type: Date, expires: '1.5h' }});\n *\n *     // expire in 7 days\n *     var schema = new Schema({ createdAt: Date });\n *     schema.path('createdAt').expires('7d');\n *\n * @param {Number|String} when\n * @added 3.0.0\n * @return {SchemaType} this\n * @api public\n */\n\n\nSchemaDate.prototype.expires = function (when) {\n  if (!this._index || this._index.constructor.name !== 'Object') {\n    this._index = {};\n  }\n\n  this._index.expires = when;\n  utils.expires(this._index);\n  return this;\n};\n/*!\n * ignore\n */\n\n\nSchemaDate._checkRequired = v => v instanceof Date;\n/**\n * Override the function the required validator uses to check whether a string\n * passes the `required` check.\n *\n * ####Example:\n *\n *     // Allow empty strings to pass `required` check\n *     mongoose.Schema.Types.String.checkRequired(v => v != null);\n *\n *     const M = mongoose.model({ str: { type: String, required: true } });\n *     new M({ str: '' }).validateSync(); // `null`, validation passes!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\n\nSchemaDate.checkRequired = SchemaType.checkRequired;\n/**\n * Check if the given value satisfies a required validator. To satisfy\n * a required validator, the given value must be an instance of `Date`.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaDate.prototype.checkRequired = function (value, doc) {\n  if (SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  } // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n\n\n  const _checkRequired = typeof this.constructor.checkRequired == 'function' ? this.constructor.checkRequired() : SchemaDate.checkRequired();\n\n  return _checkRequired(value);\n};\n/**\n * Sets a minimum date validator.\n *\n * ####Example:\n *\n *     var s = new Schema({ d: { type: Date, min: Date('1970-01-01') })\n *     var M = db.model('M', s)\n *     var m = new M({ d: Date('1969-12-31') })\n *     m.save(function (err) {\n *       console.error(err) // validator error\n *       m.d = Date('2014-12-08');\n *       m.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MIN} token which will be replaced with the invalid value\n *     var min = [Date('1970-01-01'), 'The value of path `{PATH}` ({VALUE}) is beneath the limit ({MIN}).'];\n *     var schema = new Schema({ d: { type: Date, min: min })\n *     var M = mongoose.model('M', schema);\n *     var s= new M({ d: Date('1969-12-31') });\n *     s.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `d` (1969-12-31) is before the limit (1970-01-01).\n *     })\n *\n * @param {Date} value minimum date\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages #error_messages_MongooseError-messages\n * @api public\n */\n\n\nSchemaDate.prototype.min = function (value, message) {\n  if (this.minValidator) {\n    this.validators = this.validators.filter(function (v) {\n      return v.validator !== this.minValidator;\n    }, this);\n  }\n\n  if (value) {\n    let msg = message || MongooseError.messages.Date.min;\n    msg = msg.replace(/{MIN}/, value === Date.now ? 'Date.now()' : value.toString());\n\n    const _this = this;\n\n    this.validators.push({\n      validator: this.minValidator = function (val) {\n        let _value = value;\n\n        if (typeof value === 'function' && value !== Date.now) {\n          _value = _value.call(this);\n        }\n\n        const min = _value === Date.now ? _value() : _this.cast(_value);\n        return val === null || val.valueOf() >= min.valueOf();\n      },\n      message: msg,\n      type: 'min',\n      min: value\n    });\n  }\n\n  return this;\n};\n/**\n * Sets a maximum date validator.\n *\n * ####Example:\n *\n *     var s = new Schema({ d: { type: Date, max: Date('2014-01-01') })\n *     var M = db.model('M', s)\n *     var m = new M({ d: Date('2014-12-08') })\n *     m.save(function (err) {\n *       console.error(err) // validator error\n *       m.d = Date('2013-12-31');\n *       m.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MAX} token which will be replaced with the invalid value\n *     var max = [Date('2014-01-01'), 'The value of path `{PATH}` ({VALUE}) exceeds the limit ({MAX}).'];\n *     var schema = new Schema({ d: { type: Date, max: max })\n *     var M = mongoose.model('M', schema);\n *     var s= new M({ d: Date('2014-12-08') });\n *     s.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `d` (2014-12-08) exceeds the limit (2014-01-01).\n *     })\n *\n * @param {Date} maximum date\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages #error_messages_MongooseError-messages\n * @api public\n */\n\n\nSchemaDate.prototype.max = function (value, message) {\n  if (this.maxValidator) {\n    this.validators = this.validators.filter(function (v) {\n      return v.validator !== this.maxValidator;\n    }, this);\n  }\n\n  if (value) {\n    let msg = message || MongooseError.messages.Date.max;\n    msg = msg.replace(/{MAX}/, value === Date.now ? 'Date.now()' : value.toString());\n\n    const _this = this;\n\n    this.validators.push({\n      validator: this.maxValidator = function (val) {\n        let _value = value;\n\n        if (typeof _value === 'function' && _value !== Date.now) {\n          _value = _value.call(this);\n        }\n\n        const max = _value === Date.now ? _value() : _this.cast(_value);\n        return val === null || val.valueOf() <= max.valueOf();\n      },\n      message: msg,\n      type: 'max',\n      max: value\n    });\n  }\n\n  return this;\n};\n/**\n * Casts to date\n *\n * @param {Object} value to cast\n * @api private\n */\n\n\nSchemaDate.prototype.cast = function (value) {\n  const castDate = typeof this.constructor.cast === 'function' ? this.constructor.cast() : SchemaDate.cast();\n\n  try {\n    return castDate(value);\n  } catch (error) {\n    throw new CastError('date', value, this.path);\n  }\n};\n/*!\n * Date Query casting.\n *\n * @api private\n */\n\n\nfunction handleSingle(val) {\n  return this.cast(val);\n}\n\nSchemaDate.prototype.$conditionalHandlers = utils.options(SchemaType.prototype.$conditionalHandlers, {\n  $gt: handleSingle,\n  $gte: handleSingle,\n  $lt: handleSingle,\n  $lte: handleSingle\n});\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaDate.prototype.castForQuery = function ($conditional, val) {\n  if (arguments.length !== 2) {\n    return this._castForQuery($conditional);\n  }\n\n  const handler = this.$conditionalHandlers[$conditional];\n\n  if (!handler) {\n    throw new Error('Can\\'t use ' + $conditional + ' with Date.');\n  }\n\n  return handler.call(this, val);\n};\n/*!\n * Module exports.\n */\n\n\nmodule.exports = SchemaDate;","map":{"version":3,"sources":["D:/Other/Git/Developer-Connector/node_modules/mongoose/lib/schema/date.js"],"names":["MongooseError","require","SchemaDateOptions","SchemaType","castDate","utils","CastError","SchemaDate","key","options","call","schemaName","prototype","Object","create","constructor","OptionsConstructor","_cast","cast","caster","arguments","length","v","Date","Error","expires","when","_index","name","_checkRequired","checkRequired","value","doc","_isRef","min","message","minValidator","validators","filter","validator","msg","messages","replace","now","toString","_this","push","val","_value","valueOf","type","max","maxValidator","error","path","handleSingle","$conditionalHandlers","$gt","$gte","$lt","$lte","castForQuery","$conditional","_castForQuery","handler","module","exports"],"mappings":"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","sourcesContent":["/*!\n * Module requirements.\n */\n\n'use strict';\n\nconst MongooseError = require('../error/index');\nconst SchemaDateOptions = require('../options/SchemaDateOptions');\nconst SchemaType = require('../schematype');\nconst castDate = require('../cast/date');\nconst utils = require('../utils');\n\nconst CastError = SchemaType.CastError;\n\n/**\n * Date SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaDate(key, options) {\n  SchemaType.call(this, key, options, 'Date');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaDate.schemaName = 'Date';\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaDate.prototype = Object.create(SchemaType.prototype);\nSchemaDate.prototype.constructor = SchemaDate;\nSchemaDate.prototype.OptionsConstructor = SchemaDateOptions;\n\n/*!\n * ignore\n */\n\nSchemaDate._cast = castDate;\n\n/**\n * Get/set the function used to cast arbitrary values to dates.\n *\n * ####Example:\n *\n *     // Mongoose converts empty string '' into `null` for date types. You\n *     // can create a custom caster to disable it.\n *     const original = mongoose.Schema.Types.Date.cast();\n *     mongoose.Schema.Types.Date.cast(v => {\n *       assert.ok(v !== '');\n *       return original(v);\n *     });\n *\n *     // Or disable casting entirely\n *     mongoose.Schema.Types.Date.cast(false);\n *\n * @param {Function} caster\n * @return {Function}\n * @function get\n * @static\n * @api public\n */\n\nSchemaDate.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = v => {\n      if (v != null && !(v instanceof Date)) {\n        throw new Error();\n      }\n      return v;\n    };\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/**\n * Declares a TTL index (rounded to the nearest second) for _Date_ types only.\n *\n * This sets the `expireAfterSeconds` index option available in MongoDB >= 2.1.2.\n * This index type is only compatible with Date types.\n *\n * ####Example:\n *\n *     // expire in 24 hours\n *     new Schema({ createdAt: { type: Date, expires: 60*60*24 }});\n *\n * `expires` utilizes the `ms` module from [guille](https://github.com/guille/) allowing us to use a friendlier syntax:\n *\n * ####Example:\n *\n *     // expire in 24 hours\n *     new Schema({ createdAt: { type: Date, expires: '24h' }});\n *\n *     // expire in 1.5 hours\n *     new Schema({ createdAt: { type: Date, expires: '1.5h' }});\n *\n *     // expire in 7 days\n *     var schema = new Schema({ createdAt: Date });\n *     schema.path('createdAt').expires('7d');\n *\n * @param {Number|String} when\n * @added 3.0.0\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaDate.prototype.expires = function(when) {\n  if (!this._index || this._index.constructor.name !== 'Object') {\n    this._index = {};\n  }\n\n  this._index.expires = when;\n  utils.expires(this._index);\n  return this;\n};\n\n/*!\n * ignore\n */\n\nSchemaDate._checkRequired = v => v instanceof Date;\n\n/**\n * Override the function the required validator uses to check whether a string\n * passes the `required` check.\n *\n * ####Example:\n *\n *     // Allow empty strings to pass `required` check\n *     mongoose.Schema.Types.String.checkRequired(v => v != null);\n *\n *     const M = mongoose.model({ str: { type: String, required: true } });\n *     new M({ str: '' }).validateSync(); // `null`, validation passes!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaDate.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies a required validator. To satisfy\n * a required validator, the given value must be an instance of `Date`.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaDate.prototype.checkRequired = function(value, doc) {\n  if (SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired == 'function' ?\n    this.constructor.checkRequired() :\n    SchemaDate.checkRequired();\n  return _checkRequired(value);\n};\n\n/**\n * Sets a minimum date validator.\n *\n * ####Example:\n *\n *     var s = new Schema({ d: { type: Date, min: Date('1970-01-01') })\n *     var M = db.model('M', s)\n *     var m = new M({ d: Date('1969-12-31') })\n *     m.save(function (err) {\n *       console.error(err) // validator error\n *       m.d = Date('2014-12-08');\n *       m.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MIN} token which will be replaced with the invalid value\n *     var min = [Date('1970-01-01'), 'The value of path `{PATH}` ({VALUE}) is beneath the limit ({MIN}).'];\n *     var schema = new Schema({ d: { type: Date, min: min })\n *     var M = mongoose.model('M', schema);\n *     var s= new M({ d: Date('1969-12-31') });\n *     s.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `d` (1969-12-31) is before the limit (1970-01-01).\n *     })\n *\n * @param {Date} value minimum date\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages #error_messages_MongooseError-messages\n * @api public\n */\n\nSchemaDate.prototype.min = function(value, message) {\n  if (this.minValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.minValidator;\n    }, this);\n  }\n\n  if (value) {\n    let msg = message || MongooseError.messages.Date.min;\n    msg = msg.replace(/{MIN}/, (value === Date.now ? 'Date.now()' : value.toString()));\n    const _this = this;\n    this.validators.push({\n      validator: this.minValidator = function(val) {\n        let _value = value;\n        if (typeof value === 'function' && value !== Date.now) {\n          _value = _value.call(this);\n        }\n        const min = (_value === Date.now ? _value() : _this.cast(_value));\n        return val === null || val.valueOf() >= min.valueOf();\n      },\n      message: msg,\n      type: 'min',\n      min: value\n    });\n  }\n\n  return this;\n};\n\n/**\n * Sets a maximum date validator.\n *\n * ####Example:\n *\n *     var s = new Schema({ d: { type: Date, max: Date('2014-01-01') })\n *     var M = db.model('M', s)\n *     var m = new M({ d: Date('2014-12-08') })\n *     m.save(function (err) {\n *       console.error(err) // validator error\n *       m.d = Date('2013-12-31');\n *       m.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MAX} token which will be replaced with the invalid value\n *     var max = [Date('2014-01-01'), 'The value of path `{PATH}` ({VALUE}) exceeds the limit ({MAX}).'];\n *     var schema = new Schema({ d: { type: Date, max: max })\n *     var M = mongoose.model('M', schema);\n *     var s= new M({ d: Date('2014-12-08') });\n *     s.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `d` (2014-12-08) exceeds the limit (2014-01-01).\n *     })\n *\n * @param {Date} maximum date\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages #error_messages_MongooseError-messages\n * @api public\n */\n\nSchemaDate.prototype.max = function(value, message) {\n  if (this.maxValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.maxValidator;\n    }, this);\n  }\n\n  if (value) {\n    let msg = message || MongooseError.messages.Date.max;\n    msg = msg.replace(/{MAX}/, (value === Date.now ? 'Date.now()' : value.toString()));\n    const _this = this;\n    this.validators.push({\n      validator: this.maxValidator = function(val) {\n        let _value = value;\n        if (typeof _value === 'function' && _value !== Date.now) {\n          _value = _value.call(this);\n        }\n        const max = (_value === Date.now ? _value() : _this.cast(_value));\n        return val === null || val.valueOf() <= max.valueOf();\n      },\n      message: msg,\n      type: 'max',\n      max: value\n    });\n  }\n\n  return this;\n};\n\n/**\n * Casts to date\n *\n * @param {Object} value to cast\n * @api private\n */\n\nSchemaDate.prototype.cast = function(value) {\n  const castDate = typeof this.constructor.cast === 'function' ?\n    this.constructor.cast() :\n    SchemaDate.cast();\n  try {\n    return castDate(value);\n  } catch (error) {\n    throw new CastError('date', value, this.path);\n  }\n};\n\n/*!\n * Date Query casting.\n *\n * @api private\n */\n\nfunction handleSingle(val) {\n  return this.cast(val);\n}\n\nSchemaDate.prototype.$conditionalHandlers =\n    utils.options(SchemaType.prototype.$conditionalHandlers, {\n      $gt: handleSingle,\n      $gte: handleSingle,\n      $lt: handleSingle,\n      $lte: handleSingle\n    });\n\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaDate.prototype.castForQuery = function($conditional, val) {\n  if (arguments.length !== 2) {\n    return this._castForQuery($conditional);\n  }\n\n  const handler = this.$conditionalHandlers[$conditional];\n\n  if (!handler) {\n    throw new Error('Can\\'t use ' + $conditional + ' with Date.');\n  }\n\n  return handler.call(this, val);\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaDate;\n"]},"metadata":{},"sourceType":"script"}