{"ast":null,"code":"'use strict';\n/*!\n * Module dependencies.\n */\n\nconst StrictModeError = require('./error/strict');\n\nconst Types = require('./schema/index');\n\nconst castTextSearch = require('./schema/operators/text');\n\nconst get = require('./helpers/get');\n\nconst util = require('util');\n\nconst utils = require('./utils');\n\nconst ALLOWED_GEOWITHIN_GEOJSON_TYPES = ['Polygon', 'MultiPolygon'];\n/**\n * Handles internal casting for query filters.\n *\n * @param {Schema} schema\n * @param {Object} obj Object to cast\n * @param {Object} options the query options\n * @param {Query} context passed to setters\n * @api private\n */\n\nmodule.exports = function cast(schema, obj, options, context) {\n  if (Array.isArray(obj)) {\n    throw new Error('Query filter must be an object, got an array ', util.inspect(obj));\n  } // bson 1.x has the unfortunate tendency to remove filters that have a top-level\n  // `_bsontype` property. But we should still allow ObjectIds because\n  // `Collection#find()` has a special case to support `find(objectid)`.\n  // Should remove this when we upgrade to bson 4.x. See gh-8222, gh-8268\n\n\n  if (obj.hasOwnProperty('_bsontype') && obj._bsontype !== 'ObjectID') {\n    delete obj._bsontype;\n  }\n\n  const paths = Object.keys(obj);\n  let i = paths.length;\n\n  let _keys;\n\n  let any$conditionals;\n  let schematype;\n  let nested;\n  let path;\n  let type;\n  let val;\n  options = options || {};\n\n  while (i--) {\n    path = paths[i];\n    val = obj[path];\n\n    if (path === '$or' || path === '$nor' || path === '$and') {\n      let k = val.length;\n\n      while (k--) {\n        val[k] = cast(schema, val[k], options, context);\n      }\n    } else if (path === '$where') {\n      type = typeof val;\n\n      if (type !== 'string' && type !== 'function') {\n        throw new Error('Must have a string or function for $where');\n      }\n\n      if (type === 'function') {\n        obj[path] = val.toString();\n      }\n\n      continue;\n    } else if (path === '$elemMatch') {\n      val = cast(schema, val, options, context);\n    } else if (path === '$text') {\n      val = castTextSearch(val, path);\n    } else {\n      if (!schema) {\n        // no casting for Mixed types\n        continue;\n      }\n\n      schematype = schema.path(path); // Check for embedded discriminator paths\n\n      if (!schematype) {\n        const split = path.split('.');\n        let j = split.length;\n\n        while (j--) {\n          const pathFirstHalf = split.slice(0, j).join('.');\n          const pathLastHalf = split.slice(j).join('.');\n\n          const _schematype = schema.path(pathFirstHalf);\n\n          const discriminatorKey = get(_schematype, 'schema.options.discriminatorKey'); // gh-6027: if we haven't found the schematype but this path is\n          // underneath an embedded discriminator and the embedded discriminator\n          // key is in the query, use the embedded discriminator schema\n\n          if (_schematype != null && get(_schematype, 'schema.discriminators') != null && discriminatorKey != null && pathLastHalf !== discriminatorKey) {\n            const discriminatorVal = get(obj, pathFirstHalf + '.' + discriminatorKey);\n\n            if (discriminatorVal != null) {\n              schematype = _schematype.schema.discriminators[discriminatorVal].path(pathLastHalf);\n            }\n          }\n        }\n      }\n\n      if (!schematype) {\n        // Handle potential embedded array queries\n        const split = path.split('.');\n        let j = split.length;\n        let pathFirstHalf;\n        let pathLastHalf;\n        let remainingConds; // Find the part of the var path that is a path of the Schema\n\n        while (j--) {\n          pathFirstHalf = split.slice(0, j).join('.');\n          schematype = schema.path(pathFirstHalf);\n\n          if (schematype) {\n            break;\n          }\n        } // If a substring of the input path resolves to an actual real path...\n\n\n        if (schematype) {\n          // Apply the casting; similar code for $elemMatch in schema/array.js\n          if (schematype.caster && schematype.caster.schema) {\n            remainingConds = {};\n            pathLastHalf = split.slice(j).join('.');\n            remainingConds[pathLastHalf] = val;\n            obj[path] = cast(schematype.caster.schema, remainingConds, options, context)[pathLastHalf];\n          } else {\n            obj[path] = val;\n          }\n\n          continue;\n        }\n\n        if (utils.isObject(val)) {\n          // handle geo schemas that use object notation\n          // { loc: { long: Number, lat: Number }\n          let geo = '';\n\n          if (val.$near) {\n            geo = '$near';\n          } else if (val.$nearSphere) {\n            geo = '$nearSphere';\n          } else if (val.$within) {\n            geo = '$within';\n          } else if (val.$geoIntersects) {\n            geo = '$geoIntersects';\n          } else if (val.$geoWithin) {\n            geo = '$geoWithin';\n          }\n\n          if (geo) {\n            const numbertype = new Types.Number('__QueryCasting__');\n            let value = val[geo];\n\n            if (val.$maxDistance != null) {\n              val.$maxDistance = numbertype.castForQueryWrapper({\n                val: val.$maxDistance,\n                context: context\n              });\n            }\n\n            if (val.$minDistance != null) {\n              val.$minDistance = numbertype.castForQueryWrapper({\n                val: val.$minDistance,\n                context: context\n              });\n            }\n\n            if (geo === '$within') {\n              const withinType = value.$center || value.$centerSphere || value.$box || value.$polygon;\n\n              if (!withinType) {\n                throw new Error('Bad $within parameter: ' + JSON.stringify(val));\n              }\n\n              value = withinType;\n            } else if (geo === '$near' && typeof value.type === 'string' && Array.isArray(value.coordinates)) {\n              // geojson; cast the coordinates\n              value = value.coordinates;\n            } else if ((geo === '$near' || geo === '$nearSphere' || geo === '$geoIntersects') && value.$geometry && typeof value.$geometry.type === 'string' && Array.isArray(value.$geometry.coordinates)) {\n              if (value.$maxDistance != null) {\n                value.$maxDistance = numbertype.castForQueryWrapper({\n                  val: value.$maxDistance,\n                  context: context\n                });\n              }\n\n              if (value.$minDistance != null) {\n                value.$minDistance = numbertype.castForQueryWrapper({\n                  val: value.$minDistance,\n                  context: context\n                });\n              }\n\n              if (utils.isMongooseObject(value.$geometry)) {\n                value.$geometry = value.$geometry.toObject({\n                  transform: false,\n                  virtuals: false\n                });\n              }\n\n              value = value.$geometry.coordinates;\n            } else if (geo === '$geoWithin') {\n              if (value.$geometry) {\n                if (utils.isMongooseObject(value.$geometry)) {\n                  value.$geometry = value.$geometry.toObject({\n                    virtuals: false\n                  });\n                }\n\n                const geoWithinType = value.$geometry.type;\n\n                if (ALLOWED_GEOWITHIN_GEOJSON_TYPES.indexOf(geoWithinType) === -1) {\n                  throw new Error('Invalid geoJSON type for $geoWithin \"' + geoWithinType + '\", must be \"Polygon\" or \"MultiPolygon\"');\n                }\n\n                value = value.$geometry.coordinates;\n              } else {\n                value = value.$box || value.$polygon || value.$center || value.$centerSphere;\n\n                if (utils.isMongooseObject(value)) {\n                  value = value.toObject({\n                    virtuals: false\n                  });\n                }\n              }\n            }\n\n            _cast(value, numbertype, context);\n\n            continue;\n          }\n        }\n\n        if (schema.nested[path]) {\n          continue;\n        }\n\n        if (options.upsert && options.strict) {\n          if (options.strict === 'throw') {\n            throw new StrictModeError(path);\n          }\n\n          throw new StrictModeError(path, 'Path \"' + path + '\" is not in ' + 'schema, strict mode is `true`, and upsert is `true`.');\n        } else if (options.strictQuery === 'throw') {\n          throw new StrictModeError(path, 'Path \"' + path + '\" is not in ' + 'schema and strictQuery is \\'throw\\'.');\n        } else if (options.strictQuery) {\n          delete obj[path];\n        }\n      } else if (val == null) {\n        continue;\n      } else if (val.constructor.name === 'Object') {\n        any$conditionals = Object.keys(val).some(function (k) {\n          return k.startsWith('$') && k !== '$id' && k !== '$ref';\n        });\n\n        if (!any$conditionals) {\n          obj[path] = schematype.castForQueryWrapper({\n            val: val,\n            context: context\n          });\n        } else {\n          const ks = Object.keys(val);\n          let $cond;\n          let k = ks.length;\n\n          while (k--) {\n            $cond = ks[k];\n            nested = val[$cond];\n\n            if ($cond === '$not') {\n              if (nested && schematype && !schematype.caster) {\n                _keys = Object.keys(nested);\n\n                if (_keys.length && _keys[0].startsWith('$')) {\n                  for (const key in nested) {\n                    nested[key] = schematype.castForQueryWrapper({\n                      $conditional: key,\n                      val: nested[key],\n                      context: context\n                    });\n                  }\n                } else {\n                  val[$cond] = schematype.castForQueryWrapper({\n                    $conditional: $cond,\n                    val: nested,\n                    context: context\n                  });\n                }\n\n                continue;\n              }\n\n              cast(schematype.caster ? schematype.caster.schema : schema, nested, options, context);\n            } else {\n              val[$cond] = schematype.castForQueryWrapper({\n                $conditional: $cond,\n                val: nested,\n                context: context\n              });\n            }\n          }\n        }\n      } else if (Array.isArray(val) && ['Buffer', 'Array'].indexOf(schematype.instance) === -1) {\n        const casted = [];\n\n        for (let valIndex = 0; valIndex < val.length; valIndex++) {\n          casted.push(schematype.castForQueryWrapper({\n            val: val[valIndex],\n            context: context\n          }));\n        }\n\n        obj[path] = {\n          $in: casted\n        };\n      } else {\n        obj[path] = schematype.castForQueryWrapper({\n          val: val,\n          context: context\n        });\n      }\n    }\n  }\n\n  return obj;\n};\n\nfunction _cast(val, numbertype, context) {\n  if (Array.isArray(val)) {\n    val.forEach(function (item, i) {\n      if (Array.isArray(item) || utils.isObject(item)) {\n        return _cast(item, numbertype, context);\n      }\n\n      val[i] = numbertype.castForQueryWrapper({\n        val: item,\n        context: context\n      });\n    });\n  } else {\n    const nearKeys = Object.keys(val);\n    let nearLen = nearKeys.length;\n\n    while (nearLen--) {\n      const nkey = nearKeys[nearLen];\n      const item = val[nkey];\n\n      if (Array.isArray(item) || utils.isObject(item)) {\n        _cast(item, numbertype, context);\n\n        val[nkey] = item;\n      } else {\n        val[nkey] = numbertype.castForQuery({\n          val: item,\n          context: context\n        });\n      }\n    }\n  }\n}","map":{"version":3,"sources":["D:/Other/Git/Developer-Connector/node_modules/mongoose/lib/cast.js"],"names":["StrictModeError","require","Types","castTextSearch","get","util","utils","ALLOWED_GEOWITHIN_GEOJSON_TYPES","module","exports","cast","schema","obj","options","context","Array","isArray","Error","inspect","hasOwnProperty","_bsontype","paths","Object","keys","i","length","_keys","any$conditionals","schematype","nested","path","type","val","k","toString","split","j","pathFirstHalf","slice","join","pathLastHalf","_schematype","discriminatorKey","discriminatorVal","discriminators","remainingConds","caster","isObject","geo","$near","$nearSphere","$within","$geoIntersects","$geoWithin","numbertype","Number","value","$maxDistance","castForQueryWrapper","$minDistance","withinType","$center","$centerSphere","$box","$polygon","JSON","stringify","coordinates","$geometry","isMongooseObject","toObject","transform","virtuals","geoWithinType","indexOf","_cast","upsert","strict","strictQuery","constructor","name","some","startsWith","ks","$cond","key","$conditional","instance","casted","valIndex","push","$in","forEach","item","nearKeys","nearLen","nkey","castForQuery"],"mappings":"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","sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst StrictModeError = require('./error/strict');\nconst Types = require('./schema/index');\nconst castTextSearch = require('./schema/operators/text');\nconst get = require('./helpers/get');\nconst util = require('util');\nconst utils = require('./utils');\n\nconst ALLOWED_GEOWITHIN_GEOJSON_TYPES = ['Polygon', 'MultiPolygon'];\n\n/**\n * Handles internal casting for query filters.\n *\n * @param {Schema} schema\n * @param {Object} obj Object to cast\n * @param {Object} options the query options\n * @param {Query} context passed to setters\n * @api private\n */\nmodule.exports = function cast(schema, obj, options, context) {\n  if (Array.isArray(obj)) {\n    throw new Error('Query filter must be an object, got an array ', util.inspect(obj));\n  }\n\n  // bson 1.x has the unfortunate tendency to remove filters that have a top-level\n  // `_bsontype` property. But we should still allow ObjectIds because\n  // `Collection#find()` has a special case to support `find(objectid)`.\n  // Should remove this when we upgrade to bson 4.x. See gh-8222, gh-8268\n  if (obj.hasOwnProperty('_bsontype') && obj._bsontype !== 'ObjectID') {\n    delete obj._bsontype;\n  }\n\n  const paths = Object.keys(obj);\n  let i = paths.length;\n  let _keys;\n  let any$conditionals;\n  let schematype;\n  let nested;\n  let path;\n  let type;\n  let val;\n\n  options = options || {};\n\n  while (i--) {\n    path = paths[i];\n    val = obj[path];\n\n    if (path === '$or' || path === '$nor' || path === '$and') {\n      let k = val.length;\n\n      while (k--) {\n        val[k] = cast(schema, val[k], options, context);\n      }\n    } else if (path === '$where') {\n      type = typeof val;\n\n      if (type !== 'string' && type !== 'function') {\n        throw new Error('Must have a string or function for $where');\n      }\n\n      if (type === 'function') {\n        obj[path] = val.toString();\n      }\n\n      continue;\n    } else if (path === '$elemMatch') {\n      val = cast(schema, val, options, context);\n    } else if (path === '$text') {\n      val = castTextSearch(val, path);\n    } else {\n      if (!schema) {\n        // no casting for Mixed types\n        continue;\n      }\n\n      schematype = schema.path(path);\n\n      // Check for embedded discriminator paths\n      if (!schematype) {\n        const split = path.split('.');\n        let j = split.length;\n        while (j--) {\n          const pathFirstHalf = split.slice(0, j).join('.');\n          const pathLastHalf = split.slice(j).join('.');\n          const _schematype = schema.path(pathFirstHalf);\n          const discriminatorKey = get(_schematype, 'schema.options.discriminatorKey');\n\n          // gh-6027: if we haven't found the schematype but this path is\n          // underneath an embedded discriminator and the embedded discriminator\n          // key is in the query, use the embedded discriminator schema\n          if (_schematype != null &&\n              get(_schematype, 'schema.discriminators') != null &&\n              discriminatorKey != null &&\n              pathLastHalf !== discriminatorKey) {\n            const discriminatorVal = get(obj, pathFirstHalf + '.' + discriminatorKey);\n            if (discriminatorVal != null) {\n              schematype = _schematype.schema.discriminators[discriminatorVal].\n                path(pathLastHalf);\n            }\n          }\n        }\n      }\n\n      if (!schematype) {\n        // Handle potential embedded array queries\n        const split = path.split('.');\n        let j = split.length;\n        let pathFirstHalf;\n        let pathLastHalf;\n        let remainingConds;\n\n        // Find the part of the var path that is a path of the Schema\n        while (j--) {\n          pathFirstHalf = split.slice(0, j).join('.');\n          schematype = schema.path(pathFirstHalf);\n          if (schematype) {\n            break;\n          }\n        }\n\n        // If a substring of the input path resolves to an actual real path...\n        if (schematype) {\n          // Apply the casting; similar code for $elemMatch in schema/array.js\n          if (schematype.caster && schematype.caster.schema) {\n            remainingConds = {};\n            pathLastHalf = split.slice(j).join('.');\n            remainingConds[pathLastHalf] = val;\n            obj[path] = cast(schematype.caster.schema, remainingConds, options, context)[pathLastHalf];\n          } else {\n            obj[path] = val;\n          }\n          continue;\n        }\n\n        if (utils.isObject(val)) {\n          // handle geo schemas that use object notation\n          // { loc: { long: Number, lat: Number }\n\n          let geo = '';\n          if (val.$near) {\n            geo = '$near';\n          } else if (val.$nearSphere) {\n            geo = '$nearSphere';\n          } else if (val.$within) {\n            geo = '$within';\n          } else if (val.$geoIntersects) {\n            geo = '$geoIntersects';\n          } else if (val.$geoWithin) {\n            geo = '$geoWithin';\n          }\n\n          if (geo) {\n            const numbertype = new Types.Number('__QueryCasting__');\n            let value = val[geo];\n\n            if (val.$maxDistance != null) {\n              val.$maxDistance = numbertype.castForQueryWrapper({\n                val: val.$maxDistance,\n                context: context\n              });\n            }\n            if (val.$minDistance != null) {\n              val.$minDistance = numbertype.castForQueryWrapper({\n                val: val.$minDistance,\n                context: context\n              });\n            }\n\n            if (geo === '$within') {\n              const withinType = value.$center\n                  || value.$centerSphere\n                  || value.$box\n                  || value.$polygon;\n\n              if (!withinType) {\n                throw new Error('Bad $within parameter: ' + JSON.stringify(val));\n              }\n\n              value = withinType;\n            } else if (geo === '$near' &&\n                typeof value.type === 'string' && Array.isArray(value.coordinates)) {\n              // geojson; cast the coordinates\n              value = value.coordinates;\n            } else if ((geo === '$near' || geo === '$nearSphere' || geo === '$geoIntersects') &&\n                value.$geometry && typeof value.$geometry.type === 'string' &&\n                Array.isArray(value.$geometry.coordinates)) {\n              if (value.$maxDistance != null) {\n                value.$maxDistance = numbertype.castForQueryWrapper({\n                  val: value.$maxDistance,\n                  context: context\n                });\n              }\n              if (value.$minDistance != null) {\n                value.$minDistance = numbertype.castForQueryWrapper({\n                  val: value.$minDistance,\n                  context: context\n                });\n              }\n              if (utils.isMongooseObject(value.$geometry)) {\n                value.$geometry = value.$geometry.toObject({\n                  transform: false,\n                  virtuals: false\n                });\n              }\n              value = value.$geometry.coordinates;\n            } else if (geo === '$geoWithin') {\n              if (value.$geometry) {\n                if (utils.isMongooseObject(value.$geometry)) {\n                  value.$geometry = value.$geometry.toObject({ virtuals: false });\n                }\n                const geoWithinType = value.$geometry.type;\n                if (ALLOWED_GEOWITHIN_GEOJSON_TYPES.indexOf(geoWithinType) === -1) {\n                  throw new Error('Invalid geoJSON type for $geoWithin \"' +\n                    geoWithinType + '\", must be \"Polygon\" or \"MultiPolygon\"');\n                }\n                value = value.$geometry.coordinates;\n              } else {\n                value = value.$box || value.$polygon || value.$center ||\n                  value.$centerSphere;\n                if (utils.isMongooseObject(value)) {\n                  value = value.toObject({ virtuals: false });\n                }\n              }\n            }\n\n            _cast(value, numbertype, context);\n            continue;\n          }\n        }\n\n        if (schema.nested[path]) {\n          continue;\n        }\n        if (options.upsert && options.strict) {\n          if (options.strict === 'throw') {\n            throw new StrictModeError(path);\n          }\n          throw new StrictModeError(path, 'Path \"' + path + '\" is not in ' +\n            'schema, strict mode is `true`, and upsert is `true`.');\n        } else if (options.strictQuery === 'throw') {\n          throw new StrictModeError(path, 'Path \"' + path + '\" is not in ' +\n            'schema and strictQuery is \\'throw\\'.');\n        } else if (options.strictQuery) {\n          delete obj[path];\n        }\n      } else if (val == null) {\n        continue;\n      } else if (val.constructor.name === 'Object') {\n        any$conditionals = Object.keys(val).some(function(k) {\n          return k.startsWith('$') && k !== '$id' && k !== '$ref';\n        });\n\n        if (!any$conditionals) {\n          obj[path] = schematype.castForQueryWrapper({\n            val: val,\n            context: context\n          });\n        } else {\n          const ks = Object.keys(val);\n          let $cond;\n\n          let k = ks.length;\n\n          while (k--) {\n            $cond = ks[k];\n            nested = val[$cond];\n\n            if ($cond === '$not') {\n              if (nested && schematype && !schematype.caster) {\n                _keys = Object.keys(nested);\n                if (_keys.length && _keys[0].startsWith('$')) {\n                  for (const key in nested) {\n                    nested[key] = schematype.castForQueryWrapper({\n                      $conditional: key,\n                      val: nested[key],\n                      context: context\n                    });\n                  }\n                } else {\n                  val[$cond] = schematype.castForQueryWrapper({\n                    $conditional: $cond,\n                    val: nested,\n                    context: context\n                  });\n                }\n                continue;\n              }\n              cast(schematype.caster ? schematype.caster.schema : schema, nested, options, context);\n            } else {\n              val[$cond] = schematype.castForQueryWrapper({\n                $conditional: $cond,\n                val: nested,\n                context: context\n              });\n            }\n          }\n        }\n      } else if (Array.isArray(val) && ['Buffer', 'Array'].indexOf(schematype.instance) === -1) {\n        const casted = [];\n        for (let valIndex = 0; valIndex < val.length; valIndex++) {\n          casted.push(schematype.castForQueryWrapper({\n            val: val[valIndex],\n            context: context\n          }));\n        }\n\n        obj[path] = { $in: casted };\n      } else {\n        obj[path] = schematype.castForQueryWrapper({\n          val: val,\n          context: context\n        });\n      }\n    }\n  }\n\n  return obj;\n};\n\nfunction _cast(val, numbertype, context) {\n  if (Array.isArray(val)) {\n    val.forEach(function(item, i) {\n      if (Array.isArray(item) || utils.isObject(item)) {\n        return _cast(item, numbertype, context);\n      }\n      val[i] = numbertype.castForQueryWrapper({ val: item, context: context });\n    });\n  } else {\n    const nearKeys = Object.keys(val);\n    let nearLen = nearKeys.length;\n    while (nearLen--) {\n      const nkey = nearKeys[nearLen];\n      const item = val[nkey];\n      if (Array.isArray(item) || utils.isObject(item)) {\n        _cast(item, numbertype, context);\n        val[nkey] = item;\n      } else {\n        val[nkey] = numbertype.castForQuery({ val: item, context: context });\n      }\n    }\n  }\n}"]},"metadata":{},"sourceType":"script"}