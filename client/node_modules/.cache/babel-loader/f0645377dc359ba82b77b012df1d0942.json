{"ast":null,"code":"'use strict';\n\nconst symbols = require('../../schema/symbols');\n\nconst utils = require('../../utils');\n/*!\n * ignore\n */\n\n\nmodule.exports = applyHooks;\n/*!\n * ignore\n */\n\napplyHooks.middlewareFunctions = ['deleteOne', 'save', 'validate', 'remove', 'updateOne', 'init'];\n/*!\n * Register hooks for this model\n *\n * @param {Model} model\n * @param {Schema} schema\n */\n\nfunction applyHooks(model, schema, options) {\n  options = options || {};\n  const kareemOptions = {\n    useErrorHandlers: true,\n    numCallbackParams: 1,\n    nullResultByDefault: true,\n    contextParameter: true\n  };\n  const objToDecorate = options.decorateDoc ? model : model.prototype;\n  model.$appliedHooks = true;\n\n  for (const key of Object.keys(schema.paths)) {\n    const type = schema.paths[key];\n    let childModel = null;\n\n    if (type.$isSingleNested) {\n      childModel = type.caster;\n    } else if (type.$isMongooseDocumentArray) {\n      childModel = type.Constructor;\n    } else {\n      continue;\n    }\n\n    if (childModel.$appliedHooks) {\n      continue;\n    }\n\n    applyHooks(childModel, type.schema, options);\n\n    if (childModel.discriminators != null) {\n      const keys = Object.keys(childModel.discriminators);\n\n      for (let j = 0; j < keys.length; ++j) {\n        applyHooks(childModel.discriminators[keys[j]], childModel.discriminators[keys[j]].schema, options);\n      }\n    }\n  } // Built-in hooks rely on hooking internal functions in order to support\n  // promises and make it so that `doc.save.toString()` provides meaningful\n  // information.\n\n\n  const middleware = schema.s.hooks.filter(hook => {\n    if (hook.name === 'updateOne' || hook.name === 'deleteOne') {\n      return !!hook['document'];\n    }\n\n    if (hook.name === 'remove') {\n      return hook['document'] == null || !!hook['document'];\n    }\n\n    return true;\n  }).filter(hook => {\n    // If user has overwritten the method, don't apply built-in middleware\n    if (schema.methods[hook.name]) {\n      return !hook.fn[symbols.builtInMiddleware];\n    }\n\n    return true;\n  });\n  model._middleware = middleware;\n  objToDecorate.$__save = middleware.createWrapper('save', objToDecorate.$__save, null, kareemOptions);\n  objToDecorate.$__originalValidate = objToDecorate.$__originalValidate || objToDecorate.$__validate;\n  objToDecorate.$__validate = middleware.createWrapper('validate', objToDecorate.$__originalValidate, null, kareemOptions);\n  objToDecorate.$__remove = middleware.createWrapper('remove', objToDecorate.$__remove, null, kareemOptions);\n  objToDecorate.$__deleteOne = middleware.createWrapper('deleteOne', objToDecorate.$__deleteOne, null, kareemOptions);\n  objToDecorate.$__init = middleware.createWrapperSync('init', objToDecorate.$__init, null, kareemOptions); // Support hooks for custom methods\n\n  const customMethods = Object.keys(schema.methods);\n  const customMethodOptions = Object.assign({}, kareemOptions, {\n    // Only use `checkForPromise` for custom methods, because mongoose\n    // query thunks are not as consistent as I would like about returning\n    // a nullish value rather than the query. If a query thunk returns\n    // a query, `checkForPromise` causes infinite recursion\n    checkForPromise: true\n  });\n\n  for (const method of customMethods) {\n    if (!middleware.hasHooks(method)) {\n      // Don't wrap if there are no hooks for the custom method to avoid\n      // surprises. Also, `createWrapper()` enforces consistent async,\n      // so wrapping a sync method would break it.\n      continue;\n    }\n\n    const originalMethod = objToDecorate[method];\n\n    objToDecorate[method] = function () {\n      const args = Array.prototype.slice.call(arguments);\n      const cb = utils.last(args);\n      const argsWithoutCallback = typeof cb === 'function' ? args.slice(0, args.length - 1) : args;\n      return utils.promiseOrCallback(cb, callback => {\n        return this[`$__${method}`].apply(this, argsWithoutCallback.concat([callback]));\n      }, model.events);\n    };\n\n    objToDecorate[`$__${method}`] = middleware.createWrapper(method, originalMethod, null, customMethodOptions);\n  }\n}","map":{"version":3,"sources":["D:/Other/Git/Developer-Connector/node_modules/mongoose/lib/helpers/model/applyHooks.js"],"names":["symbols","require","utils","module","exports","applyHooks","middlewareFunctions","model","schema","options","kareemOptions","useErrorHandlers","numCallbackParams","nullResultByDefault","contextParameter","objToDecorate","decorateDoc","prototype","$appliedHooks","key","Object","keys","paths","type","childModel","$isSingleNested","caster","$isMongooseDocumentArray","Constructor","discriminators","j","length","middleware","s","hooks","filter","hook","name","methods","fn","builtInMiddleware","_middleware","$__save","createWrapper","$__originalValidate","$__validate","$__remove","$__deleteOne","$__init","createWrapperSync","customMethods","customMethodOptions","assign","checkForPromise","method","hasHooks","originalMethod","args","Array","slice","call","arguments","cb","last","argsWithoutCallback","promiseOrCallback","callback","apply","concat","events"],"mappings":"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","sourcesContent":["'use strict';\n\nconst symbols = require('../../schema/symbols');\nconst utils = require('../../utils');\n\n/*!\n * ignore\n */\n\nmodule.exports = applyHooks;\n\n/*!\n * ignore\n */\n\napplyHooks.middlewareFunctions = [\n  'deleteOne',\n  'save',\n  'validate',\n  'remove',\n  'updateOne',\n  'init'\n];\n\n/*!\n * Register hooks for this model\n *\n * @param {Model} model\n * @param {Schema} schema\n */\n\nfunction applyHooks(model, schema, options) {\n  options = options || {};\n\n  const kareemOptions = {\n    useErrorHandlers: true,\n    numCallbackParams: 1,\n    nullResultByDefault: true,\n    contextParameter: true\n  };\n  const objToDecorate = options.decorateDoc ? model : model.prototype;\n\n  model.$appliedHooks = true;\n  for (const key of Object.keys(schema.paths)) {\n    const type = schema.paths[key];\n    let childModel = null;\n    if (type.$isSingleNested) {\n      childModel = type.caster;\n    } else if (type.$isMongooseDocumentArray) {\n      childModel = type.Constructor;\n    } else {\n      continue;\n    }\n\n    if (childModel.$appliedHooks) {\n      continue;\n    }\n\n    applyHooks(childModel, type.schema, options);\n    if (childModel.discriminators != null) {\n      const keys = Object.keys(childModel.discriminators);\n      for (let j = 0; j < keys.length; ++j) {\n        applyHooks(childModel.discriminators[keys[j]],\n          childModel.discriminators[keys[j]].schema, options);\n      }\n    }\n  }\n\n  // Built-in hooks rely on hooking internal functions in order to support\n  // promises and make it so that `doc.save.toString()` provides meaningful\n  // information.\n\n  const middleware = schema.s.hooks.\n    filter(hook => {\n      if (hook.name === 'updateOne' || hook.name === 'deleteOne') {\n        return !!hook['document'];\n      }\n      if (hook.name === 'remove') {\n        return hook['document'] == null || !!hook['document'];\n      }\n      return true;\n    }).\n    filter(hook => {\n      // If user has overwritten the method, don't apply built-in middleware\n      if (schema.methods[hook.name]) {\n        return !hook.fn[symbols.builtInMiddleware];\n      }\n\n      return true;\n    });\n\n  model._middleware = middleware;\n\n  objToDecorate.$__save = middleware.\n    createWrapper('save', objToDecorate.$__save, null, kareemOptions);\n\n  objToDecorate.$__originalValidate = objToDecorate.$__originalValidate || objToDecorate.$__validate;\n  objToDecorate.$__validate = middleware.\n    createWrapper('validate', objToDecorate.$__originalValidate, null, kareemOptions);\n  objToDecorate.$__remove = middleware.\n    createWrapper('remove', objToDecorate.$__remove, null, kareemOptions);\n  objToDecorate.$__deleteOne = middleware.\n    createWrapper('deleteOne', objToDecorate.$__deleteOne, null, kareemOptions);\n  objToDecorate.$__init = middleware.\n    createWrapperSync('init', objToDecorate.$__init, null, kareemOptions);\n\n  // Support hooks for custom methods\n  const customMethods = Object.keys(schema.methods);\n  const customMethodOptions = Object.assign({}, kareemOptions, {\n    // Only use `checkForPromise` for custom methods, because mongoose\n    // query thunks are not as consistent as I would like about returning\n    // a nullish value rather than the query. If a query thunk returns\n    // a query, `checkForPromise` causes infinite recursion\n    checkForPromise: true\n  });\n  for (const method of customMethods) {\n    if (!middleware.hasHooks(method)) {\n      // Don't wrap if there are no hooks for the custom method to avoid\n      // surprises. Also, `createWrapper()` enforces consistent async,\n      // so wrapping a sync method would break it.\n      continue;\n    }\n    const originalMethod = objToDecorate[method];\n    objToDecorate[method] = function() {\n      const args = Array.prototype.slice.call(arguments);\n      const cb = utils.last(args);\n      const argsWithoutCallback = typeof cb === 'function' ?\n        args.slice(0, args.length - 1) : args;\n      return utils.promiseOrCallback(cb, callback => {\n        return this[`$__${method}`].apply(this,\n          argsWithoutCallback.concat([callback]));\n      }, model.events);\n    };\n    objToDecorate[`$__${method}`] = middleware.\n      createWrapper(method, originalMethod, null, customMethodOptions);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}